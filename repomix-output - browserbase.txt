This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-30T22:14:00.750Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.changeset/
  config.json
  tender-years-crash.md
.github/
  workflows/
    ci.yml
    release.yml
  pull_request_template
docs/
  release.md
evals/
  assets/
    cart.html
    peeler.html
  deterministic/
    tests/
      BrowserContext/
        addInitScript.test.ts
        cookies.test.ts
        page.test.ts
        routing.test.ts
      page/
        addInitScript.test.ts
        addRemoveLocatorHandler.test.ts
        addTags.test.ts
        bringToFront.test.ts
        content.test.ts
        contexts.test.ts
        downloads.test.ts
        evaluate.test.ts
        expose.test.ts
        frames.test.ts
        getBy.test.ts
        navigation.test.ts
        pageContext.test.ts
        reload.test.ts
        uploads.test.ts
        waitFor.test.ts
    playwright.config.ts
    stagehand.config.ts
  tasks/
    allrecipes.ts
    amazon_add_to_cart.ts
    apple.ts
    arxiv.ts
    bidnet.ts
    combination_sauce.ts
    costar.ts
    expedia_search.ts
    expedia.ts
    extract_aigrant_companies.ts
    extract_area_codes.ts
    extract_baptist_health.ts
    extract_capacitor_info.ts
    extract_collaborators.ts
    extract_github_commits.ts
    extract_github_stars.ts
    extract_memorial_healthcare.ts
    extract_nhl_stats.ts
    extract_partners.ts
    extract_press_releases.ts
    extract_professional_info.ts
    extract_public_notices.ts
    extract_regulations.ts
    extract_research_reports.ts
    extract_resistor_info.ts
    extract_rockauto.ts
    extract_snowshoeing_destinations.ts
    extract_staff_members.ts
    google_jobs.ts
    homedepot.ts
    ibm.ts
    imdb_movie_details.ts
    ionwave_observe.ts
    ionwave.ts
    laroche_form.ts
    nonsense_action.ts
    panamcs.ts
    peeler_complex.ts
    peeler_simple.ts
    rakuten_jp.ts
    sciquest.ts
    shopify_homepage.ts
    simple_google_search.ts
    stock_x.ts
    ted_talk.ts
    vanta_h.ts
    vanta.ts
    vantechjournal.ts
    wichita.ts
    wikipedia.ts
  args.ts
  env.ts
  evals.config.json
  index.eval.ts
  initStagehand.ts
  logger.ts
  scoring.ts
  taskConfig.ts
  utils.ts
examples/
  2048.ts
  debugUrl.ts
  example.ts
  parameterizeApiKey.ts
  stagehand.config.ts
lib/
  cache/
    ActionCache.ts
    BaseCache.ts
    LLMCache.ts
  dom/
    debug.ts
    genDomScripts.ts
    global.d.ts
    index.ts
    process.ts
    utils.ts
    xpathUtils.ts
  handlers/
    actHandler.ts
    extractHandler.ts
    observeHandler.ts
  llm/
    AnthropicClient.ts
    LLMClient.ts
    LLMProvider.ts
    OpenAIClient.ts
  cache.ts
  index.ts
  inference.ts
  prompt.ts
  StagehandContext.ts
  StagehandPage.ts
  utils.ts
  vision.ts
types/
  act.ts
  browser.ts
  evals.ts
  inference.ts
  log.ts
  model.ts
  page.ts
  playwright.ts
  stagehand.ts
  textannotation.ts
.env.example
.gitignore
.prettierignore
.prettierrc
CHANGELOG.md
eslint.config.mjs
LICENSE
package.json
README.md
ROADMAP.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .changeset/config.json
================
{
  "$schema": "https://unpkg.com/@changesets/config@2.1.1/schema.json",
  "commit": false,
  "fixed": [],
  "linked": [],
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "access": "public",
  "changelog": [
    "@changesets/changelog-github",
    {
      "repo": "browserbase/stagehand"
    }
  ],
  "snapshot": {
    "useCalculatedVersion": true,
    "prereleaseTemplate": "alpha-{commit}",
    "tag": "alpha"
  }
}

================
File: .changeset/tender-years-crash.md
================
---
"@browserbasehq/stagehand": patch
---

Remove duplicate logging and expose Page/BrowserContext types

================
File: .github/workflows/ci.yml
================
name: Evals

on:
  push:
    branches:
      - main
  pull_request:
    types:
      - opened
      - synchronize

env:
  EVAL_MODELS: "gpt-4o,gpt-4o-mini,claude-3-5-sonnet-latest"
  EVAL_CATEGORIES: "observe,act,combination,extract,text_extract"

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  run-lint:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Run Lint
        run: npm run lint

  run-build:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Run Build
        run: npm run build

  run-e2e-tests:
    needs: [run-lint, run-build]
    runs-on: ubuntu-latest
    timeout-minutes: 50
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      - name: Run E2E Tests
        run: npm run e2e

  run-act-evals:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [run-text-extract-evals]
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BRAINTRUST_API_KEY: ${{ secrets.BRAINTRUST_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true
      EVAL_ENV: browserbase

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      - name: Run Act Evals
        run: npm run evals category act

      - name: Log Act Evals Performance
        run: |
          experimentName=$(jq -r '.experimentName' eval-summary.json)
          echo "View results at https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentName}"
          if [ -f eval-summary.json ]; then
            act_score=$(jq '.categories.act' eval-summary.json)
            echo "Act category score: $act_score%"
            if (( $(echo "$act_score < 80" | bc -l) )); then
              echo "Act category score is below 80%. Failing CI."
              exit 1
            fi
          else
            echo "Eval summary not found for act category. Failing CI."
            exit 1
          fi

  run-extract-evals:
    needs: [run-lint, run-build, run-e2e-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 50
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BRAINTRUST_API_KEY: ${{ secrets.BRAINTRUST_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true
      EVAL_ENV: browserbase
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      # 1. Run extract category with domExtract
      - name: Run Extract Evals (domExtract)
        run: npm run evals category extract -- --extract-method=domExtract
      - name: Save Extract Dom Results
        run: mv eval-summary.json eval-summary-extract-dom.json

      # 2. Once domExtract finishes, run extract category with textExtract
      - name: Run Extract Evals (textExtract)
        run: npm run evals category extract -- --extract-method=textExtract
      - name: Save Extract Text Results
        run: mv eval-summary.json eval-summary-extract-text.json

      # 3. Log and Compare Extract Evals Performance
      - name: Log and Compare Extract Evals Performance
        run: |
          experimentNameDom=$(jq -r '.experimentName' eval-summary-extract-dom.json)
          dom_score=$(jq '.categories.extract' eval-summary-extract-dom.json)
          echo "DomExtract Extract category score: $dom_score%"
          echo "View domExtract results: https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentNameDom}"

          experimentNameText=$(jq -r '.experimentName' eval-summary-extract-text.json)
          text_score=$(jq '.categories.extract' eval-summary-extract-text.json)
          echo "TextExtract Extract category score: $text_score%"
          echo "View textExtract results: https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentNameText}"

          # 4. If domExtract <80% fail CI
          if (( $(echo "$dom_score < 80" | bc -l) )); then
            echo "DomExtract extract category score is below 80%. Failing CI."
            exit 1
          fi

  run-text-extract-evals:
    needs: [run-extract-evals]
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BRAINTRUST_API_KEY: ${{ secrets.BRAINTRUST_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true
      EVAL_ENV: browserbase
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      # 1. Run text_extract category with textExtract first
      - name: Run text_extract Evals (textExtract)
        run: npm run evals category text_extract -- --extract-method=textExtract
      - name: Save text_extract Text Results
        run: mv eval-summary.json eval-summary-text_extract-text.json

      # 2. Then run text_extract category with domExtract
      - name: Run text_extract Evals (domExtract)
        run: npm run evals category text_extract -- --extract-method=domExtract
      - name: Save text_extract Dom Results
        run: mv eval-summary.json eval-summary-text_extract-dom.json

      # 3. Log and Compare text_extract Evals Performance
      - name: Log and Compare text_extract Evals Performance
        run: |
          experimentNameText=$(jq -r '.experimentName' eval-summary-text_extract-text.json)
          text_score=$(jq '.categories.text_extract' eval-summary-text_extract-text.json)
          echo "TextExtract text_extract category score: $text_score%"
          echo "View textExtract results: https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentNameText}"

          experimentNameDom=$(jq -r '.experimentName' eval-summary-text_extract-dom.json)
          dom_score=$(jq '.categories.text_extract' eval-summary-text_extract-dom.json)
          echo "DomExtract text_extract category score: $dom_score%"
          echo "View domExtract results: https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentNameDom}"

          # 4. If textExtract (for text_extract category) <80% fail CI
          if (( $(echo "$text_score < 80" | bc -l) )); then
            echo "textExtract text_extract category score is below 80%. Failing CI."
            exit 1
          fi

  run-observe-evals:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [run-act-evals]
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BRAINTRUST_API_KEY: ${{ secrets.BRAINTRUST_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true
      EVAL_ENV: browserbase

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      - name: Run Observe Evals
        run: npm run evals category observe

      - name: Log Observe Evals Performance
        run: |
          experimentName=$(jq -r '.experimentName' eval-summary.json)
          echo "View results at https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentName}"
          if [ -f eval-summary.json ]; then
            observe_score=$(jq '.categories.observe' eval-summary.json)
            echo "Observe category score: $observe_score%"
            if (( $(echo "$observe_score < 80" | bc -l) )); then
              echo "Observe category score is below 80%. Failing CI."
              exit 1
            fi
          else
            echo "Eval summary not found for observe category. Failing CI."
            exit 1
          fi

  run-combination-evals:
    runs-on: ubuntu-latest
    timeout-minutes: 40
    needs: [run-observe-evals]
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      BRAINTRUST_API_KEY: ${{ secrets.BRAINTRUST_API_KEY }}
      BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
      BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}
      HEADLESS: true
      EVAL_ENV: browserbase

    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm install --no-frozen-lockfile

      - name: Install Playwright browsers
        run: npm exec playwright install --with-deps

      - name: Run Combination Evals
        run: npm run evals category combination

      - name: Log Combination Evals Performance
        run: |
          experimentName=$(jq -r '.experimentName' eval-summary.json)
          echo "View results at https://www.braintrust.dev/app/Browserbase/p/stagehand/experiments/${experimentName}"
          if [ -f eval-summary.json ]; then
            combination_score=$(jq '.categories.combination' eval-summary.json)
            echo "Combination category score: $combination_score%"
            exit 0
          else
            echo "Eval summary not found for combination category. Failing CI."
            exit 1
          fi

================
File: .github/workflows/release.yml
================
name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Node.js 20.x
        uses: actions/setup-node@v3
        with:
          node-version: 20.x
          registry-url: "https://registry.npmjs.org"

      - name: Install Dependencies
        run: npm install

      - name: Build
        run: npm run build

      - name: Create Release Pull Request or Publish to npm
        id: changesets
        uses: changesets/action@v1
        with:
          publish: npm run release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Publish Canary
        if: github.ref == 'refs/heads/main'
        run: |
          npm config set //registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}
          git checkout main
          npm run release-canary
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

================
File: .github/pull_request_template
================
# why

# what changed

# test plan

================
File: docs/release.md
================
# Releasing

We use [Changesets](https://github.com/changesets/changesets) to version and release our packages.

When we merge to main, the release workflow will:

1. Create a release pull request with:
   - A version bump for the package calculated by the changesets.
   - A changelog entry summarizing the changes in the release.
1. Create an `alpha` version of the package with whatever is merged to main, and you can install it with `npm install @browserbasehq/stagehand@alpha`. This is useful for testing the release before it's published to the `latest` tag.

When the pull request is merged, the release workflow will publish the package to npm with the version calculated by the changesets.

For more information on how changesets work, see the [changesets docs](https://github.com/changesets/changesets) and our [release.yml file](/.github/workflows/release.yml).

# Manually Releasing

> [!WARNING]
> You should not need to manually release unless absolutely necessary. Our automated release workflow handles this for you when changes are merged to main.

When you're ready to cut a release, start by versioning the packages:

```
npx changeset version
```

This will consume the changesets in [`.changeset`](../.changeset) and update the [changelog](../CHANGELOG.md) and [`package.json`](../package.json):

```
% git status --short
 M CHANGELOG.md
 M package.json
```

Based on the versions implications declared by the changesets, the package version will be updated to the next patch, minor, or major:

```diff
   "name": "@browserbasehq/stagehand",
-  "version": "1.3.0",
+  "version": "1.3.1",
```

Since we updated the `package.json`, we should also update the lockfile ([`package-lock.json`](../package-lock.json)) for tidiness:

```
npm install
```

Now the lockfile should be updated:

```
% git status --short
 M CHANGELOG.md
 M package-lock.json
 M package.json
```

The diff will look something like this:

```diff
 {
   "name": "@browserbasehq/stagehand",
-  "version": "1.3.0",
+  "version": "1.3.1",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "@browserbasehq/stagehand",
-      "version": "1.3.0",
+      "version": "1.3.1",
```

At this point we're ready to commit our changes.
It's probably a good idea to have some consistency around the name of this commit message:

```
git commit -am 'Version Packages'
```

Ok, now it's time to publish the release.
Before we do, we have to build the artifacts that comprise the tarball.
Let's clean our working directory first so that we don't accidentally include anything in the tarball that shouldn't be there:

```
% git clean -fxd -e .env
Removing dist/
Removing lib/dom/build/
Removing node_modules/
```

Let's reinstall dependencies and build the artifacts:

```
npm install && npm run build
```

Now we're ready to publish to NPM. You have to be logged in via the `npm` CLI and have to be part of the `@browserbasehq` org:

```
npx changeset publish
```

Congratulations! You just published a new version of `@browserbasehq/stagehand`. 🤘

In the process of publishing, Changesets created an [annotated git tag](https://git-scm.com/book/en/v2/Git-Basics-Tagging):

```
🦋  Creating git tag...
🦋  New tag:  v1.3.1
```

Let's push the commit and tag to GitHub for posterity:

```
git push --follow-tags
```

================
File: evals/assets/cart.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
      }
      const item = getQueryParam("item");
      document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("cartItem").textContent =
          `Congratulations, you have 1 ${item} in your cart`;
      });
    </script>
    <div id="cartItem"></div>
  </body>
</html>

================
File: evals/assets/peeler.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>Welcome to Our Page</h1>

    <div class="product-card">
      <div class="product-info">
        <h2>Knife Set</h2>
        <p>
          High-quality stainless steel knives for all your cooking needs.<a
            >my stuff</a
          >
          more stuff
        </p>
      </div>
      <button onclick="location.href='cart.html?item=B'">Add to cart</button>
    </div>
    <div class="product-card">
      <div class="product-info">
        <h2>Peeler</h2>
        <p>The ultimate tool for peeling fruits and vegetables.</p>
      </div>
      <button onclick="location.href='cart.html?item=A'">Add to cart</button>
    </div>
    <a href="cart.html" aria-role="button">
      <div>hi world</div>
    </a>
    <p>
      Baseball evolved from older
      <a href="/wiki/Bat-and-ball_games" title="Bat-and-ball games"
        >bat-and-ball games</a
      >
      already being played in England by the mid-18th century. This game was
      brought by immigrants to North America,
      <a
        href="/wiki/History_of_baseball_in_the_United_States"
        title="History of baseball in the United States"
        >where the modern version developed</a
      >.
    </p>
  </body>
</html>

================
File: evals/deterministic/tests/BrowserContext/addInitScript.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandContext - addInitScript", () => {
  test("should inject a script on the context before pages load", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const context = stagehand.context;

    await context.addInitScript(() => {
      const w = window as typeof window & {
        __testContextScriptVar?: string;
      };
      w.__testContextScriptVar = "Hello from context.initScript!";
    });

    const pageA = await context.newPage();
    await pageA.goto("https://example.com");

    const resultA = await pageA.evaluate(() => {
      const w = window as typeof window & {
        __testContextScriptVar?: string;
      };
      return w.__testContextScriptVar;
    });
    expect(resultA).toBe("Hello from context.initScript!");

    const pageB = await context.newPage();
    await pageB.goto("https://www.browserbase.com");

    const resultB = await pageB.evaluate(() => {
      const w = window as typeof window & {
        __testContextScriptVar?: string;
      };
      return w.__testContextScriptVar;
    });
    expect(resultB).toBe("Hello from context.initScript!");

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/BrowserContext/cookies.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib"; // Adjust the relative path as needed
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandContext - Cookies", () => {
  let stagehand: Stagehand;

  test.beforeEach(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterEach(async () => {
    await stagehand.close();
  });

  test("should add cookies and retrieve them", async () => {
    const context = stagehand.context; // This is the wrapped BrowserContext
    const url = "https://example.com";

    await context.addCookies([
      {
        name: "myCookie",
        value: "myValue",
        domain: "example.com",
        path: "/",
        expires: Math.floor(Date.now() / 1000) + 3600,
        httpOnly: false,
        secure: false,
        sameSite: "Lax",
      },
    ]);

    const cookies = await context.cookies(url);
    expect(cookies.length).toBeGreaterThan(0);

    const myCookie = cookies.find((c) => c.name === "myCookie");
    expect(myCookie).toBeDefined();
    expect(myCookie?.value).toBe("myValue");
  });

  test("should clear all cookies", async () => {
    const context = stagehand.context;
    const url = "https://example.com";

    await context.addCookies([
      {
        name: "myOtherCookie",
        value: "anotherValue",
        domain: "example.com",
        path: "/",
        expires: Math.floor(Date.now() / 1000) + 3600,
        httpOnly: false,
        secure: false,
        sameSite: "Lax",
      },
    ]);

    const cookiesBefore = await context.cookies(url);
    const found = cookiesBefore.some((c) => c.name === "myOtherCookie");
    expect(found).toBe(true);

    await context.clearCookies();

    const cookiesAfter = await context.cookies(url);
    const stillFound = cookiesAfter.some((c) => c.name === "myOtherCookie");
    expect(stillFound).toBe(false);
  });
});

================
File: evals/deterministic/tests/BrowserContext/page.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

import http from "http";
import express from "express";
import { Server as WebSocketServer } from "ws";

test.describe("StagehandContext - pages and newPage", () => {
  let stagehand: Stagehand;
  let server: http.Server;
  let wss: WebSocketServer;
  let serverPort: number;

  test.beforeAll(async () => {
    // 1. Spin up a local Express server
    const app = express();

    // Serve a single page at "/"
    app.get("/", (_req, res) => {
      res.set("Content-Type", "text/html");
      res.end(`
        <html>
          <head>
            <title>Test Page</title>
          </head>
          <body>
            <h1>Hello from local server</h1>
            <script>
              // Optionally register a service worker if you want it for demo:
              if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                  .then(() => console.log('SW registered'))
                  .catch(e => console.error('SW failed', e));
              }
            </script>
          </body>
        </html>
      `);
    });

    // Create the server on a random free port
    server = http.createServer(app);
    await new Promise<void>((resolve) => {
      server.listen(0, () => resolve());
    });
    const address = server.address();
    if (typeof address === "object" && address !== null) {
      serverPort = address.port;
    } else {
      throw new Error("Failed to get server port");
    }

    // Optionally set up a WebSocket for future tests
    wss = new WebSocketServer({ server, path: "/socket" });
    wss.on("connection", (ws) => {
      console.log("WebSocket client connected");
      ws.send("Hello from server WebSocket");
    });
  });

  test.beforeEach(async () => {
    // 2. Create & init Stagehand for each test
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterEach(async () => {
    await stagehand.close();
  });

  test.afterAll(async () => {
    // Shut down local server
    wss?.close();
    server?.close();
  });

  /**
   * Test context.newPage() and context.pages()
   */
  test("should create multiple pages and list them via context.pages()", async () => {
    const context = stagehand.context;

    // Create multiple pages
    const page1 = await context.newPage();
    const page2 = await context.newPage();

    // Confirm context.pages() sees them
    const allPages = context.pages();

    // We expect at least these 2 pages. If a default blank page existed, total might be more.
    // The key is that page1 & page2 are in the array:
    expect(allPages).toContain(page1);
    expect(allPages).toContain(page2);

    // Navigate page1 to the local server
    await page1.goto(`http://localhost:${serverPort}`);
    expect(await page1.title()).toBe("Test Page");
  });
});

================
File: evals/deterministic/tests/BrowserContext/routing.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

import http from "http";
import express from "express";
import { Server as WebSocketServer } from "ws";
import fs from "fs";
import path from "path";

const HAR_CONTENT = `{
  "log": {
    "version": "1.2",
    "creator": { "name": "PlaywrightTest", "version": "1.0" },
    "entries": [
      {
        "startedDateTime": "2023-01-01T00:00:00.000Z",
        "time": 5,
        "request": {
          "method": "GET",
          "url": "http://localhost/har-example.json",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [],
          "queryString": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "cookies": [],
          "headers": [{"name":"Content-Type","value":"application/json"}],
          "content": {
            "size": 27,
            "mimeType": "application/json",
            "text": "{\\"harKey\\":\\"harValue\\"}"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0
        },
        "cache": {},
        "timings": { "send": 0, "wait": 5, "receive": 0 }
      }
    ]
  }
}`;

test.describe("StagehandContext - Routing APIs with dynamic setup", () => {
  let stagehand: Stagehand;
  let server: http.Server;
  let wss: WebSocketServer;
  let serverPort: number;

  test.beforeAll(async () => {
    const app = express();

    app.get("/example.json", (_req, res) => {
      res.json({ original: "server-data" });
    });

    app.get("/har-example.json", (_req, res) => {
      res.json({
        fromServer:
          "This should be replaced by HAR if routeFromHar is in effect",
      });
    });

    server = http.createServer(app);
    await new Promise<void>((resolve) => {
      server.listen(0, () => resolve());
    });
    const address = server.address();
    if (typeof address === "object" && address !== null) {
      serverPort = address.port;
    } else {
      throw new Error("Failed to get server port");
    }

    // Set up a WebSocket endpoint at "/socket"
    wss = new WebSocketServer({ server, path: "/socket" });
    wss.on("connection", (ws) => {
      console.log("WebSocket client connected");
      ws.send("Hello from server WebSocket");

      // Echo messages back
      ws.on("message", (message) => {
        console.log("Server received WS message:", message);
        ws.send(`Server echo: ${message}`);
      });
    });
  });

  test.beforeEach(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterEach(async () => {
    await stagehand.close();
  });

  test.afterAll(async () => {
    wss?.close();
    server?.close();
  });

  test("should intercept requests, mock the response, handle websockets, and unroute them", async () => {
    const context = stagehand.context;
    const baseURL = `http://localhost:${serverPort}`;

    // 1. route: intercept "/example.json" and fulfill with a mock response
    await context.route("**/example.json", async (route) => {
      console.log("[route] Intercepting:", route.request().url());

      // Mock the response entirely:
      await route.fulfill({
        status: 200,
        contentType: "application/json",
        body: JSON.stringify({ mockedData: 1234 }),
      });
    });

    // 2. routeWebSocket: intercept "/socket"
    await context.routeWebSocket("**/socket", async (pageSideRoute) => {
      console.log("Intercepting WebSocket at:", pageSideRoute.url());

      // Connect to the real server
      const serverSideRoute = pageSideRoute.connectToServer();

      // Page -> Server
      pageSideRoute.onMessage((msg) => {
        console.log("Page -> Server message:", msg);
        // Forward to server side
        serverSideRoute.send(msg);
      });

      // Server -> Page
      serverSideRoute.onMessage((msg) => {
        console.log("Server -> Page message:", msg);
        pageSideRoute.send(msg);
      });
    });

    // 3. Open a page and fetch /example.json
    const page = await context.newPage();
    await page.goto(baseURL);

    const fetchResult = await page.evaluate(async () => {
      const res = await fetch("/example.json");
      return res.json();
    });
    // We should get the mocked data from our route, not the real 'server-data'
    expect(fetchResult.mockedData).toBe(1234);

    // 4. Test the WebSocket
    // We'll store messages from the server in an array so we can assert them
    const wsMessages: string[] = [];
    page.on("console", (msg) => {
      // We'll parse out the console logs we used for WebSocket
      if (msg.type() === "log") {
        wsMessages.push(msg.text());
      }
    });

    // Create a WS from the page
    await page.evaluate((port) => {
      const ws = new WebSocket(`ws://localhost:${port}/socket`);
      ws.onmessage = (evt) => {
        console.log(`WS message from server: ${evt.data}`);
      };
      setTimeout(() => {
        // send a message from the page side
        ws.send("Hello from the client");
      }, 1000);
    }, serverPort);

    // Wait a moment for messages
    await page.waitForTimeout(3000);

    // We expect the server to have initially sent "Hello from server WebSocket"
    // And also an echo of "Hello from the client" => "Server echo: Hello from the client"
    const initialHello = wsMessages.find((m) =>
      m.includes("Hello from server WebSocket"),
    );
    expect(initialHello).toBeTruthy();

    const echoMessage = wsMessages.find((m) =>
      m.includes("Server echo: Hello from the client"),
    );
    expect(echoMessage).toBeTruthy();

    // 5. unroute the JSON route
    await context.unroute("**/example.json");

    // 6. confirm the WebSocket route is still active
    // do a second fetch -> This time it won't be mocked
    const fetchResult2 = await page.evaluate(async () => {
      const res = await fetch("/example.json");
      return res.json();
    });
    // The real server returns { original: "server-data" }
    expect(fetchResult2.original).toBe("server-data");

    // 7. unrouteAll
    await context.unrouteAll();
  });

  test("should demonstrate routeFromHar usage", async () => {
    const harPath = path.join(__dirname, "tmp-test.har");

    const dynamicHar = HAR_CONTENT.replace(
      "http://localhost/har-example.json",
      `http://localhost:${serverPort}/har-example.json`,
    );

    fs.writeFileSync(harPath, dynamicHar, "utf-8");

    const context = stagehand.context;

    await context.routeFromHAR(harPath, { update: false });

    const page = await context.newPage();
    await page.goto(`http://localhost:${serverPort}/har-example.json`);

    const bodyText = await page.evaluate(() => document.body.innerText);
    console.log("HAR-based body text:", bodyText);
    expect(bodyText).toContain("harKey");
    expect(bodyText).toContain("harValue");

    await context.unrouteAll();
    fs.unlinkSync(harPath);
  });
});

================
File: evals/deterministic/tests/page/addInitScript.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - addInitScript", () => {
  test("should inject a script before the page loads", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;

    await page.addInitScript(() => {
      const w = window as typeof window & {
        __testInitScriptVar?: string;
      };
      w.__testInitScriptVar = "Hello from init script!";
    });

    await page.goto("https://example.com");

    const result = await page.evaluate(() => {
      const w = window as typeof window & {
        __testInitScriptVar?: string;
      };
      return w.__testInitScriptVar;
    });
    expect(result).toBe("Hello from init script!");

    await page.goto("https://www.browserbase.com/");
    const resultAfterNavigation = await page.evaluate(() => {
      const w = window as typeof window & {
        __testInitScriptVar?: string;
      };
      return w.__testInitScriptVar;
    });
    expect(resultAfterNavigation).toBe("Hello from init script!");

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/page/addRemoveLocatorHandler.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - addLocatorHandler and removeLocatorHandler", () => {
  // This HTML snippet is reused by both tests.
  // The "Sign up to the newsletter" overlay appears after 2 seconds.
  // The "No thanks" button hides it.
  const overlayHTML = `
    <html>
      <body>
        <button id="cta">Start here</button>
        <div id="overlay" style="display: none;">
          <p>Sign up to the newsletter</p>
          <button id="no-thanks">No thanks</button>
        </div>
        <script>
          // Show the overlay after 2 seconds
          setTimeout(() => {
            document.getElementById('overlay').style.display = 'block';
          }, 2000);

          // Hide the overlay when "No thanks" is clicked
          document.getElementById('no-thanks').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
          });
        </script>
      </body>
    </html>
  `;

  test("should use a custom locator handler to dismiss the overlay", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const { page } = stagehand;

    await page.addLocatorHandler(
      page.getByText("Sign up to the newsletter"),
      async () => {
        console.log("Overlay detected. Clicking 'No thanks' to remove it...");
        await page.getByRole("button", { name: "No thanks" }).click();
      },
    );

    await page.goto("https://example.com");
    await page.setContent(overlayHTML);

    await page.waitForTimeout(5000);

    await page.getByRole("button", { name: "Start here" }).click();

    const isOverlayVisible = await page
      .getByText("Sign up to the newsletter")
      .isVisible()
      .catch(() => false);

    await stagehand.close();

    expect(isOverlayVisible).toBeFalsy();
  });

  test("should remove a custom locator handler so overlay stays visible", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const { page } = stagehand;

    const locator = page.getByText("Sign up to the newsletter");
    await page.addLocatorHandler(locator, async () => {
      console.log("Overlay detected. Clicking 'No thanks' to remove it...");
      await page.getByRole("button", { name: "No thanks" }).click();
    });

    await page.removeLocatorHandler(locator);
    console.log("Locator handler removed — overlay will not be dismissed now.");

    await page.goto("https://example.com");
    await page.setContent(overlayHTML);

    await page.waitForTimeout(5000);

    await page.getByRole("button", { name: "Start here" }).click();

    const isOverlayVisible = await page
      .getByText("Sign up to the newsletter")
      .isVisible()
      .catch(() => false);

    await stagehand.close();
    expect(isOverlayVisible).toBe(true);
  });
});

================
File: evals/deterministic/tests/page/addTags.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - addScriptTag and addStyleTag", () => {
  let stagehand: Stagehand;

  test.beforeAll(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterAll(async () => {
    await stagehand.close();
  });

  test("should inject a script tag and have access to the defined function", async () => {
    const { page } = stagehand;

    await page.setContent(`
      <html>
      <body>
        <h1 id="greeting">Hello, world!</h1>
      </body>
      </html>
    `);

    await page.addScriptTag({
      content: `
        window.sayHello = function() {
          document.getElementById("greeting").textContent = "Hello from injected script!";
        }
      `,
    });

    await page.evaluate(() => {
      const w = window as typeof window & {
        sayHello?: () => void;
      };
      w.sayHello?.();
    });

    const text = await page.locator("#greeting").textContent();
    expect(text).toBe("Hello from injected script!");
  });

  test("should inject a style tag and apply styles", async () => {
    const { page } = stagehand;

    await page.setContent(`
      <html>
      <body>
        <div id="styledDiv">Some text</div>
      </body>
      </html>
    `);

    await page.addStyleTag({
      content: `
        #styledDiv {
          color: red;
          font-weight: bold;
        }
      `,
    });

    const color = await page.evaluate(() => {
      const el = document.getElementById("styledDiv");
      return window.getComputedStyle(el!).color;
    });
    expect(color).toBe("rgb(255, 0, 0)");

    const fontWeight = await page.evaluate(() => {
      const el = document.getElementById("styledDiv");
      return window.getComputedStyle(el!).fontWeight;
    });
    expect(["bold", "700"]).toContain(fontWeight);
  });
});

================
File: evals/deterministic/tests/page/bringToFront.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - bringToFront", () => {
  test("should bring a background page to the front and allow further actions", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const { page: page1 } = stagehand;

    const page2 = await stagehand.context.newPage();
    await page2.goto("https://example.com");
    const page2Title = await page2.title();
    console.log("Page2 Title:", page2Title);

    await page1.goto("https://www.google.com");
    const page1TitleBefore = await page1.title();
    console.log("Page1 Title before:", page1TitleBefore);

    await page1.bringToFront();

    await page1.goto("https://www.browserbase.com");
    const page1TitleAfter = await page1.title();
    console.log("Page1 Title after:", page1TitleAfter);

    await page2.bringToFront();
    const page2URLBefore = page2.url();
    console.log("Page2 URL before navigation:", page2URLBefore);

    await stagehand.close();

    expect(page1TitleBefore).toContain("Google");
    expect(page1TitleAfter).toContain("Browserbase");
    expect(page2Title).toContain("Example Domain");
  });
});

================
File: evals/deterministic/tests/page/content.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - content", () => {
  test("should retrieve the full HTML content of the page", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://example.com");
    const html = await page.content();
    expect(html).toContain("<title>Example Domain</title>");
    expect(html).toContain("<h1>Example Domain</h1>");

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/page/contexts.test.ts
================
import Browserbase from "@browserbasehq/sdk";
import { Stagehand } from "../../../../lib";
import { expect, test } from "@playwright/test";
import StagehandConfig from "../../stagehand.config";

// Configuration
const CONTEXT_TEST_URL = "https://docs.browserbase.com";
const BROWSERBASE_PROJECT_ID = process.env.BROWSERBASE_PROJECT_ID!;
const BROWSERBASE_API_KEY = process.env.BROWSERBASE_API_KEY!;

const bb = new Browserbase({
  apiKey: BROWSERBASE_API_KEY,
});

// Helper functions
function addHour(date: Date): number {
  const SECOND = 1000;
  return new Date(date.getTime() + 60 * 60 * 1000).getTime() / SECOND;
}

async function findCookie(stagehand: Stagehand, name: string) {
  const defaultContext = stagehand.context;
  const cookies = await defaultContext?.cookies();
  return cookies?.find((cookie) => cookie.name === name);
}

async function createContext() {
  console.log("Creating a new context...");
  const context = await bb.contexts.create({
    projectId: BROWSERBASE_PROJECT_ID,
  });
  const contextId = context.id;
  console.log(`Context created with ID: ${contextId}`);
  return contextId;
}

async function setRandomCookie(contextId: string, stagehand: Stagehand) {
  console.log(
    `Populating context ${contextId} during session ${stagehand.browserbaseSessionID}`,
  );
  const page = stagehand.page;

  await page.goto(CONTEXT_TEST_URL, { waitUntil: "domcontentloaded" });

  const now = new Date();
  const testCookieName = `bb_${now.getTime().toString()}`;
  const testCookieValue = now.toISOString();

  await stagehand.context.addCookies([
    {
      domain: `.${new URL(CONTEXT_TEST_URL).hostname}`,
      expires: addHour(now),
      name: testCookieName,
      path: "/",
      value: testCookieValue,
    },
  ]);

  expect(findCookie(stagehand, testCookieName)).toBeDefined();
  console.log(`Set test cookie: ${testCookieName}=${testCookieValue}`);
  return { testCookieName, testCookieValue };
}

test.describe("Contexts", () => {
  test("Persists and re-uses a context", async () => {
    let contextId: string;
    let testCookieName: string;
    let testCookieValue: string;
    let stagehand: Stagehand;

    await test.step("Create a context", async () => {
      contextId = await createContext();
    });

    await test.step("Instantiate Stagehand with the context to persist", async () => {
      // We will be adding cookies to the context in this session, so we need mark persist=true
      stagehand = new Stagehand({
        ...StagehandConfig,
        browserbaseSessionCreateParams: {
          projectId: BROWSERBASE_PROJECT_ID,
          browserSettings: {
            context: {
              id: contextId,
              persist: true,
            },
          },
        },
      });
      await stagehand.init();
    });

    await test.step("Set a random cookie on the page", async () => {
      ({ testCookieName } = await setRandomCookie(contextId, stagehand));

      const page = stagehand.page;
      await page.goto("https://www.google.com", {
        waitUntil: "domcontentloaded",
      });
      await page.goBack();
    });

    await test.step("Validate cookie persistence between pages", async () => {
      const cookie = await findCookie(stagehand, testCookieName);
      const found = !!cookie;
      expect(found).toBe(true);
      console.log("Cookie persisted between pages:", found);

      await stagehand.close();
      // Wait for context to persist
      console.log("Waiting for context to persist...");
      await new Promise((resolve) => setTimeout(resolve, 5000));
    });

    await test.step("Create another session with the same context", async () => {
      // We don't need to persist cookies in this session, so we can mark persist=false
      const newStagehand = new Stagehand({
        ...StagehandConfig,
        browserbaseSessionCreateParams: {
          projectId: BROWSERBASE_PROJECT_ID,
          browserSettings: {
            context: {
              id: contextId,
              persist: false,
            },
          },
        },
      });
      await newStagehand.init();
      console.log(
        `Reusing context ${contextId} during session ${newStagehand.browserbaseSessionID}`,
      );
      const newPage = newStagehand.page;
      await newPage.goto(CONTEXT_TEST_URL, { waitUntil: "domcontentloaded" });

      const foundCookie = await findCookie(newStagehand, testCookieName);
      console.log("Cookie found in new session:", !!foundCookie);
      console.log(
        "Cookie value matches:",
        foundCookie?.value === testCookieValue,
      );

      await newStagehand.close();
    });
  });
});

================
File: evals/deterministic/tests/page/downloads.test.ts
================
import { test, expect } from "@playwright/test";
import AdmZip from "adm-zip";
import StagehandConfig from "../../stagehand.config";
import { Stagehand } from "../../../../lib";
import Browserbase from "@browserbasehq/sdk";

const downloadRe = /sandstorm-(\d{13})+\.mp3/;

test("Downloads", async () => {
  const stagehand = new Stagehand(StagehandConfig);
  await stagehand.init();
  const page = stagehand.page;
  const context = stagehand.context;

  const client = await context.newCDPSession(page);
  await client.send("Browser.setDownloadBehavior", {
    behavior: "allow",
    // `downloadPath` gets appended to the browser's default download directory.
    // set to "downloads", it ends up being "/app/apps/browser/downloads/<file>".
    downloadPath: "downloads",
    eventsEnabled: true,
  });

  await page.goto("https://browser-tests-alpha.vercel.app/api/download-test");

  const [download] = await Promise.all([
    page.waitForEvent("download"),
    page.locator("#download").click(),
  ]);

  const downloadError = await download.failure();

  await stagehand.close();

  if (downloadError !== null) {
    throw new Error(
      `Download for session ${stagehand.browserbaseSessionID} failed: ${downloadError}`,
    );
  }

  expect(async () => {
    const bb = new Browserbase();
    const zipBuffer = await bb.sessions.downloads.list(
      stagehand.browserbaseSessionID,
    );
    if (!zipBuffer) {
      throw new Error(
        `Download buffer is empty for session ${stagehand.browserbaseSessionID}`,
      );
    }

    const zip = new AdmZip(Buffer.from(await zipBuffer.arrayBuffer()));
    const zipEntries = zip.getEntries();
    const mp3Entry = zipEntries.find((entry) =>
      downloadRe.test(entry.entryName),
    );

    if (!mp3Entry) {
      throw new Error(
        `Session ${stagehand.browserbaseSessionID} is missing a file matching "${downloadRe.toString()}" in its zip entries: ${JSON.stringify(zipEntries.map((entry) => entry.entryName))}`,
      );
    }

    const expectedFileSize = 6137541;
    expect(mp3Entry.header.size).toBe(expectedFileSize);
  }).toPass({
    timeout: 30_000,
  });
});

================
File: evals/deterministic/tests/page/evaluate.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - JavaScript Evaluation", () => {
  test("can evaluate JavaScript in the page context", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;

    await page.goto("https://example.com");

    const sum = await page.evaluate(() => 2 + 2);
    expect(sum).toBe(4);

    const pageTitle = await page.evaluate(() => document.title);
    expect(pageTitle).toMatch(/example/i);

    const obj = await page.evaluate(() => {
      return {
        message: "Hello from the browser",
        userAgent: navigator.userAgent,
      };
    });
    expect(obj).toHaveProperty("message", "Hello from the browser");
    expect(obj.userAgent).toBeDefined();

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/page/expose.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - evaluateHandle, exposeBinding, exposeFunction", () => {
  let stagehand: Stagehand;

  test.beforeAll(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterAll(async () => {
    await stagehand.close();
  });

  test("demonstrates evaluateHandle, exposeBinding, and exposeFunction", async () => {
    const { page } = stagehand;

    await page.setContent(`
      <html>
        <body>
          <div id="myDiv">Initial Text</div>
        </body>
      </html>
    `);

    const divHandle = await page.evaluateHandle(() => {
      return document.getElementById("myDiv");
    });
    await divHandle.evaluate((div, newText) => {
      div.textContent = newText;
    }, "Text updated via evaluateHandle");

    const text = await page.locator("#myDiv").textContent();
    expect(text).toBe("Text updated via evaluateHandle");

    await page.exposeBinding("myBinding", async (source, arg: string) => {
      console.log("myBinding called from page with arg:", arg);
      return `Node responded with: I got your message: "${arg}"`;
    });

    const responseFromBinding = await page.evaluate(async () => {
      const w = window as typeof window & {
        myBinding?: (arg: string) => Promise<string>;
      };
      return w.myBinding?.("Hello from the browser");
    });
    expect(responseFromBinding).toMatch(/I got your message/);

    await page.exposeFunction("addNumbers", (a: number, b: number) => {
      return a + b;
    });

    const sum = await page.evaluate(async () => {
      const w = window as typeof window & {
        addNumbers?: (a: number, b: number) => number;
      };
      return w.addNumbers?.(3, 7);
    });
    expect(sum).toBe(10);
  });
});

================
File: evals/deterministic/tests/page/frames.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - frame operations", () => {
  let stagehand: Stagehand;

  test.beforeAll(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterAll(async () => {
    await stagehand.close();
  });

  test("should use page.mainFrame(), page.frames(), page.frame(), and page.frameLocator()", async () => {
    const { page } = stagehand;

    await page.setContent(`
      <html>
        <body>
          <iframe
            name="frame-one"
            srcdoc="<html><body><h1>Hello from Frame 1</h1></body></html>">
          </iframe>

          <iframe
            name="frame-two"
            srcdoc="<html><body><h1>Hello from Frame 2</h1></body></html>">
          </iframe>
        </body>
      </html>
    `);

    await page.waitForSelector('iframe[name="frame-one"]');
    await page.waitForSelector('iframe[name="frame-two"]');

    const frames = page.frames();
    console.log(
      "All frames found:",
      frames.map((f) => f.name()),
    );
    expect(frames).toHaveLength(3);

    const mainFrame = page.mainFrame();
    console.log("Main frame name:", mainFrame.name());
    expect(mainFrame.name()).toBe("");

    const frameOne = page.frame({ name: "frame-one" });
    expect(frameOne).not.toBeNull();

    const frameOneText = await frameOne?.locator("h1").textContent();
    expect(frameOneText).toBe("Hello from Frame 1");

    const frameTwoLocator = page.frameLocator("iframe[name='frame-two']");
    const frameTwoText = await frameTwoLocator.locator("h1").textContent();
    expect(frameTwoText).toBe("Hello from Frame 2");

    const frameTwo = page.frame({ name: "frame-two" });
    expect(frameTwo).not.toBeNull();

    const frameTwoTextAgain = await frameTwo?.locator("h1").textContent();
    expect(frameTwoTextAgain).toBe("Hello from Frame 2");
  });
});

================
File: evals/deterministic/tests/page/getBy.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - Built-in locators", () => {
  let stagehand: Stagehand;

  test.beforeAll(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterAll(async () => {
    await stagehand.close();
  });

  test("demonstrates getByAltText, getByLabel, getByPlaceholder, getByRole, getByTestId, getByText, getByTitle", async () => {
    const { page } = stagehand;
    await page.setContent(`
      <html>
        <body>
          <img src="avatar.png" alt="Profile picture" />
          <label for="username">Username</label>
          <input id="username" type="text" />
          <input placeholder="Enter your email" type="email" />
          <button>Sign in</button>
          <div data-testid="greeting">Hello World!</div>
          <p>This is some descriptive text on the page.</p>
          <h1 title="A heading for the page">Site Title</h1>
        </body>
      </html>
    `);
    const image = page.getByAltText("Profile picture");
    await expect(image).toBeVisible();
    const usernameInput = page.getByLabel("Username");
    await expect(usernameInput).toBeVisible();
    const emailInput = page.getByPlaceholder("Enter your email");
    await expect(emailInput).toBeVisible();
    const signInButton = page.getByRole("button", { name: "Sign in" });
    await expect(signInButton).toBeVisible();
    const greetingDiv = page.getByTestId("greeting");
    await expect(greetingDiv).toHaveText("Hello World!");
    const descriptiveText = page.getByText(
      "This is some descriptive text on the page.",
    );
    await expect(descriptiveText).toBeVisible();
    const heading = page.getByTitle("A heading for the page");
    await expect(heading).toHaveText("Site Title");
  });
});

================
File: evals/deterministic/tests/page/navigation.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - Navigation", () => {
  test("should navigate back and forward between pages", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;

    await page.goto("https://example.com");
    expect(page.url()).toBe("https://example.com/");

    await page.goto("https://www.browserbase.com/");
    expect(page.url()).toBe("https://www.browserbase.com/");

    await page.goBack();
    expect(page.url()).toBe("https://example.com/");

    await page.goForward();
    expect(page.url()).toBe("https://www.browserbase.com/");

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/page/pageContext.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - page.context()", () => {
  let stagehand: Stagehand;

  test.beforeEach(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterEach(async () => {
    if (stagehand) {
      try {
        await stagehand.close();
      } catch (error) {
        console.error("[afterEach] Error during stagehand.close():", error);
      }
    } else {
      console.log("[afterEach] Stagehand was not defined, skipping close().");
    }
  });

  test("should confirm page.context() and stagehand.context share state", async () => {
    const page = stagehand.page;
    const stagehandContext = stagehand.context;
    const pageContext = page.context();

    await pageContext.addCookies([
      {
        name: "stagehandTestCookie",
        value: "hello-stagehand",
        domain: "example.com",
        path: "/",
        expires: Math.floor(Date.now() / 1000) + 3600, // 1 hour
        httpOnly: false,
        secure: false,
        sameSite: "Lax",
      },
    ]);

    const cookies = await stagehandContext.cookies("https://example.com");

    const testCookie = cookies.find((c) => c.name === "stagehandTestCookie");
    expect(testCookie).toBeDefined();
    expect(testCookie?.value).toBe("hello-stagehand");

    const extraPage = await pageContext.newPage();
    await extraPage.goto("https://example.com");
    const contextPages = stagehandContext.pages();

    // The newly created page should be recognized by stagehandContext as well.
    const foundExtraPage = contextPages.find(
      (p) => p.url() === "https://example.com/",
    );
    expect(foundExtraPage).toBeDefined();
  });
});

================
File: evals/deterministic/tests/page/reload.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - Reload", () => {
  test("should reload the page and reset page state", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://www.browserbase.com/");

    await page.evaluate(() => {
      const w = window as typeof window & {
        __testReloadMarker?: string;
      };
      w.__testReloadMarker = "Hello Reload!";
    });

    const markerBeforeReload = await page.evaluate(() => {
      const w = window as typeof window & {
        __testReloadMarker?: string;
      };
      return w.__testReloadMarker;
    });
    expect(markerBeforeReload).toBe("Hello Reload!");

    await page.reload();

    const markerAfterReload = await page.evaluate(() => {
      const w = window as typeof window & {
        __testReloadMarker?: string;
      };
      return w.__testReloadMarker;
    });
    expect(markerAfterReload).toBeUndefined();

    await stagehand.close();
  });
});

================
File: evals/deterministic/tests/page/uploads.test.ts
================
import { join } from "node:path";
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("Playwright Upload", () => {
  let stagehand: Stagehand;

  test.beforeAll(async () => {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
  });

  test.afterAll(async () => {
    await stagehand.close();
  });

  test("uploads a file", async () => {
    const page = stagehand.page;
    await page.goto("https://browser-tests-alpha.vercel.app/api/upload-test");

    const fileInput = page.locator("#fileUpload");
    await fileInput.setInputFiles(
      join(__dirname, "../..", "auxiliary", "logo.png"),
    );

    const fileNameSpan = page.locator("#fileName");
    const fileName = await fileNameSpan.innerText();

    const fileSizeSpan = page.locator("#fileSize");
    const fileSize = Number(await fileSizeSpan.innerText());

    expect(fileName).toBe("logo.png");
    expect(fileSize).toBeGreaterThan(0);
  });
});

================
File: evals/deterministic/tests/page/waitFor.test.ts
================
import { test, expect } from "@playwright/test";
import { Stagehand } from "../../../../lib";
import StagehandConfig from "../../stagehand.config";

test.describe("StagehandPage - waitFor", () => {
  test("should wait for an element to become visible", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com/introduction");
    const dynamicElement = page.locator(
      "div.grid:nth-child(1) > a:nth-child(1) > div:nth-child(1)",
    );

    const isVisibleBefore = await dynamicElement.isVisible();
    expect(isVisibleBefore).toBe(false);

    const clickableElement = page.locator(
      "div.mt-12:nth-child(3) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(1)",
    );
    await clickableElement.click();

    await dynamicElement.waitFor({ state: "visible" });

    const isVisibleAfter = await dynamicElement.isVisible();
    expect(isVisibleAfter).toBe(true);

    await stagehand.close();
  });

  test("should wait for an element to be detached", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com/introduction");

    const disappearingElement = page.locator(
      "div.not-prose:nth-child(2) > a:nth-child(1) > div:nth-child(1)",
    );

    await disappearingElement.click();
    await disappearingElement.waitFor({ state: "detached" });

    const isAttachedAfter = await disappearingElement.isVisible();
    expect(isAttachedAfter).toBe(false);

    await stagehand.close();
  });

  test("should wait for a specific event (waitForEvent)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com/introduction");

    const consolePromise = page.waitForEvent("console");
    await page.evaluate(() => {
      console.log("Hello from the browser console!");
    });
    const consoleMessage = await consolePromise;
    expect(consoleMessage.text()).toBe("Hello from the browser console!");

    await stagehand.close();
  });

  test("should wait for a function to return true (waitForFunction)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com/introduction");

    await page.evaluate(() => {
      setTimeout(() => {
        const w = window as typeof window & {
          __stagehandFlag?: boolean;
        };
        w.__stagehandFlag = true;
      }, 1000);
    });

    await page.waitForFunction(() => {
      const w = window as typeof window & {
        __stagehandFlag?: boolean;
      };
      return w.__stagehandFlag === true;
    });

    const value = await page.evaluate(() => {
      const w = window as typeof window & {
        __stagehandFlag?: boolean;
      };
      return w.__stagehandFlag;
    });
    expect(value).toBe(true);

    await stagehand.close();
  });

  test("should wait for the load state (waitForLoadState)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com/introduction");
    await page.waitForLoadState("networkidle");
    const heroTitle = page.locator("h1");
    await expect(heroTitle).toHaveText(/Documentation/i);

    await stagehand.close();
  });

  test("should wait for a specific request (waitForRequest)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    const requestPromise = page.waitForRequest((req) =>
      req.url().includes("mintlify"),
    );

    await page.goto("https://docs.browserbase.com/introduction");
    const matchingRequest = await requestPromise;
    expect(matchingRequest.url()).toContain("mintlify");

    await stagehand.close();
  });

  test("should wait for a specific response (waitForResponse)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    const responsePromise = page.waitForResponse(
      (res) => res.url().includes("introduction") && res.status() === 200,
    );

    await page.goto("https://docs.browserbase.com/introduction");
    const matchingResponse = await responsePromise;
    expect(await matchingResponse.text()).toContain("Browserbase");

    await stagehand.close();
  });

  test("should wait for a URL (waitForURL)", async () => {
    const stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();

    const page = stagehand.page;
    await page.goto("https://docs.browserbase.com");

    const quickstartLink = page.locator(
      "div.mt-12:nth-child(3) > ul:nth-child(2) > li:nth-child(2) > div:nth-child(1) > div:nth-child(1)",
    );
    await quickstartLink.click();

    await page.waitForURL(/.*quickstart.*/);
    expect(page.url()).toContain("/quickstart");

    await stagehand.close();
  });
});

================
File: evals/deterministic/playwright.config.ts
================
import { defineConfig, devices } from "@playwright/test";

/**
 * See https://playwright.dev/docs/test-configuration.
 */
export default defineConfig({
  testDir: "./tests",

  /* Fail the build on CI if you accidentally left test.only in the source code. */
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  //   reporter: "html",
  reporter: "line",
  /* Retry on CI only */
  retries: 2,

  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: "on-first-retry",
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
});

================
File: evals/deterministic/stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "../../lib";

const StagehandConfig: ConstructorParams = {
  env: "LOCAL" /* Environment to run Stagehand in */,
  apiKey: process.env.BROWSERBASE_API_KEY! /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID! /* Project identifier */,
  verbose: 1 /* Logging verbosity level (0=quiet, 1=normal, 2=verbose) */,
  debugDom: true /* Enable DOM debugging features */,
  headless: true /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(
      `[stagehand::${message.category}] ${message.message}`,
    ) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
  modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};
export default StagehandConfig;

================
File: evals/tasks/allrecipes.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";
import { z } from "zod";

export const allrecipes: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.allrecipes.com/", {
    waitUntil: "domcontentloaded",
  });

  await stagehand.page.act({
    action: 'Search for "chocolate chip cookies" using the search bar',
  });

  const recipeDetails = await stagehand.page.extract({
    instruction:
      "Extract the title of the first recipe and the total number of ratings it has received.",
    schema: z.object({
      title: z.string().describe("Title of the recipe"),
      total_ratings: z
        .string()
        .describe("Total number of ratings for the recipe"),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { title, total_ratings } = recipeDetails;
  const expectedTitle = "Best Chocolate Chip Cookies";
  const expectedRatings = 19164;

  const extractedRatings = parseInt(total_ratings.replace(/[^\d]/g, ""), 10);
  const isRatingsWithinRange =
    extractedRatings >= expectedRatings - 1000 &&
    extractedRatings <= expectedRatings + 1000;

  if (title !== expectedTitle || !isRatingsWithinRange) {
    const errors = [];
    if (title !== expectedTitle) {
      errors.push({
        message: "Extracted title does not match the expected title",
        expected: expectedTitle,
        actual: title,
      });
    }
    if (!isRatingsWithinRange) {
      errors.push({
        message: "Extracted ratings are not within the expected range",
        expected: `${expectedRatings} ± 1000`,
        actual: extractedRatings.toString(),
      });
    }

    logger.error({
      message: "Failed to extract correct recipe details",
      level: 0,
      auxiliary: {
        errors: {
          value: JSON.stringify(errors),
          type: "object",
        },
      },
    });

    return {
      _success: false,
      error: "Recipe details extraction validation failed",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    recipeDetails: {
      title,
      total_ratings: extractedRatings,
    },
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/amazon_add_to_cart.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const amazon_add_to_cart: EvalFunction = async ({
  modelName,
  logger,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.amazon.com/Laptop-MacBook-Surface-Water-Resistant-Accessories/dp/B0D5M4H5CD",
  );

  await stagehand.page.waitForTimeout(5000);

  await stagehand.page.act({
    action: "click the 'Add to Cart' button",
  });

  await stagehand.page.waitForTimeout(2000);

  await stagehand.page.act({
    action: "click the 'Proceed to checkout' button",
  });

  await stagehand.page.waitForTimeout(2000);
  const currentUrl = stagehand.page.url();
  const expectedUrlPrefix = "https://www.amazon.com/ap/signin";

  await stagehand.close();

  return {
    _success: currentUrl.startsWith(expectedUrlPrefix),
    currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/apple.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const apple: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.apple.com/iphone-16-pro/");

  await stagehand.page.act({ action: "click on the buy button" });
  await stagehand.page.act({ action: "select the Pro Max model" });
  await stagehand.page.act({ action: "select the natural titanium color" });
  await stagehand.page.act({ action: "select the 256GB storage option" });
  await stagehand.page.act({
    action: "click on the 'select a smartphone' trade-in option",
  });

  await stagehand.page.act({
    action: "select the iPhone 13 mini model from the dropdown",
  });
  await stagehand.page.act({
    action: "select the iPhone 13 mini is in good condition",
  });

  const successMessageLocator = stagehand.page.locator(
    'text="Good News. Your iPhone 13 mini qualifies for credit."',
  );
  const isVisible = await successMessageLocator.isVisible();

  await stagehand.close();

  return {
    _success: isVisible,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/arxiv.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const arxiv: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://arxiv.org/search/");

    await stagehand.page.act({
      action: "search for papers about web agents with multimodal models",
    });

    const paper_links = await stagehand.page.extract({
      instruction: "extract the titles and links for two papers",
      schema: z.object({
        papers: z
          .array(
            z.object({
              title: z.string().describe("the title of the paper"),
              link: z.string().describe("the link to the paper").nullable(),
            }),
          )
          .describe("list of papers"),
      }),
      modelName,
      useTextExtract,
    });

    if (
      !paper_links ||
      !paper_links.papers ||
      paper_links.papers.length === 0
    ) {
      await stagehand.close();

      return {
        _success: false,
        logs: logger.getLogs(),
        debugUrl,
        sessionUrl,
      };
    }

    const papers = [];
    for (const paper of paper_links.papers) {
      if (paper.link) {
        await stagehand.page.goto(paper.link);
        const abstract = await stagehand.page.extract({
          instruction: "extract details of the paper from the abstract",
          schema: z.object({
            category: z
              .string()
              .describe(
                "the category of the paper. one of {'Benchmark', 'Dataset', 'Model', 'Framework', 'System', 'Other'}",
              ),
            problem: z
              .string()
              .describe(
                "summarize the problem that the paper is trying to solve in one sentence",
              )
              .nullable(),
            methodology: z
              .string()
              .describe(
                "summarize the methodology of the paper in one sentence",
              )
              .nullable(),
            results: z
              .string()
              .describe("summarize the results of the paper in one sentence")
              .nullable(),
            conclusion: z
              .string()
              .describe("summarize the conclusion of the paper in one sentence")
              .nullable(),
            code: z
              .string()
              .describe(
                "if provided, extract only the link to the code repository, without additional text. this is often optional and not always provided.",
              )
              .nullable(),
          }),
          modelName,
          useTextExtract,
        });

        papers.push({
          title: paper.title,
          link: paper.link,
          ...abstract,
        });
      }
    }

    if (!papers || papers.length === 0) {
      await stagehand.close();

      return {
        _success: false,
        logs: logger.getLogs(),
        debugUrl,
        sessionUrl,
      };
    }

    if (papers.length !== 2) {
      logger.error({
        message: "incorrect number of papers extracted",
        level: 0,
        auxiliary: {
          expected: {
            value: "2",
            type: "integer",
          },
          actual: {
            value: papers.length.toString(),
            type: "integer",
          },
        },
      });

      await stagehand.close();

      return {
        _success: false,
        error: "Incorrect number of papers extracted",
        logs: logger.getLogs(),
        debugUrl,
        sessionUrl,
      };
    }

    // Ensure that every paper has a problem and methodology
    for (const paper of papers) {
      if (!paper.problem || !paper.methodology) {
        logger.error({
          message: `paper missing problem or methodology`,
          level: 0,
          auxiliary: {
            paper: {
              value: JSON.stringify(paper),
              type: "object",
            },
          },
        });

        await stagehand.close();

        return {
          _success: false,
          error: "Incomplete paper information",
          logs: logger.getLogs(),
          debugUrl,
          sessionUrl,
        };
      }
    }

    await stagehand.close();

    return {
      _success: true,
      papers,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } catch (error) {
    logger.error({
      message: `error in arxiv function`,
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
};

================
File: evals/tasks/bidnet.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const bidnet: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.bidnetdirect.com/");

  await stagehand.page.act({
    action: 'Click on the "Construction" keyword',
  });

  const expectedUrl =
    "https://www.bidnetdirect.com/public/solicitations/open?keywords=Construction";
  const currentUrl = stagehand.page.url();

  await stagehand.close();

  return {
    _success: currentUrl.startsWith(expectedUrl),
    currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/combination_sauce.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const combination_sauce: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.saucedemo.com/");

    const { usernames, password } = await stagehand.page.extract({
      instruction: "extract the accepted usernames and the password for login",
      schema: z.object({
        usernames: z.array(z.string()).describe("the accepted usernames"),
        password: z.string().describe("the password for login"),
      }),
      modelName,
      useTextExtract,
    });

    await stagehand.page.act({
      action: `enter username 'standard_user'`,
    });

    await stagehand.page.act({
      action: `enter password '${password}'`,
    });

    await stagehand.page.act({
      action: "click on 'login'",
    });

    const observations = await stagehand.page.observe({
      instruction: "find all the 'add to cart' buttons",
    });

    console.log("observations", observations);
    console.log("observations length", observations.length);

    const url = await stagehand.page.url();

    await stagehand.close();

    const usernamesCheck = usernames.length === 6;
    const urlCheck = url === "https://www.saucedemo.com/inventory.html";
    const observationsCheck = observations.length === 6;

    return {
      _success: usernamesCheck && urlCheck && observationsCheck,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error("Error or timeout occurred:", error);

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/costar.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";
import { z } from "zod";

export const costar: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;
  // TODO: fix this eval - does not work in headless mode
  try {
    await Promise.race([
      stagehand.page.goto("https://www.costar.com/"),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Navigation timeout")), 30000),
      ),
    ]);

    await stagehand.page.act({ action: "click on the first article" });

    await stagehand.page.act({
      action: "click on the learn more button for the first job",
    });

    const articleTitle = await stagehand.page.extract({
      instruction: "extract the title of the article",
      schema: z.object({
        title: z.string().describe("the title of the article").nullable(),
      }),
      modelName,
      useTextExtract,
    });

    logger.log({
      message: "got article title",
      level: 1,
      auxiliary: {
        articleTitle: {
          value: JSON.stringify(articleTitle),
          type: "object",
        },
      },
    });

    // Check if the title is more than 5 characters
    const isTitleValid =
      articleTitle.title !== null && articleTitle.title.length > 5;

    await stagehand.close();

    return {
      title: articleTitle.title,
      _success: isTitleValid,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "error in costar function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      title: null,
      _success: false,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/expedia_search.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const expedia_search: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.expedia.com/flights");

    await stagehand.page.act({
      action:
        "find round-trip flights from San Francisco (SFO) to Toronto (YYZ) for Jan 1, 2025 (up to one to two weeks)",
    });

    await stagehand.page.act({ action: "Go to the first non-stop flight" });

    await stagehand.page.act({ action: "select the cheapest flight" });

    await stagehand.page.act({ action: "click on the first non-stop flight" });

    await stagehand.page.act({
      action: "Take me to the checkout page",
    });

    const url = stagehand.page.url();
    return {
      _success: url.startsWith("https://www.expedia.com/Checkout/"),
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } catch (error) {
    logger.error({
      message: `error in expedia function`,
      level: 0,
      auxiliary: {
        error: {
          value: JSON.stringify(error, null, 2),
          type: "object",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } finally {
    await stagehand.close();
  }
};

================
File: evals/tasks/expedia.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const expedia: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.expedia.com/flights");
    await stagehand.page.act({
      action:
        "find round-trip flights from San Francisco (SFO) to Toronto (YYZ) for Jan 1, 2025 (up to one to two weeks)",
    });
    await stagehand.page.act({ action: "Go to the first non-stop flight" });
    await stagehand.page.act({ action: "select the cheapest flight" });
    await stagehand.page.act({ action: "click on the first non-stop flight" });
    await stagehand.page.act({ action: "Take me to the checkout page" });

    const url = stagehand.page.url();
    return {
      _success: url.startsWith("https://www.expedia.com/Checkout/"),
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } catch (error) {
    logger.error({
      message: "Error in expedia eval",
      level: 0,
      auxiliary: {
        error: { value: error.message, type: "string" },
        trace: { value: error.stack, type: "string" },
      },
    });

    return {
      _success: false,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } finally {
    await stagehand.close();
  }
};

================
File: evals/tasks/extract_aigrant_companies.ts
================
import { z } from "zod";
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const extract_aigrant_companies: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 3000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://aigrant.com/");
  const companyList = await stagehand.page.extract({
    instruction:
      "Extract all companies that received the AI grant and group them with their batch numbers as an array of objects. Each object should contain the company name and its corresponding batch number.",
    schema: z.object({
      companies: z.array(
        z.object({
          company: z.string(),
          batch: z.string(),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();
  const companies = companyList.companies;
  const expectedLength = 91;

  const expectedFirstItem = {
    company: "Goodfire",
    batch: "4",
  };

  const expectedLastItem = {
    company: "Forefront",
    batch: "1",
  };

  if (companies.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of companies extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: companies.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of companies extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    companies[0].company === expectedFirstItem.company &&
    companies[0].batch === expectedFirstItem.batch;

  if (!firstItemMatches) {
    logger.error({
      message: "First company extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(companies[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First company extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    companies[companies.length - 1].company === expectedLastItem.company &&
    companies[companies.length - 1].batch === expectedLastItem.batch;

  if (!lastItemMatches) {
    logger.error({
      message: "Last company extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(companies[companies.length - 1]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last company extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_area_codes.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_area_codes: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.init();
  await stagehand.page.goto(
    "https://www.ncc.gov.ng/technical-regulation/standards/numbering#area-codes-by-zone-primary-centre",
    { waitUntil: "domcontentloaded" },
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract ALL the Primary Center names and their corresponding Area Code, and the name of their corresponding Zone.",
    schema: z.object({
      primary_center_list: z.array(
        z.object({
          zone_name: z
            .string()
            .describe(
              "The name of the Zone that the Primary Center is in. For example, 'North Central Zone'.",
            ),
          primary_center_name: z
            .string()
            .describe(
              "The name of the Primary Center. I.e., this is the name of the city or town.",
            ),
          area_code: z
            .string()
            .describe(
              "The area code for the Primary Center. This will either be 2 or 3 digits.",
            ),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const primaryCenterList = result.primary_center_list;
  const expectedLength = 56;

  const expectedFirstItem = {
    zone_name: "Lagos Zone",
    primary_center_name: "Lagos",
    area_code: "01",
  };

  const expectedLastItem = {
    zone_name: "South-East Zone",
    primary_center_name: "Yenagoa",
    area_code: "089",
  };

  if (primaryCenterList.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of primary centers extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: primaryCenterList.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of primary centers extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    primaryCenterList[0].zone_name === expectedFirstItem.zone_name &&
    primaryCenterList[0].primary_center_name ===
      expectedFirstItem.primary_center_name &&
    primaryCenterList[0].area_code === expectedFirstItem.area_code;

  if (!firstItemMatches) {
    logger.error({
      message: "First primary center extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(primaryCenterList[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First primary center extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    primaryCenterList[primaryCenterList.length - 1].zone_name ===
      expectedLastItem.zone_name &&
    primaryCenterList[primaryCenterList.length - 1].primary_center_name ===
      expectedLastItem.primary_center_name &&
    primaryCenterList[primaryCenterList.length - 1].area_code ===
      expectedLastItem.area_code;

  if (!lastItemMatches) {
    logger.error({
      message: "Last primary center extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(
            primaryCenterList[primaryCenterList.length - 1],
          ),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last primary center extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_baptist_health.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";
import { compareStrings } from "../utils";

export const extract_baptist_health: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.baptistfirst.org/location/baptist-health-ent-partners",
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract the address, phone number, and fax number of the healthcare location.",
    schema: z.object({
      address: z.string(),
      phone: z.string(),
      fax: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { address, phone, fax } = result;
  const expected = {
    address: "2055 East South Blvd; Suite 908 Montgomery, AL 36116",
    phone: "334-747-2273",
    fax: "334-747-7501",
  };

  const similarityThreshold = 0.85;
  const failedFields: Array<{
    field: string;
    similarity: number;
    expected: string;
    actual: string;
  }> = [];

  const compareField = (
    actualVal: string,
    expectedVal: string,
    fieldName: string,
  ) => {
    const { similarity, meetsThreshold } = compareStrings(
      actualVal,
      expectedVal,
      similarityThreshold,
    );

    if (!meetsThreshold) {
      failedFields.push({
        field: fieldName,
        similarity,
        expected: expectedVal,
        actual: actualVal,
      });
      logger.error({
        message: `${fieldName} extracted does not meet similarity threshold`,
        level: 0,
        auxiliary: {
          field: { value: fieldName, type: "string" },
          similarity: { value: similarity.toFixed(2), type: "string" },
          expected: { value: expectedVal, type: "string" },
          actual: { value: actualVal, type: "string" },
        },
      });
    }

    return meetsThreshold;
  };

  const addressOk = compareField(address, expected.address, "Address");
  const phoneOk = compareField(phone, expected.phone, "Phone number");
  const faxOk = compareField(fax, expected.fax, "Fax number");

  if (!addressOk || !phoneOk || !faxOk) {
    return {
      _success: false,
      error: "Some fields did not meet similarity threshold",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
      failedFields,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_capacitor_info.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { normalizeString } from "../utils";
import { z } from "zod";

export const extract_capacitor_info: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.jakelectronics.com/productdetail/panasonicelectroniccomponents-eeufm1a472l-2937406",
  );

  const result = await stagehand.page.extract({
    instruction: "Extract the ECCN Code, RoHS Status, and Impedance.",
    schema: z.object({
      ECCN_code: z.string(),
      RoHS_Status: z.string(),
      Impedance: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { ECCN_code, RoHS_Status, Impedance } = result;

  const expected = {
    ECCN_code: "EAR99",
    RoHS_Status: "RoHS Compliant",
    Impedance: "12mOhm",
  };

  if (normalizeString(ECCN_code) !== normalizeString(expected.ECCN_code)) {
    logger.error({
      message: "ECCN code extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.ECCN_code),
          type: "string",
        },
        actual: {
          value: normalizeString(ECCN_code),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "ECCN code extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(RoHS_Status) !== normalizeString(expected.RoHS_Status)) {
    logger.error({
      message: "RoHS Status extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.RoHS_Status),
          type: "string",
        },
        actual: {
          value: normalizeString(RoHS_Status),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "RoHS Status extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(Impedance) !== normalizeString(expected.Impedance)) {
    logger.error({
      message: "Impedance extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.Impedance),
          type: "string",
        },
        actual: {
          value: normalizeString(Impedance),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Impedance extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_collaborators.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_collaborators: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://github.com/facebook/react");
    await stagehand.page.act({
      action: "find the contributors section",
    });

    const { contributors } = await stagehand.page.extract({
      instruction: "Extract top 20 contributors of this repository",
      schema: z.object({
        contributors: z.array(
          z.object({
            github_username: z
              .string()
              .describe("the github username of the contributor"),
            information: z.string().describe("number of commits contributed"),
          }),
        ),
      }),
      modelName,
      useTextExtract,
    });

    await stagehand.close();

    return {
      _success: contributors.length === 20,
      contributors,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error("Error or timeout occurred:", error);

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/extract_github_commits.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";
import { z } from "zod";

export const extract_github_commits: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://github.com/facebook/react");

    await stagehand.page.act({
      action:
        "find commit history, generally described by the number of commits",
    });
    const { commits } = await stagehand.page.extract({
      instruction: "Extract last 20 commits",
      schema: z.object({
        commits: z.array(
          z.object({
            commit_message: z.string(),
            commit_url: z.string(),
            commit_hash: z.string(),
          }),
        ),
      }),
      modelName,
      useTextExtract,
    });

    logger.log({
      message: "Extracted commits",
      level: 1,
      auxiliary: {
        commits: {
          value: JSON.stringify(commits),
          type: "object",
        },
      },
    });

    await stagehand.close();

    return {
      _success: commits.length === 20,
      commits,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error("Error or timeout occurred:", error);

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/extract_github_stars.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_github_stars: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://github.com/facebook/react");

    const { stars } = await stagehand.page.extract({
      instruction: "Extract the number of stars for the project",
      schema: z.object({
        stars: z.number().describe("the number of stars for the project"),
      }),
      modelName,
      useTextExtract,
    });

    const expectedStarsString = await stagehand.page
      .locator("#repo-stars-counter-star")
      .first()
      .innerHTML();

    const expectedStars = expectedStarsString.toLowerCase().endsWith("k")
      ? parseFloat(expectedStarsString.slice(0, -1)) * 1000
      : parseFloat(expectedStarsString);

    const tolerance = 1000;
    const isWithinTolerance = Math.abs(stars - expectedStars) <= tolerance;

    await stagehand.close();

    return {
      _success: isWithinTolerance,
      stars,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error("Error or timeout occurred:", error);

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/extract_memorial_healthcare.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";
import { compareStrings } from "../utils";

export const extract_memorial_healthcare: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 3000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.mycmh.org/locations/");

  const result = await stagehand.page.extract({
    instruction:
      "extract a list of the first three healthcare centers on this page, with their name, full address, and phone number",
    schema: z.object({
      health_centers: z.array(
        z.object({
          name: z.string(),
          phone_number: z.string(),
          address: z.string(),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const health_centers: Array<
    Partial<{ name: string; phone_number: string; address: string }>
  > = result.health_centers;

  const expectedLength = 3;
  const similarityThreshold = 0.85;

  const expectedFirstItem = {
    name: "Community Memorial Breast Center",
    phone_number: "805-948-5093",
    address: "168 North Brent Street, Suite 401, Ventura, CA 93003",
  };

  const expectedLastItem = {
    name: "Community Memorial Dermatology and Mohs Surgery",
    phone_number: "805-948-6920",
    address: "168 North Brent Street, Suite 403, Ventura, CA 93003",
  };

  if (health_centers.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of health centers extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: health_centers.length.toString(),
          type: "integer",
        },
      },
    });

    return {
      _success: false,
      error: "Incorrect number of health centers extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const validateHealthCenter = (
    center: Partial<{ name: string; phone_number: string; address: string }>,
  ): { name: string; phone_number: string; address: string } | null => {
    if (center.name && center.phone_number && center.address) {
      return center as { name: string; phone_number: string; address: string };
    }
    logger.error({
      message: "Invalid health center data",
      level: 0,
      auxiliary: {
        center: { value: JSON.stringify(center), type: "object" },
      },
    });
    return null;
  };

  const validHealthCenters = health_centers
    .map(validateHealthCenter)
    .filter(Boolean) as Array<{
    name: string;
    phone_number: string;
    address: string;
  }>;

  if (validHealthCenters.length < expectedLength) {
    return {
      _success: false,
      error: "One or more health centers have missing fields",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const compareField = (
    actual: string,
    expected: string,
    fieldName: string,
  ): boolean => {
    const { similarity, meetsThreshold } = compareStrings(
      actual,
      expected,
      similarityThreshold,
    );

    if (!meetsThreshold) {
      logger.error({
        message: `Field "${fieldName}" does not meet similarity threshold`,
        level: 0,
        auxiliary: {
          field: { value: fieldName, type: "string" },
          similarity: { value: similarity.toFixed(2), type: "float" },
          expected: { value: expected, type: "string" },
          actual: { value: actual, type: "string" },
        },
      });
    }

    return meetsThreshold;
  };

  const compareItem = (
    actual: { name: string; phone_number: string; address: string },
    expected: { name: string; phone_number: string; address: string },
    position: string,
  ): boolean => {
    const fields = [
      { field: "name", actual: actual.name, expected: expected.name },
      {
        field: "phone_number",
        actual: actual.phone_number,
        expected: expected.phone_number,
      },
      { field: "address", actual: actual.address, expected: expected.address },
    ];

    return fields.every(({ field, actual, expected }) =>
      compareField(actual, expected, `${position} ${field}`),
    );
  };

  const firstItemMatches = compareItem(
    validHealthCenters[0],
    expectedFirstItem,
    "First",
  );
  const lastItemMatches = compareItem(
    validHealthCenters[validHealthCenters.length - 1],
    expectedLastItem,
    "Last",
  );

  if (!firstItemMatches || !lastItemMatches) {
    return {
      _success: false,
      error: "One or more fields do not match expected values",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_nhl_stats.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { normalizeString } from "../utils";
import { z } from "zod";

export const extract_nhl_stats: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 4000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.hockeydb.com/ihdb/stats/top_league.php?lid=nhl1927&sid=1990",
    {
      waitUntil: "domcontentloaded",
    },
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract the name of the goal scoring leader, their number of goals they scored, and the team they played for.",
    schema: z.object({
      name: z.string(),
      num_goals: z.string(),
      team: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { name, num_goals, team } = result;

  const expected = {
    name: "Brett Hull",
    num_goals: "72",
    team: "St. Louis",
  };

  if (normalizeString(name) !== normalizeString(expected.name)) {
    logger.error({
      message: "Player name extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.name),
          type: "string",
        },
        actual: {
          value: normalizeString(name),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Player name extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(num_goals) !== normalizeString(expected.num_goals)) {
    logger.error({
      message: "Number of goals extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.num_goals),
          type: "string",
        },
        actual: {
          value: normalizeString(num_goals),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Number of goals extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(team) !== normalizeString(expected.team)) {
    logger.error({
      message: "Player team extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.team),
          type: "string",
        },
        actual: {
          value: normalizeString(team),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Player team extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_partners.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_partners: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://ramp.com");

    await stagehand.page.act({
      action: "move down to the bottom of the page.",
    });

    await stagehand.page.act({
      action: "Close the popup.",
    });

    await stagehand.page.act({
      action: "Find and click on the link that leads to the partners page.",
    });

    const partners = await stagehand.page.extract({
      instruction: `
      Extract all of the partner categories on the page.
    `,
      schema: z.object({
        partners: z.array(
          z.object({
            partner_category: z.string().describe("The partner category"),
          }),
        ),
        explanation: z
          .string()
          .optional()
          .describe("Any explanation about partner listing or absence thereof"),
      }),
      modelName,
      useTextExtract,
    });

    const expectedPartners = [
      "Accounting Partners",
      "Private Equity & Venture Capital Partners",
      "Services Partners",
      "Affiliates",
    ];

    const foundPartners = partners.partners.map((partner) =>
      partner.partner_category.toLowerCase(),
    );

    const allExpectedPartnersFound = expectedPartners.every((partner) =>
      foundPartners.includes(partner.toLowerCase()),
    );

    await stagehand.close();

    return {
      _success: allExpectedPartnersFound,
      partners,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "error in extractPartners function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      debugUrl,
      sessionUrl,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/extract_press_releases.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";
import { compareStrings } from "../utils";

export const extract_press_releases: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 3000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  const schema = z.object({
    items: z.array(
      z.object({
        title: z.string().describe("The title of the press release"),
        publish_date: z
          .string()
          .describe("The date the press release was published"),
      }),
    ),
  });

  type PressRelease = z.infer<typeof schema>["items"][number];

  try {
    await stagehand.page.goto("https://www.landerfornyc.com/news", {
      waitUntil: "networkidle",
    });
    await new Promise((resolve) => setTimeout(resolve, 5000));

    const rawResult = await stagehand.page.extract({
      instruction:
        "extract the title and corresponding publish date of EACH AND EVERY press releases on this page. DO NOT MISS ANY PRESS RELEASES.",
      schema,
      modelName,
      useTextExtract,
    });

    const parsed = schema.parse(rawResult);
    const { items } = parsed;

    await stagehand.close();

    const expectedLength = 28;
    const expectedFirstItem: PressRelease = {
      title: "UAW Region 9A Endorses Brad Lander for Mayor",
      publish_date: "Dec 4, 2024",
    };
    const expectedLastItem: PressRelease = {
      title: "An Unassuming Liberal Makes a Rapid Ascent to Power Broker",
      publish_date: "Jan 23, 2014",
    };

    if (items.length <= expectedLength) {
      logger.error({
        message: "Not enough items extracted",
        level: 0,
        auxiliary: {
          expected: {
            value: `> ${expectedLength}`,
            type: "string",
          },
          actual: {
            value: items.length.toString(),
            type: "integer",
          },
        },
      });
      return {
        _success: false,
        error: "Not enough items extracted",
        logs: logger.getLogs(),
        debugUrl,
        sessionUrl,
      };
    }

    const isItemMatch = (item: PressRelease, expected: PressRelease) => {
      const titleComparison = compareStrings(item.title, expected.title, 0.9);
      const dateComparison = compareStrings(
        item.publish_date,
        expected.publish_date,
        0.9,
      );
      return titleComparison.meetsThreshold && dateComparison.meetsThreshold;
    };

    const foundFirstItem = items.some((item) =>
      isItemMatch(item, expectedFirstItem),
    );
    const foundLastItem = items.some((item) =>
      isItemMatch(item, expectedLastItem),
    );

    return {
      _success: foundFirstItem && foundLastItem,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } catch (error) {
    logger.error({
      message: `Error in extract_press_releases function`,
      level: 0,
      auxiliary: {
        error: {
          value: (error as Error).message || JSON.stringify(error),
          type: "string",
        },
        trace: {
          value: (error as Error).stack,
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "An error occurred during extraction",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } finally {
    await stagehand.context.close();
  }
};

================
File: evals/tasks/extract_professional_info.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { normalizeString } from "../utils";
import { z } from "zod";

export const extract_professional_info: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.paulweiss.com/professionals/partners-and-counsel/brian-bolin",
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract the list of Practices, phone number, and fax number of the professional.",
    schema: z.object({
      practices: z.array(z.string()),
      phone: z.string(),
      fax: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { practices, phone, fax } = result;

  const expected = {
    practices: [
      "Restructuring",
      "Finance",
      "Hybrid Capital & Special Situations",
    ],
    phone: "+1-212-373-3262",
    fax: "+1-212-492-0262",
  };

  if (
    JSON.stringify(practices.map(normalizeString)) !==
    JSON.stringify(expected.practices.map(normalizeString))
  ) {
    logger.error({
      message: "Practices extracted do not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expected.practices),
          type: "object",
        },
        actual: {
          value: JSON.stringify(practices),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Practices extracted do not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(phone) !== normalizeString(expected.phone)) {
    logger.error({
      message: "Phone number extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.phone),
          type: "string",
        },
        actual: {
          value: normalizeString(phone),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Phone number extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(fax) !== normalizeString(expected.fax)) {
    logger.error({
      message: "Fax number extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.fax),
          type: "string",
        },
        actual: {
          value: normalizeString(fax),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Fax number extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_public_notices.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";
import { compareStrings } from "../utils";

export const extract_public_notices: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.init();
  await stagehand.page.goto(
    "https://www.sars.gov.za/legal-counsel/secondary-legislation/public-notices/",
    { waitUntil: "load" },
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract ALL the public notice descriptions with their corresponding, GG number and publication date. Extract ALL notices from 2024 through 2020. Do not include the Notice number.",
    schema: z.object({
      public_notices: z.array(
        z.object({
          notice_description: z
            .string()
            .describe(
              "the description of the notice. Do not include the Notice number",
            ),
          gg_number: z
            .string()
            .describe("the GG number of the notice. For example, GG 12345"),
          publication_date: z
            .string()
            .describe(
              "the publication date of the notice. For example, 8 December 2021",
            ),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const publicNotices = result.public_notices;
  const expectedLength = 24;

  const expectedFirstItem = {
    notice_description:
      "Additional considerations in terms of section 80(2) in respect of which an application for a binding private ruling or a binding class ruling may be rejected",
    gg_number: "GG 51526",
    publication_date: "8 November 2024",
  };

  const expectedLastItem = {
    notice_description:
      "Notice in terms of section 25, read with section 66(1) of the Income Tax Act, 1962, for submission of 2020 income tax returns",
    gg_number: "GG 43495",
    publication_date: "3 July 2020",
  };

  if (publicNotices.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of public notices extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: publicNotices.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of public notices extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    compareStrings(
      publicNotices[0].notice_description,
      expectedFirstItem.notice_description,
      0.9,
    ) &&
    compareStrings(
      publicNotices[0].gg_number,
      expectedFirstItem.gg_number,
      0.9,
    ) &&
    compareStrings(
      publicNotices[0].publication_date,
      expectedFirstItem.publication_date,
      0.9,
    );

  if (!firstItemMatches) {
    logger.error({
      message: "First public notice extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(publicNotices[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First public notice extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    compareStrings(
      publicNotices[publicNotices.length - 1].notice_description,
      expectedLastItem.notice_description,
      0.9,
    ) &&
    compareStrings(
      publicNotices[publicNotices.length - 1].gg_number,
      expectedLastItem.gg_number,
      0.9,
    ) &&
    compareStrings(
      publicNotices[publicNotices.length - 1].publication_date,
      expectedLastItem.publication_date,
      0.9,
    );

  if (!lastItemMatches) {
    logger.error({
      message: "Last public notice extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(publicNotices[publicNotices.length - 1]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last public notice extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_regulations.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_regulations: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.jsc.gov.jo/Links2/en/Regulations");

  const result = await stagehand.page.extract({
    instruction:
      "Extract the list of regulations with their descriptions and issue dates",
    schema: z.object({
      regulations: z.array(
        z.object({
          description: z.string(),
          issue_date: z.string(),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const regulations = result.regulations;
  const expectedLength = 4;

  const expectedFirstItem = {
    description:
      "The Regulation of Investors Protection Fund in Securities No. (47) for the Year 2018 Amended Pursuant to Regulation No. (24) for the Year 2019",
    issue_date: "2019",
  };

  const expectedLastItem = {
    description: "Islamic Finance sukuk conrract regulation",
    issue_date: "2014",
  };

  if (regulations.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of regulations extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: regulations.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of regulations extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    regulations[0].description === expectedFirstItem.description &&
    regulations[0].issue_date === expectedFirstItem.issue_date;

  if (!firstItemMatches) {
    logger.error({
      message: "First regulation extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(regulations[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First regulation extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    regulations[regulations.length - 1].description ===
      expectedLastItem.description &&
    regulations[regulations.length - 1].issue_date ===
      expectedLastItem.issue_date;

  if (!lastItemMatches) {
    logger.error({
      message: "Last regulation extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(regulations[regulations.length - 1]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last regulation extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_research_reports.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_research_reports: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.init();
  await stagehand.page.goto(
    "http://www.dsbd.gov.za/index.php/research-reports",
    { waitUntil: "load" },
  );

  const result = await stagehand.page.extract({
    instruction:
      "Extract ALL the research report names. Do not extract the names of the PDF attachments.",
    schema: z.object({
      reports: z.array(
        z.object({
          report_name: z
            .string()
            .describe(
              "The name or title of the research report. NOT the name of the PDF attachment.",
            ),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const reports = result.reports;
  const expectedLength = 9;

  const expectedFirstItem = {
    report_name:
      "Longitudinal Study on SMMEs and Co-operatives in South Africa and the study on the Eastern SeaBoard",
  };

  const expectedLastItem = {
    report_name: "Research Agenda",
  };

  if (reports.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of reports extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: reports.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of reports extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    reports[0].report_name === expectedFirstItem.report_name;

  if (!firstItemMatches) {
    logger.error({
      message: "First report extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(reports[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First report extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    reports[reports.length - 1].report_name === expectedLastItem.report_name;

  if (!lastItemMatches) {
    logger.error({
      message: "Last report extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(reports[reports.length - 1]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last report extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_resistor_info.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { normalizeString } from "../utils";
import { z } from "zod";

export const extract_resistor_info: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.seielect.com/?stockcheck=ASR1JA330R");

  const result = await stagehand.page.extract({
    instruction:
      "Extract the MOQ, tolerance percentage, ohmic value, and operating temperature range of the resistor.",
    schema: z.object({
      moq: z.string(),
      tolerance_percentage: z.string(),
      ohmic_value: z.string(),
      operating_temperature_range: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const {
    moq,
    tolerance_percentage,
    ohmic_value,
    operating_temperature_range,
  } = result;

  const expected = {
    moq: "500",
    tolerance_percentage: "5%",
    ohmic_value: "330 ohm",
    operating_temperature_range: "-55 to +155",
  };

  if (normalizeString(moq) !== normalizeString(expected.moq)) {
    logger.error({
      message: "MOQ extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.moq),
          type: "string",
        },
        actual: {
          value: normalizeString(moq),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "MOQ extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (
    normalizeString(tolerance_percentage) !==
    normalizeString(expected.tolerance_percentage)
  ) {
    logger.error({
      message: "Tolerance percentage extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.tolerance_percentage),
          type: "string",
        },
        actual: {
          value: normalizeString(tolerance_percentage),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Tolerance percentage extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (normalizeString(ohmic_value) !== normalizeString(expected.ohmic_value)) {
    logger.error({
      message: "Ohmic value extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.ohmic_value),
          type: "string",
        },
        actual: {
          value: normalizeString(ohmic_value),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Ohmic value extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  if (
    normalizeString(operating_temperature_range) !==
    normalizeString(expected.operating_temperature_range)
  ) {
    logger.error({
      message: "Operating temperature range extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: normalizeString(expected.operating_temperature_range),
          type: "string",
        },
        actual: {
          value: normalizeString(operating_temperature_range),
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: "Operating temperature range extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_rockauto.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const extract_rockauto: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 10000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.rockauto.com/en/catalog/alpine,1974,a310,1.6l+l4,1436055,cooling+system,coolant+/+antifreeze,11393",
  );
  await new Promise((resolve) => setTimeout(resolve, 5000));
  const result = await stagehand.page.extract({
    instruction:
      "Extract the part number of all the coolant and antifreeze products in the 'economy' category. Do not include the manufacturer name.",
    schema: z.object({
      coolant_products: z.array(
        z.object({
          part_number: z.string(),
        }),
      ),
    }),
    modelName,
    useTextExtract,
    domSettleTimeoutMs: 10000,
  });

  await stagehand.close();

  const coolantProducts = result.coolant_products;
  const expectedLength = 4;

  const expectedFirstItem = {
    part_number: "GREEN5050GAL",
  };

  const expectedLastItem = {
    part_number: "719009",
  };

  if (coolantProducts.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of coolant products extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: coolantProducts.length.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Incorrect number of coolant products extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }
  const firstItemMatches =
    coolantProducts[0].part_number === expectedFirstItem.part_number;

  if (!firstItemMatches) {
    logger.error({
      message: "First coolant product extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(coolantProducts[0]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "First coolant product extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemMatches =
    coolantProducts[coolantProducts.length - 1].part_number ===
    expectedLastItem.part_number;

  if (!lastItemMatches) {
    logger.error({
      message: "Last coolant product extracted does not match expected",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(coolantProducts[coolantProducts.length - 1]),
          type: "object",
        },
      },
    });
    return {
      _success: false,
      error: "Last coolant product extracted does not match expected",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/extract_snowshoeing_destinations.ts
================
import { z } from "zod";
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const extract_snowshoeing_destinations: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto(
      "https://www.cbisland.com/blog/10-snowshoeing-adventures-on-cape-breton-island/",
    );

    await stagehand.page.act({ action: "reject the cookies" });

    const snowshoeing_regions = await stagehand.page.extract({
      instruction:
        "Extract all the snowshoeing regions and the names of the trails within each region.",
      schema: z.object({
        snowshoeing_regions: z.array(
          z.object({
            region_name: z
              .string()
              .describe("The name of the snowshoeing region"),
            trails: z
              .array(
                z.object({
                  trail_name: z.string().describe("The name of the trail"),
                }),
              )
              .describe("The list of trails available in this region."),
          }),
        ),
      }),
      modelName,
      useTextExtract,
    });

    logger.log({
      message: "Extracted destinations and trails",
      level: 1,
      auxiliary: {
        destinations: {
          value: JSON.stringify(snowshoeing_regions),
          type: "object",
        },
      },
    });

    await stagehand.close();

    const _success = snowshoeing_regions.snowshoeing_regions.length === 10;

    return {
      _success,
      snowshoeing_regions,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "Error in extract_snowshoeing_destinations function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } finally {
    await stagehand.context.close().catch(() => {});
  }
};

================
File: evals/tasks/extract_staff_members.ts
================
import { z } from "zod";
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const extract_staff_members: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 3000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://panamcs.org/about/staff/");

  const result = await stagehand.page.extract({
    instruction:
      "extract a list of staff members on this page, with their name and their job title",
    schema: z.object({
      staff_members: z.array(
        z.object({
          name: z.string(),
          job_title: z.string(),
        }),
      ),
    }),
    modelName,
    useTextExtract,
  });

  const staff_members = result.staff_members;
  await stagehand.close();

  const expectedLength = 47;

  const expectedFirstItem = {
    name: "Louis Alvarez",
    job_title: "School Resource Officer",
  };

  const expectedLastItem = {
    name: "Jessica Zipin",
    job_title: "School Based Therapist",
  };

  if (staff_members.length !== expectedLength) {
    logger.error({
      message: "Incorrect number of items extracted",
      level: 0,
      auxiliary: {
        expected: {
          value: expectedLength.toString(),
          type: "integer",
        },
        actual: {
          value: staff_members.length.toString(),
          type: "integer",
        },
      },
    });

    return {
      _success: false,
      error: "Incorrect number of staff members extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  // Check for the presence of the expected items
  const firstItemExists = staff_members.some(
    (member) =>
      member.name === expectedFirstItem.name &&
      member.job_title === expectedFirstItem.job_title,
  );

  if (!firstItemExists) {
    logger.error({
      message: "Expected first staff member not found in extracted data",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedFirstItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(staff_members),
          type: "object",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      error: "Expected first staff member not found in extracted data",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const lastItemExists = staff_members.some(
    (member) =>
      member.name === expectedLastItem.name &&
      member.job_title === expectedLastItem.job_title,
  );

  if (!lastItemExists) {
    logger.error({
      message: "Expected last staff member not found in extracted data",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedLastItem),
          type: "object",
        },
        actual: {
          value: JSON.stringify(staff_members),
          type: "object",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      error: "Expected last staff member not found in extracted data",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  await stagehand.close();

  return {
    _success: true,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/google_jobs.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const google_jobs: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.google.com/");
    await stagehand.page.act({ action: "click on the about page" });
    await stagehand.page.act({ action: "click on the careers page" });
    await stagehand.page.act({ action: "input data scientist into role" });
    await stagehand.page.act({ action: "input new york city into location" });
    await stagehand.page.act({ action: "click on the search button" });
    await stagehand.page.act({ action: "click on the first job link" });

    const jobDetails = await stagehand.page.extract({
      instruction:
        "Extract the following details from the job posting: application deadline, minimum qualifications (degree and years of experience), and preferred qualifications (degree and years of experience)",
      schema: z.object({
        applicationDeadline: z
          .string()
          .describe("The date until which the application window will be open")
          .nullable(),
        minimumQualifications: z.object({
          degree: z.string().describe("The minimum required degree").nullable(),
          yearsOfExperience: z
            .number()
            .describe("The minimum required years of experience")
            .nullable(),
        }),
        preferredQualifications: z.object({
          degree: z.string().describe("The preferred degree").nullable(),
          yearsOfExperience: z
            .number()
            .describe("The preferred years of experience")
            .nullable(),
        }),
      }),
      modelName,
      useTextExtract,
    });

    const isJobDetailsValid =
      jobDetails &&
      Object.values(jobDetails).every(
        (value) =>
          value !== null &&
          value !== undefined &&
          (typeof value !== "object" ||
            Object.values(value).every(
              (v) =>
                v !== null &&
                v !== undefined &&
                (typeof v === "number" || typeof v === "string"),
            )),
      );

    await stagehand.close();

    return {
      _success: isJobDetailsValid,
      jobDetails,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "error in google_jobs function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      debugUrl,
      sessionUrl,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/homedepot.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const homedepot: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
    domSettleTimeoutMs: 60_000,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.homedepot.com/");
    await stagehand.page.act({ action: "search for gas grills" });
    await stagehand.page.act({ action: "click on the best selling gas grill" });
    await stagehand.page.act({ action: "click on the Product Details" });
    await stagehand.page.act({ action: "find the Primary Burner BTU" });

    const productSpecs = await stagehand.page.extract({
      instruction: "Extract the Primary exact Burner BTU of the product",
      schema: z.object({
        productSpecs: z
          .array(
            z.object({
              burnerBTU: z.string().describe("Primary Burner BTU exact value"),
            }),
          )
          .describe("Gas grill Primary Burner BTU exact value"),
      }),
      modelName,
      useTextExtract,
    });

    logger.log({
      message: `gas grill primary burner BTU`,
      level: 1,
      auxiliary: {
        productSpecs: {
          value: JSON.stringify(productSpecs),
          type: "object",
        },
      },
    });

    if (
      !productSpecs ||
      !productSpecs.productSpecs ||
      productSpecs.productSpecs.length !== 1
    ) {
      await stagehand.close();

      return {
        _success: false,
        productSpecs,
        debugUrl,
        sessionUrl,
        logs: logger.getLogs(),
      };
    }

    const hasFourZerosAndOne4 =
      (productSpecs.productSpecs[0].burnerBTU.match(/0/g) || []).length === 4 &&
      (productSpecs.productSpecs[0].burnerBTU.match(/4/g) || []).length === 1;

    await stagehand.close();

    return {
      _success: hasFourZerosAndOne4,
      productSpecs,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "error in homedepot function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/ibm.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const ibm: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.ibm.com/artificial-intelligence");

    await stagehand.page.act({
      action: "if there is a cookies popup, accept it",
    });

    const { title } = await stagehand.page.extract({
      instruction: "extract the title of the article",
      schema: z.object({
        title: z.string().describe("the title of the article"),
      }),
    });

    await stagehand.page.act({
      action: "click on the 'explore AI use cases' button",
    });

    await stagehand.page.waitForLoadState("networkidle");

    const url = await stagehand.page.url();

    await stagehand.close();

    const titleCheck = title.toLowerCase().includes("ai");
    const urlCheck = url === "https://www.ibm.com/watsonx/use-cases";

    return {
      _success: titleCheck && urlCheck,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error("Error or timeout occurred:", error);

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/imdb_movie_details.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const imdb_movie_details: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.imdb.com/title/tt0111161/", {
    waitUntil: "domcontentloaded",
  });
  await stagehand.page.act({
    action: "click on the movie ratings",
  });

  const movieDetails = await stagehand.page.extract({
    instruction: "Extract the list of countries with the most ratings.",
    schema: z.object({
      countries: z
        .array(z.string())
        .describe("List of countries with the most ratings"),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const expectedCountries = [
    "United States",
    "United Kingdom",
    "Turkey",
    "India",
    "Germany",
  ];

  if (!movieDetails.countries || movieDetails.countries.length !== 5) {
    logger.error({
      message: "Failed to extract exactly five countries",
      level: 0,
      auxiliary: {
        expected: {
          value: JSON.stringify(expectedCountries),
          type: "object",
        },
        actual: {
          value: JSON.stringify(movieDetails.countries || []),
          type: "object",
        },
      },
    });

    return {
      _success: false,
      error: "Incorrect number of countries extracted",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const missingCountries = expectedCountries.filter(
    (country) => !movieDetails.countries.includes(country),
  );

  if (missingCountries.length > 0) {
    logger.error({
      message: "Extracted countries do not match expected countries",
      level: 0,
      auxiliary: {
        missing: {
          value: JSON.stringify(missingCountries),
          type: "object",
        },
        extracted: {
          value: JSON.stringify(movieDetails.countries),
          type: "object",
        },
      },
    });

    return {
      _success: false,
      error: "Extracted countries do not match expected countries",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    countries: movieDetails.countries,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/ionwave_observe.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const ionwave_observe: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://elpasotexas.ionwave.net/Login.aspx");

  const observations = await stagehand.page.observe();

  if (observations.length === 0) {
    await stagehand.close();
    return {
      _success: false,
      observations,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  const expectedLocator = `div.rowLinks:nth-child(27) > div:nth-child(1) > a:nth-child(1)`;

  const expectedResult = await stagehand.page
    .locator(expectedLocator)
    .first()
    .innerText();

  let foundMatch = false;
  for (const observation of observations) {
    try {
      const observationResult = await stagehand.page
        .locator(observation.selector)
        .first()
        .innerText();

      if (observationResult === expectedResult) {
        foundMatch = true;
        break;
      }
    } catch (error) {
      console.warn(
        `Failed to check observation with selector ${observation.selector}:`,
        error.message,
      );
      continue;
    }
  }

  await stagehand.close();

  return {
    _success: foundMatch,
    expected: expectedResult,
    observations,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/ionwave.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const ionwave: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://elpasotexas.ionwave.net/Login.aspx");

  await stagehand.page.act({
    action: 'Click on "Closed Bids"',
  });

  const expectedUrl =
    "https://elpasotexas.ionwave.net/SourcingEvents.aspx?SourceType=2";
  const currentUrl = stagehand.page.url();

  await stagehand.close();

  return {
    _success: currentUrl.startsWith(expectedUrl),
    currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/laroche_form.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const laroche_form: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto(
      "https://www.laroche-posay.us/offers/anthelios-melt-in-milk-sunscreen-sample.html",
    );

    await stagehand.page.act({ action: "close the privacy policy popup" });
    await stagehand.page
      .waitForNavigation({ waitUntil: "domcontentloaded", timeout: 10000 })
      .catch(() => {});

    await stagehand.page.act({ action: "fill the last name field" });
    await stagehand.page.act({ action: "fill address 1 field" });
    await stagehand.page.act({ action: "select a state" });
    await stagehand.page.act({ action: "select a skin type" });

    return {
      _success: true,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  } catch (error) {
    logger.error({
      message: "error in LarocheForm function",
      level: 0,
      auxiliary: {
        error: {
          value: error.message,
          type: "string",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });
    return {
      _success: false,
      error: error.message,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } finally {
    await stagehand.close();
  }
};

================
File: evals/tasks/nonsense_action.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const nonsense_action: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto("https://www.homedepot.com/");

    const result = await stagehand.page.act({
      action: "click on the first banana",
    });
    console.log("result", result);

    // Assert the output
    const expectedResult = {
      success: false,
      message: "Action was not able to be completed.",
      action: "click on the first banana",
    };

    const isResultCorrect =
      JSON.stringify(result) === JSON.stringify(expectedResult);

    return {
      _success: isResultCorrect,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    console.error(`Error in nonsense_action function: ${error.message}`);
    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } finally {
    await stagehand.close();
  }
};

================
File: evals/tasks/panamcs.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const panamcs: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://panamcs.org/about/staff/");

  const observations = await stagehand.page.observe();

  if (observations.length === 0) {
    await stagehand.close();
    return {
      _success: false,
      observations,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  const expectedLocator = `a.btn:nth-child(3)`;

  const expectedResult = await stagehand.page
    .locator(expectedLocator)
    .first()
    .innerText();

  let foundMatch = false;
  for (const observation of observations) {
    try {
      const observationResult = await stagehand.page
        .locator(observation.selector)
        .first()
        .innerText();

      if (observationResult === expectedResult) {
        foundMatch = true;
        break;
      }
    } catch (error) {
      console.warn(
        `Failed to check observation with selector ${observation.selector}:`,
        error.message,
      );
      continue;
    }
  }

  await stagehand.close();

  return {
    _success: foundMatch,
    expected: expectedResult,
    observations,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/peeler_complex.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { z } from "zod";

export const peeler_complex: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  try {
    await stagehand.page.goto(`https://chefstoys.com/`, { timeout: 60000 });

    await stagehand.page.act({
      action: "search for %search_query%",
      variables: {
        search_query: "peeler",
      },
    });

    await stagehand.page.act({
      action: 'click on the first "OXO" brand peeler',
    });

    const { price } = await stagehand.page.extract({
      instruction: "get the price of the peeler",
      schema: z.object({ price: z.number().nullable() }),
      modelName,
      useTextExtract,
    });

    await stagehand.close();

    return {
      _success: price === 11.99,
      price,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  } catch (error) {
    logger.error({
      message: "error in peeler_complex function",
      level: 0,
      auxiliary: {
        error: {
          value: JSON.stringify(error, null, 2),
          type: "object",
        },
        trace: {
          value: error.stack,
          type: "string",
        },
      },
    });

    await stagehand.close();

    return {
      _success: false,
      error: JSON.parse(JSON.stringify(error, null, 2)),
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }
};

================
File: evals/tasks/peeler_simple.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

const env: "BROWSERBASE" | "LOCAL" =
  process.env.EVAL_ENV?.toLowerCase() === "browserbase"
    ? "BROWSERBASE"
    : "LOCAL";

export const peeler_simple: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  if (env === "BROWSERBASE") {
    throw new Error(
      "Browserbase not supported for this eval since we block all requests to file://",
    );
  }

  await stagehand.page.goto(`file://${process.cwd()}/evals/assets/peeler.html`);
  await stagehand.page.act({ action: "add the peeler to cart" });

  const successMessageLocator = stagehand.page.locator(
    'text="Congratulations, you have 1 A in your cart"',
  );
  const isVisible = await successMessageLocator.isVisible();

  await stagehand.close();

  return {
    _success: isVisible,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/rakuten_jp.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const rakuten_jp: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.rakuten.co.jp/");
  await stagehand.page.act({ action: "click on online supermarket" });

  await stagehand.page.act({ action: "if there is a popup, close it" });

  await stagehand.page.act({
    action: "navigate to Inageya Online Supermarket",
  });
  await stagehand.page.act({ action: "click the search bar input" });
  await stagehand.page.act({ action: "search for '香菜'" });

  const url = stagehand.page.url();
  const successUrl =
    "https://netsuper.rakuten.co.jp/inageya/search/?keyword=%E9%A6%99%E8%8F%9C";

  await stagehand.close();

  return {
    _success: url === successUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/sciquest.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";
import { z } from "zod";

export const sciquest: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://bids.sciquest.com/apps/Router/PublicEvent?tab=PHX_NAV_SourcingAllOpps&CustomerOrg=StateOfUtah",
  );

  await stagehand.page.act({
    action: 'Click on the "Closed" tab',
  });

  const result = await stagehand.page.extract({
    instruction:
      "Extract the total number of results that the search produced. Not the number of results displayed on the page.",
    schema: z.object({
      total_results: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { total_results } = result;

  const expectedNumber = 12637;
  const extractedNumber = parseInt(total_results.replace(/[^\d]/g, ""), 10);

  const isWithinRange =
    extractedNumber >= expectedNumber - 1000 &&
    extractedNumber <= expectedNumber + 1000;

  if (!isWithinRange) {
    logger.error({
      message: "Total number of results is not within the expected range",
      level: 0,
      auxiliary: {
        expected: {
          value: `${expectedNumber} ± 1000`,
          type: "string",
        },
        actual: {
          value: extractedNumber.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Total number of results is not within the expected range",
      extractedNumber,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  return {
    _success: true,
    extractedNumber,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/shopify_homepage.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const shopify_homepage: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.shopify.com/");

  const observations = await stagehand.page.observe();

  if (observations.length === 0) {
    await stagehand.close();
    return {
      _success: false,
      observations,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  const expectedLocator = `body > div.relative > header > div > div > div.ml-auto > ul.lg\\:flex.hidden.items-center > li.leading-\\[0\\] > a`;

  const expectedResult = await stagehand.page
    .locator(expectedLocator)
    .first()
    .innerText();

  let foundMatch = false;
  for (const observation of observations) {
    try {
      const observationResult = await stagehand.page
        .locator(observation.selector)
        .first()
        .innerText();

      if (observationResult === expectedResult) {
        foundMatch = true;
        break;
      }
    } catch (error) {
      console.warn(
        `Failed to check observation with selector ${observation.selector}:`,
        error.message,
      );
      continue;
    }
  }

  await stagehand.close();

  return {
    _success: foundMatch,
    expected: expectedResult,
    observations,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/simple_google_search.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const simple_google_search: EvalFunction = async ({
  modelName,
  logger,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.google.com");

  await stagehand.page.act({
    action: 'Search for "OpenAI"',
  });

  const expectedUrl = "https://www.google.com/search?q=OpenAI";
  const currentUrl = stagehand.page.url();

  await stagehand.close();

  return {
    _success: currentUrl.startsWith(expectedUrl),
    currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/stock_x.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const stock_x: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://stockx.com/air-jordan-3-retro-black-cement-2024",
  );

  await stagehand.page.waitForTimeout(3000);

  await stagehand.page.act({
    action: "click on Jordan 3 Retro Crimson in the related products",
  });

  await stagehand.page.waitForTimeout(2000);
  const currentUrl = stagehand.page.url();
  const expectedUrlPrefix = "https://stockx.com/jordan-3-retro-crimson";

  await stagehand.close();

  return {
    _success: currentUrl.startsWith(expectedUrlPrefix),
    currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/ted_talk.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";
import { normalizeString } from "../utils";
import { z } from "zod";

export const ted_talk: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(
    "https://www.ted.com/talks/sir_ken_robinson_do_schools_kill_creativity",
    {
      waitUntil: "domcontentloaded",
    },
  );
  await stagehand.page.act({
    action:
      "Click the link that takes you to the page about the 'Culture' topic",
  });

  const playlists = await stagehand.page.extract({
    instruction:
      "Extract the video playlist titles and the number of talks in each playlist. This info is in the Video Playlists about Culture section of the webpage.",
    schema: z.object({
      playlists: z
        .array(
          z.object({
            title: z.string().describe("Title of the playlist"),
            num_talks: z.number().describe("Number of talks in the playlist"),
          }),
        )
        .describe("List of culture video playlists"),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const expectedPlaylists = [
    {
      title: "Talks that celebrate the boundless creativity of an open mind",
      num_talks: 6,
    },
    {
      title: "Little-known big history",
      num_talks: 15,
    },
    {
      title: "Extraordinary, larger-than-life art",
      num_talks: 10,
    },
    {
      title: "How perfectionism fails us",
      num_talks: 4,
    },
  ];

  if (!playlists.playlists || playlists.playlists.length === 0) {
    logger.error({
      message: "Failed to extract playlists on culture",
      level: 0,
    });

    return {
      _success: false,
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  const missingPlaylists = expectedPlaylists.filter((expected) =>
    playlists.playlists.every(
      (extracted) =>
        normalizeString(extracted.title) !== normalizeString(expected.title) ||
        extracted.num_talks !== expected.num_talks,
    ),
  );

  if (missingPlaylists.length > 0) {
    logger.error({
      message: "Extracted playlists do not match expected playlists",
      level: 0,
      auxiliary: {
        missing: {
          value: JSON.stringify(missingPlaylists),
          type: "object",
        },
        extracted: {
          value: JSON.stringify(playlists.playlists),
          type: "object",
        },
      },
    });

    return {
      _success: false,
      error: "Extracted playlists do not match expected playlists",
      logs: logger.getLogs(),
      debugUrl,
      sessionUrl,
    };
  }

  return {
    _success: true,
    playlists: playlists.playlists,
    logs: logger.getLogs(),
    debugUrl,
    sessionUrl,
  };
};

================
File: evals/tasks/vanta_h.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const vanta_h: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.vanta.com/");

  const observations = await stagehand.page.observe({
    instruction: "find the buy now button if it is available",
  });

  await stagehand.close();

  // we should have no saved observation since the element shouldn't exist
  return {
    _success: observations.length === 0,
    observations,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/vanta.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const vanta: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.vanta.com/");
  await stagehand.page.act({ action: "close the cookies popup" });

  const observations = await stagehand.page.observe();

  if (observations.length === 0) {
    await stagehand.close();
    return {
      _success: false,
      observations,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  const expectedLocator = `body > div.page-wrapper > div.nav_component > div.nav_element.w-nav > div.padding-global > div > div > nav > div.nav_cta-wrapper.is-new > a.nav_link.is-tablet-margin-0.w-nav-link`;

  const expectedResult = await stagehand.page
    .locator(expectedLocator)
    .first()
    .innerHTML();

  let foundMatch = false;
  for (const observation of observations) {
    try {
      const observationResult = await stagehand.page
        .locator(observation.selector)
        .first()
        .innerHTML();

      if (observationResult === expectedResult) {
        foundMatch = true;
        break;
      }
    } catch (error) {
      console.warn(
        `Failed to check observation with selector ${observation.selector}:`,
        error.message,
      );
      continue;
    }
  }

  await stagehand.close();

  return {
    _success: foundMatch,
    expected: expectedResult,
    observations,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/vantechjournal.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";

export const vantechjournal: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://vantechjournal.com/");

  await stagehand.page.act({
    action: "click on page 8. do not click the next button",
  });

  const expectedUrl = "https://vantechjournal.com/archive?page=8";
  const currentUrl = stagehand.page.url();

  await stagehand.close();

  return {
    _success: currentUrl === expectedUrl,
    currentUrl,
    expectedUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/wichita.ts
================
import { initStagehand } from "../initStagehand";
import { EvalFunction } from "../../types/evals";
import { z } from "zod";

export const wichita: EvalFunction = async ({
  modelName,
  logger,
  useTextExtract,
}) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto("https://www.wichitafallstx.gov/Bids.aspx");

  await stagehand.page.act({
    action: 'Click on "Show Closed/Awarded/Cancelled bids"',
  });

  const result = await stagehand.page.extract({
    instruction: "Extract the total number of bids that the search produced.",
    schema: z.object({
      total_results: z.string(),
    }),
    modelName,
    useTextExtract,
  });

  await stagehand.close();

  const { total_results } = result;

  const expectedNumber = 405;
  const extractedNumber = parseInt(total_results.replace(/[^\d]/g, ""), 10);

  const isWithinRange =
    extractedNumber >= expectedNumber - 10 &&
    extractedNumber <= expectedNumber + 10;

  if (!isWithinRange) {
    logger.error({
      message: "Total number of results is not within the expected range",
      level: 0,
      auxiliary: {
        expected: {
          value: `${expectedNumber} ± 10`,
          type: "string",
        },
        actual: {
          value: extractedNumber.toString(),
          type: "integer",
        },
      },
    });
    return {
      _success: false,
      error: "Total number of results is not within the expected range",
      extractedNumber,
      debugUrl,
      sessionUrl,
      logs: logger.getLogs(),
    };
  }

  return {
    _success: true,
    extractedNumber,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/tasks/wikipedia.ts
================
import { EvalFunction } from "../../types/evals";
import { initStagehand } from "../initStagehand";

export const wikipedia: EvalFunction = async ({ modelName, logger }) => {
  const { stagehand, initResponse } = await initStagehand({
    modelName,
    logger,
  });

  const { debugUrl, sessionUrl } = initResponse;

  await stagehand.page.goto(`https://en.wikipedia.org/wiki/Baseball`);
  await stagehand.page.act({
    action: 'click the "hit and run" link in this article',
  });

  const url = "https://en.wikipedia.org/wiki/Hit_and_run_(baseball)";
  const currentUrl = stagehand.page.url();

  await stagehand.close();

  return {
    _success: currentUrl === url,
    expected: url,
    actual: currentUrl,
    debugUrl,
    sessionUrl,
    logs: logger.getLogs(),
  };
};

================
File: evals/args.ts
================
import process from "process";
import { EvalCategorySchema } from "../types/evals";

// Extract command-line arguments passed to this script.
const args = process.argv.slice(2);

/**
 * The default categories of evaluations to run if none is specified.
 * These categories represent different styles or types of tasks.
 */
const DEFAULT_EVAL_CATEGORIES = process.env.EVAL_CATEGORIES
  ? process.env.EVAL_CATEGORIES.split(",")
  : [
      "observe",
      "act",
      "combination",
      "extract",
      "experimental",
      "text_extract",
    ];

/**
 * Determine which extraction method to use for tasks that involve extraction.
 * By default, "domExtract" is used. However, if a `--extract-method=<method>`
 * argument is provided, it will override the default.
 */
let extractMethod = "domExtract";
const extractMethodArg = args.find((arg) =>
  arg.startsWith("--extract-method="),
);
if (extractMethodArg) {
  extractMethod = extractMethodArg.split("=")[1];
}

// Set the extraction method in the process environment so tasks can reference it.
process.env.EXTRACT_METHOD = extractMethod;
const useTextExtract = process.env.EXTRACT_METHOD === "textExtract";

/**
 * Variables for filtering which tasks to run:
 * - `filterByCategory`: if provided, only tasks that belong to this category will be run.
 * - `filterByEvalName`: if provided, only the task with this name will be run.
 */
let filterByCategory: string | null = null;
let filterByEvalName: string | null = null;

/**
 * Check the first argument:
 * - If it is "category", the next argument should be the category name.
 * - Otherwise, assume it is a specific evaluation (task) name.
 */
if (args.length > 0) {
  if (args[0].toLowerCase() === "category") {
    filterByCategory = args[1];
    if (!filterByCategory) {
      console.error("Error: Category name not specified.");
      process.exit(1);
    }
    // Validate that the category is one of the known ones.
    try {
      EvalCategorySchema.parse(filterByCategory);
    } catch {
      console.error(
        `Error: Invalid category "${filterByCategory}". Valid categories are: ${DEFAULT_EVAL_CATEGORIES.join(", ")}`,
      );
      process.exit(1);
    }
  } else {
    // Otherwise, treat it as a filter by evaluation name.
    filterByEvalName = args[0];
  }
}

export {
  filterByCategory,
  filterByEvalName,
  useTextExtract,
  DEFAULT_EVAL_CATEGORIES,
};

================
File: evals/env.ts
================
/**
 * Determine the current environment in which the evaluations are running:
 * - BROWSERBASE or LOCAL
 *
 * The environment is read from the EVAL_ENV environment variable.
 */
export const env: "BROWSERBASE" | "LOCAL" =
  process.env.EVAL_ENV?.toLowerCase() === "browserbase"
    ? "BROWSERBASE"
    : "LOCAL";

/**
 * Enable or disable caching based on the EVAL_ENABLE_CACHING environment variable.
 * Caching may improve performance by not re-fetching or re-computing certain results.
 * By default, caching is disabled unless explicitly enabled.
 */
export const enableCaching =
  process.env.EVAL_ENABLE_CACHING?.toLowerCase() === "true";

================
File: evals/evals.config.json
================
{
  "tasks": [
    {
      "name": "amazon_add_to_cart",
      "categories": ["act"]
    },
    {
      "name": "bidnet",
      "categories": ["act"]
    },
    {
      "name": "ionwave",
      "categories": ["act"]
    },
    {
      "name": "laroche_form",
      "categories": ["act"]
    },
    {
      "name": "nonsense_action",
      "categories": ["act"]
    },
    {
      "name": "peeler_simple",
      "categories": ["act"]
    },
    {
      "name": "simple_google_search",
      "categories": ["act"]
    },
    {
      "name": "vantechjournal",
      "categories": ["act"]
    },
    {
      "name": "wikipedia",
      "categories": ["act"]
    },

    {
      "name": "allrecipes",
      "categories": ["combination"]
    },
    {
      "name": "arxiv",
      "categories": ["combination"]
    },
    {
      "name": "extract_collaborators",
      "categories": ["combination"]
    },
    {
      "name": "extract_github_commits",
      "categories": ["combination"]
    },
    {
      "name": "imdb_movie_details",
      "categories": ["combination"]
    },
    {
      "name": "peeler_complex",
      "categories": ["combination"]
    },
    {
      "name": "sciquest",
      "categories": ["combination"]
    },
    {
      "name": "wichita",
      "categories": ["combination"]
    },

    {
      "name": "apple",
      "categories": ["experimental"]
    },
    {
      "name": "combination_sauce",
      "categories": ["experimental"]
    },
    {
      "name": "costar",
      "categories": ["experimental"]
    },
    {
      "name": "expedia",
      "categories": ["experimental"]
    },
    {
      "name": "expedia_search",
      "categories": ["experimental"]
    },
    {
      "name": "extract_aigrant_companies",
      "categories": ["experimental", "text_extract"]
    },
    {
      "name": "extract_capacitor_info",
      "categories": ["experimental", "text_extract"]
    },
    {
      "name": "extract_partners",
      "categories": ["experimental"]
    },
    {
      "name": "extract_press_releases",
      "categories": ["experimental", "text_extract"]
    },
    {
      "name": "extract_snowshoeing_destinations",
      "categories": ["experimental", "text_extract"]
    },
    {
      "name": "google_jobs",
      "categories": ["experimental"]
    },
    {
      "name": "homedepot",
      "categories": ["experimental"]
    },
    {
      "name": "ibm",
      "categories": ["experimental"]
    },
    {
      "name": "rakuten_jp",
      "categories": ["experimental"]
    },
    {
      "name": "stock_x",
      "categories": ["experimental"]
    },
    {
      "name": "ted_talk",
      "categories": ["experimental"]
    },

    {
      "name": "extract_baptist_health",
      "categories": ["extract"]
    },
    {
      "name": "extract_github_stars",
      "categories": ["extract"]
    },
    {
      "name": "extract_memorial_healthcare",
      "categories": ["extract"]
    },
    {
      "name": "extract_nhl_stats",
      "categories": ["extract"]
    },
    {
      "name": "extract_professional_info",
      "categories": ["extract"]
    },
    {
      "name": "extract_regulations",
      "categories": ["extract"]
    },
    {
      "name": "extract_resistor_info",
      "categories": ["extract"]
    },
    {
      "name": "extract_rockauto",
      "categories": ["extract"]
    },
    {
      "name": "extract_staff_members",
      "categories": ["extract"]
    },

    {
      "name": "ionwave_observe",
      "categories": ["observe"]
    },
    {
      "name": "panamcs",
      "categories": ["observe"]
    },
    {
      "name": "shopify_homepage",
      "categories": ["observe"]
    },
    {
      "name": "vanta",
      "categories": ["observe"]
    },
    {
      "name": "vanta_h",
      "categories": ["observe"]
    },

    {
      "name": "extract_area_codes",
      "categories": ["text_extract"]
    },
    {
      "name": "extract_public_notices",
      "categories": ["text_extract"]
    },
    {
      "name": "extract_research_reports",
      "categories": ["text_extract"]
    }
  ]
}

================
File: evals/index.eval.ts
================
/**
 * This script orchestrates the running of evaluations against a set of tasks.
 * It braintrust to run multiple testcases (each testcase representing a
 * given task-model combination) and then aggregates the results, producing
 * a summary of passes, failures, and categorized success rates.
 *
 * Overview:
 * - Reads a configuration file `evals.config.json` to determine what tasks (evaluations)
 *   are available and which categories they belong to.
 * - Supports filtering which tasks to run either by evaluation category or by specific task name.
 * - Supports multiple models, defaulting to certain sets of models depending on the category.
 * - Runs each selected task against each selected model in parallel, collecting results.
 * - Saves a summary of the evaluation results to `eval-summary.json`.
 */
import fs from "fs";
import path from "path";
import process from "process";
import { env } from "./env";
import { generateExperimentName } from "./utils";
import { exactMatch, errorMatch } from "./scoring";
import { tasksByName, MODELS } from "./taskConfig";
import { filterByCategory, filterByEvalName, useTextExtract } from "./args";
import { Eval } from "braintrust";
import { EvalFunction, SummaryResult, Testcase } from "../types/evals";
import { EvalLogger } from "./logger";
import { AvailableModel } from "../types/model";
import dotenv from "dotenv";
dotenv.config();

const MAX_CONCURRENCY = 20;
const TRIAL_COUNT = 5;

/**
 * generateSummary:
 * After all evaluations have finished, aggregate the results into a summary.
 * This summary includes:
 * - Which tasks passed or failed (with model and categories).
 * - Category-wise success percentages.
 * - Model-wise success percentages.
 *
 * The summary is written to `eval-summary.json` for further analysis.
 */
const generateSummary = async (
  results: SummaryResult[],
  experimentName: string,
) => {
  // Determine passed testcases (those with _success: true)
  const passed = results
    .filter((r) => r.output._success)
    .map((r) => ({
      eval: r.input.name,
      model: r.input.modelName,
      categories: tasksByName[r.input.name].categories,
    }));

  // Determine failed testcases (those with _success: false)
  const failed = results
    .filter((r) => !r.output._success)
    .map((r) => ({
      eval: r.input.name,
      model: r.input.modelName,
      categories: tasksByName[r.input.name].categories,
    }));

  // Calculate success counts for each category
  const categorySuccessCounts: Record<
    string,
    { total: number; success: number }
  > = {};
  for (const taskName of Object.keys(tasksByName)) {
    const taskCategories = tasksByName[taskName].categories;
    const taskResults = results.filter((r) => r.input.name === taskName);
    const successCount = taskResults.filter((r) => r.output._success).length;

    for (const cat of taskCategories) {
      if (!categorySuccessCounts[cat]) {
        categorySuccessCounts[cat] = { total: 0, success: 0 };
      }
      categorySuccessCounts[cat].total += taskResults.length;
      categorySuccessCounts[cat].success += successCount;
    }
  }

  // Compute percentage success per category
  const categories: Record<string, number> = {};
  for (const [cat, counts] of Object.entries(categorySuccessCounts)) {
    categories[cat] = Math.round((counts.success / counts.total) * 100);
  }

  // Compute percentage success per model
  const models: Record<string, number> = {};
  const allModels = [...new Set(results.map((r) => r.input.modelName))];
  for (const model of allModels) {
    const modelResults = results.filter((r) => r.input.modelName === model);
    const successCount = modelResults.filter((r) => r.output._success).length;
    models[model] = Math.round((successCount / modelResults.length) * 100);
  }

  // Format and write the summary to a JSON file
  const formattedSummary = {
    experimentName,
    passed,
    failed,
    categories,
    models,
  };

  fs.writeFileSync(
    "eval-summary.json",
    JSON.stringify(formattedSummary, null, 2),
  );
  console.log("Evaluation summary written to eval-summary.json");
};

/**
 * generateFilteredTestcases:
 * Based on the chosen filters (category or specific eval name) and environment,
 * this function generates the set of testcases to run. Each testcase is a combination
 * of a task and a model.
 *
 * Steps:
 * - Start with all combinations of tasks (from `tasksByName`) and models (`MODELS`).
 * - Filter by category if a category filter was specified.
 * - Filter by evaluation name if specified.
 * - In the BROWSERBASE environment, exclude certain tasks that are not suitable.
 */
const generateFilteredTestcases = (): Testcase[] => {
  // Create a list of all testcases for each model-task combination.
  let allTestcases = MODELS.flatMap((model) =>
    Object.keys(tasksByName).map((testName) => ({
      input: { name: testName, modelName: model },
      name: testName,
      tags: [model, testName],
      metadata: {
        model,
        test: testName,
      },
      expected: true,
    })),
  );

  // Filter by category if a category is specified
  if (filterByCategory) {
    allTestcases = allTestcases.filter((testcase) =>
      tasksByName[testcase.name].categories.includes(filterByCategory!),
    );
  }

  // Filter by a specific evaluation (task) name if specified
  if (filterByEvalName) {
    allTestcases = allTestcases.filter(
      (testcase) =>
        testcase.name === filterByEvalName ||
        testcase.input.name === filterByEvalName,
    );
  }

  // If running in BROWSERBASE environment, exclude tasks that are not applicable.
  if (env === "BROWSERBASE") {
    allTestcases = allTestcases.filter(
      (testcase) => !["peeler_simple", "stock_x"].includes(testcase.name),
    );
  }

  return allTestcases;
};

/**
 * Main execution block:
 * - Determine experiment name
 * - Determine the project name (braintrustProjectName) based on CI or dev environment
 * - Run the Eval function with the given configuration:
 *    * experimentName: A label for this run
 *    * data: A function that returns the testcases to run
 *    * task: A function that executes each task, given input specifying model and task name
 *    * scores: An array of scoring functions
 *    * maxConcurrency: Limit on parallel tasks
 *    * trialCount: Number of trials (retries) per task
 * - Collect and summarize results using `generateSummary`.
 */
(async () => {
  // Generate a unique name for the experiment
  const experimentName: string = generateExperimentName({
    evalName: filterByEvalName || undefined,
    category: filterByCategory || undefined,
    environment: env,
  });

  // Determine braintrust project name to use (stagehand in CI, stagehand-dev otherwise)
  const braintrustProjectName =
    process.env.CI === "true" ? "stagehand" : "stagehand-dev";

  try {
    // Run the evaluations with the braintrust Eval function
    const evalResult = await Eval(braintrustProjectName, {
      experimentName,
      data: generateFilteredTestcases,
      // Each test is a function that runs the corresponding task module
      task: async (input: { name: string; modelName: AvailableModel }) => {
        const logger = new EvalLogger();
        try {
          // Dynamically import the task based on its name
          const taskModulePath = path.join(
            __dirname,
            "tasks",
            `${input.name}.ts`,
          );
          const taskModule = (await import(taskModulePath)) as {
            [key: string]: EvalFunction;
          };
          const taskFunction = taskModule[input.name];

          if (typeof taskFunction !== "function") {
            throw new Error(
              `Task function for ${input.name} is not a function`,
            );
          }

          // Execute the task
          const result = await taskFunction({
            modelName: input.modelName,
            logger,
            useTextExtract,
          });

          // Log result to console
          if (result && result._success) {
            console.log(`✅ ${input.name}: Passed`);
          } else {
            console.log(`❌ ${input.name}: Failed`);
          }
          return result;
        } catch (error) {
          // Log any errors that occur during task execution
          console.error(`❌ ${input.name}: Error - ${error}`);
          logger.error({
            message: `Error in task ${input.name}`,
            level: 0,
            auxiliary: {
              error: {
                value: error.message,
                type: "object",
              },
              trace: {
                value: error.stack,
                type: "string",
              },
            },
          });
          return {
            _success: false,
            error: JSON.parse(JSON.stringify(error, null, 2)),
            logs: logger.getLogs(),
          };
        }
      },
      // Use the scoring functions defined above
      scores: [exactMatch, errorMatch],
      maxConcurrency: MAX_CONCURRENCY,
      trialCount: TRIAL_COUNT,
    });

    // Map results to the SummaryResult format
    const summaryResults: SummaryResult[] = evalResult.results.map((result) => {
      const output =
        typeof result.output === "boolean"
          ? { _success: result.output }
          : result.output;

      return {
        input: result.input,
        output,
        name: result.input.name,
        score: output._success ? 1 : 0,
      };
    });

    // Generate and write the summary
    await generateSummary(summaryResults, experimentName);
  } catch (error) {
    console.error("Error during evaluation run:", error);
    process.exit(1);
  }
})();

================
File: evals/initStagehand.ts
================
/**
 * This file provides a function to initialize a Stagehand instance for use in evaluations.
 * It configures the Stagehand environment and sets default options based on the current environment
 * (e.g., local or BROWSERBASE), caching preferences, and verbosity. It also establishes a logger for
 * capturing logs emitted by Stagehand.
 *
 * We create a central config object (`StagehandConfig`) that defines all parameters for Stagehand.
 *
 * The `initStagehand` function takes the model name, an optional DOM settling timeout, and an EvalLogger,
 * then uses these to override some default values before creating and initializing the Stagehand instance.
 */

import { enableCaching, env } from "./env";
import { AvailableModel, LogLine, Stagehand } from "../lib";
import { EvalLogger } from "./logger";

/**
 * StagehandConfig:
 * This configuration object follows a similar pattern to `examples/stagehand.config.ts`.
 * It sets the environment, verbosity, caching preferences, and other defaults. Some values,
 * like `apiKey` and `projectId`, can be defined via environment variables if needed.
 *
 * Adjust or remove fields as appropriate for your environment.
 */
const StagehandConfig = {
  env: env,
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
  verbose: 2 as const,
  debugDom: true,
  headless: false,
  enableCaching,
  domSettleTimeoutMs: 30_000,
  modelName: "gpt-4o", // default model, can be overridden by initStagehand arguments
  modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  },
  logger: (logLine: LogLine) =>
    console.log(`[stagehand::${logLine.category}] ${logLine.message}`),
};

/**
 * Initializes a Stagehand instance for a given model:
 * - modelName: The model to use (overrides default in StagehandConfig)
 * - domSettleTimeoutMs: Optional timeout for DOM settling operations
 * - logger: An EvalLogger instance for capturing logs
 *
 * Returns:
 * - stagehand: The initialized Stagehand instance
 * - logger: The provided logger, associated with the Stagehand instance
 * - initResponse: Any response data returned by Stagehand initialization
 */
export const initStagehand = async ({
  modelName,
  domSettleTimeoutMs,
  logger,
}: {
  modelName: AvailableModel;
  domSettleTimeoutMs?: number;
  logger: EvalLogger;
}) => {
  let chosenApiKey: string | undefined = process.env.OPENAI_API_KEY;
  if (modelName.startsWith("claude")) {
    chosenApiKey = process.env.ANTHROPIC_API_KEY;
  }

  const config = {
    ...StagehandConfig,
    modelName,
    ...(domSettleTimeoutMs && { domSettleTimeoutMs }),
    modelClientOptions: {
      apiKey: chosenApiKey,
    },
    logger: (logLine: LogLine) => {
      logger.log(logLine);
    },
  };

  const stagehand = new Stagehand(config);

  // Associate the logger with the Stagehand instance
  logger.init(stagehand);

  const initResponse = await stagehand.init();
  return { stagehand, logger, initResponse };
};

================
File: evals/logger.ts
================
/**
 * This file defines the `EvalLogger` class, which is used to capture and manage
 * log lines during the evaluation process. The logger supports different log
 * levels (info, error, warn), stores logs in memory for later retrieval, and
 * also prints them to the console for immediate feedback.
 *
 * The `parseLogLine` function helps transform raw `LogLine` objects into a more
 * structured format (`LogLineEval`), making auxiliary data easier to understand
 * and analyze. By associating an `EvalLogger` instance with a `Stagehand` object,
 * all logs emitted during the evaluation process can be captured, persisted, and
 * reviewed after the tasks complete.
 */
import { logLineToString } from "../lib/utils";
import { LogLine } from "../types/log";
import { LogLineEval } from "../types/evals";
import { Stagehand } from "../lib";

/**
 * parseLogLine:
 * Given a LogLine, attempts to parse its `auxiliary` field into a structured object.
 * If parsing fails, logs an error and returns the original line.
 *
 * The `auxiliary` field in the log line typically contains additional metadata about the log event.
 */
function parseLogLine(logLine: LogLine): LogLineEval {
  try {
    return {
      ...logLine,
      // Remove the original auxiliary field in favor of parsedAuxiliary
      auxiliary: undefined,
      parsedAuxiliary: logLine.auxiliary
        ? Object.fromEntries(
            Object.entries(logLine.auxiliary).map(([key, entry]) => [
              key,
              entry.type === "object" ? JSON.parse(entry.value) : entry.value,
            ]),
          )
        : undefined,
    } as LogLineEval;
  } catch (e) {
    console.log("Error parsing log line", logLine);
    console.error(e);
    return logLine;
  }
}

/**
 * EvalLogger:
 * A logger class used during evaluations to capture and print log lines.
 *
 * Capabilities:
 * - Maintains an internal array of log lines (EvalLogger.logs) for later retrieval.
 * - Can be initialized with a Stagehand instance to provide consistent logging.
 * - Supports logging at different levels (info, error, warn).
 * - Each log line is converted to a string and printed to console for immediate feedback.
 * - Also keeps a structured version of the logs that can be returned for analysis or
 *   included in evaluation output.
 */
export class EvalLogger {
  logs: LogLineEval[] = [];
  stagehand?: Stagehand;

  constructor() {}

  /**
   * init:
   * Associates this logger with a given Stagehand instance.
   * This allows the logger to provide additional context if needed.
   */
  init(stagehand: Stagehand) {
    this.stagehand = stagehand;
  }

  /**
   * log:
   * Logs a message at the default (info) level.
   * Uses `logLineToString` to produce a readable output on the console,
   * and then stores the parsed log line in `this.logs`.
   */
  log(logLine: LogLine) {
    console.log(logLineToString(logLine));
    this.logs.push(parseLogLine(logLine));
  }

  /**
   * error:
   * Logs an error message with `console.error` and stores it.
   * Useful for capturing and differentiating error-level logs.
   */
  error(logLine: LogLine) {
    console.error(logLineToString(logLine));
    this.logs.push(parseLogLine(logLine));
  }

  /**
   * warn:
   * Logs a warning message with `console.warn` and stores it.
   * Helps differentiate warnings from regular info logs.
   */
  warn(logLine: LogLine) {
    console.warn(logLineToString(logLine));
    this.logs.push(parseLogLine(logLine));
  }

  /**
   * getLogs:
   * Retrieves the array of stored log lines.
   * Useful for returning logs after a task completes, for analysis or debugging.
   */
  getLogs() {
    return this.logs;
  }
}

================
File: evals/scoring.ts
================
/**
 * This file implements scoring functions needed by braintrust.
 */

import { EvalArgs, EvalInput, EvalResult } from "../types/evals";

/**
 * Scoring function: exactMatch
 * Given the arguments (including input, output, and expected result),
 * this returns a score of 1 if the result matches the expectation, and 0 otherwise.
 *
 * If "expected" is true, it checks if the output indicates success.
 * If "expected" is a boolean or an object with _success flag,
 * it checks if output is exactly that success condition.
 */
export function exactMatch(
  args: EvalArgs<EvalInput, boolean | { _success: boolean }, unknown>,
): EvalResult {
  console.log(`Task "${args.input.name}" returned: ${args.output}`);

  const expected = args.expected ?? true;
  if (expected === true) {
    // If we expect a success (true), then we check the output's _success flag.
    return {
      name: "Exact match",
      score:
        typeof args.output === "boolean"
          ? args.output
            ? 1
            : 0
          : args.output._success
            ? 1
            : 0,
    };
  }

  // If expected is not true, just directly compare the output to expected.
  return {
    name: "Exact match",
    score: args.output === expected ? 1 : 0,
  };
}

/**
 * Scoring function: errorMatch
 * Determines if an error occurred in the task.
 * Scores 1 if an error is found, otherwise 0.
 */
export function errorMatch(
  args: EvalArgs<
    EvalInput,
    boolean | { _success: boolean; error?: unknown },
    unknown
  >,
): EvalResult {
  console.log(`Task "${args.input.name}" returned: ${args.output}`);

  return {
    name: "Error rate",
    score:
      typeof args.output === "object" && args.output.error !== undefined
        ? 1
        : 0,
  };
}

================
File: evals/taskConfig.ts
================
/**
 * This file is responsible for:
 * - Loading and parsing the `evals.config.json` file, which defines tasks (evaluations) and their associated categories.
 * - Building a lookup structure (`tasksByName`) to map each task name to its categories.
 * - Filtering tasks based on command-line arguments (e.g., `filterByEvalName`) and ensuring that requested tasks exist.
 * - Determining which models to use for evaluations, depending on the category and environment variables.
 * - Validating that the chosen models are supported.
 *
 * The exported objects (`tasksByName`, `MODELS`, `config`) are used by the main evaluation script and other modules
 * to know which tasks and models are available, and to configure the evaluations accordingly.
 */

import fs from "fs";
import path from "path";
import { AvailableModel, AvailableModelSchema } from "../types/model";
import { filterByEvalName } from "./args";

// The configuration file `evals.config.json` contains a list of tasks and their associated categories.
const configPath = path.join(__dirname, "evals.config.json");
const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));

/**
 * The `tasksConfig` defines all tasks from the config file. Each task has a name and categories.
 * We create a mapping `tasksByName` from task name to its categories for quick lookup.
 */
type TaskConfig = { name: string; categories: string[] };
const tasksConfig = config.tasks as TaskConfig[];

const tasksByName = tasksConfig.reduce<
  Record<string, { categories: string[] }>
>((acc, task) => {
  acc[task.name] = { categories: task.categories };
  return acc;
}, {});

/**
 * If filtering by a specific eval name (task), ensure that this task actually exists.
 */
if (filterByEvalName && !tasksByName[filterByEvalName]) {
  console.error(`Error: Evaluation "${filterByEvalName}" does not exist.`);
  process.exit(1);
}

/**
 * Determine which models to run the evaluations against.
 *
 * DEFAULT_EVAL_MODELS: The default set of models used for most categories.
 * EXPERIMENTAL_EVAL_MODELS: Additional models included if the category is "experimental".
 */
const DEFAULT_EVAL_MODELS = process.env.EVAL_MODELS
  ? process.env.EVAL_MODELS.split(",")
  : ["gpt-4o", "claude-3-5-sonnet-latest"];

/**
 * getModelList:
 * Returns a list of models to be used for the given category.
 * If category is "experimental", it merges DEFAULT_EVAL_MODELS and EXPERIMENTAL_EVAL_MODELS.
 * Otherwise, returns DEFAULT_EVAL_MODELS.
 */
const getModelList = (): string[] => {
  return DEFAULT_EVAL_MODELS;
};
const MODELS: AvailableModel[] = getModelList().map((model) => {
  if (!AvailableModelSchema.safeParse(model).success) {
    throw new Error(`Model ${model} is not a supported model`);
  }
  return model as AvailableModel;
});

export { tasksByName, MODELS, config };

================
File: evals/utils.ts
================
/**
 * This file provides utility functions and classes to assist with evaluation tasks.
 *
 * Key functionalities:
 * - String normalization and fuzzy comparison utility functions to compare output strings
 *   against expected results in a flexible and robust way.
 * - Generation of unique experiment names based on the current timestamp, environment,
 *   and eval name or category.
 */

import stringComparison from "string-comparison";
const { jaroWinkler } = stringComparison;

/**
 * normalizeString:
 * Prepares a string for comparison by:
 * - Converting to lowercase
 * - Collapsing multiple spaces to a single space
 * - Removing punctuation and special characters that are not alphabetic or numeric
 * - Normalizing spacing around commas
 * - Trimming leading and trailing whitespace
 *
 * This helps create a stable string representation to compare against expected outputs,
 * even if the actual output contains minor formatting differences.
 */
export function normalizeString(str: string): string {
  return str
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/[;/#!$%^&*:{}=\-_`~()]/g, "")
    .replace(/\s*,\s*/g, ", ")
    .trim();
}

/**
 * compareStrings:
 * Compares two strings (actual vs. expected) using a similarity metric (Jaro-Winkler).
 *
 * Arguments:
 * - actual: The actual output string to be checked.
 * - expected: The expected string we want to match against.
 * - similarityThreshold: A number between 0 and 1. Default is 0.85.
 *   If the computed similarity is greater than or equal to this threshold,
 *   we consider the strings sufficiently similar.
 *
 * Returns:
 * - similarity: A number indicating how similar the two strings are.
 * - meetsThreshold: A boolean indicating if the similarity meets or exceeds the threshold.
 *
 * This function is useful for tasks where exact string matching is too strict,
 * allowing for fuzzy matching that tolerates minor differences in formatting or spelling.
 */
export function compareStrings(
  actual: string,
  expected: string,
  similarityThreshold: number = 0.85,
): { similarity: number; meetsThreshold: boolean } {
  const similarity = jaroWinkler.similarity(
    normalizeString(actual),
    normalizeString(expected),
  );
  return {
    similarity,
    meetsThreshold: similarity >= similarityThreshold,
  };
}

/**
 * generateTimestamp:
 * Generates a timestamp string formatted as "YYYYMMDDHHMMSS".
 * Used to create unique experiment names, ensuring that results can be
 * distinguished by the time they were generated.
 */
export function generateTimestamp(): string {
  const now = new Date();
  return now
    .toISOString()
    .replace(/[-:TZ]/g, "")
    .slice(0, 14);
}

/**
 * generateExperimentName:
 * Creates a unique name for the experiment based on optional evalName or category,
 * the environment (e.g., dev or CI), and the current timestamp.
 * This is used to label the output files and directories.
 */
export function generateExperimentName({
  evalName,
  category,
  environment,
}: {
  evalName?: string;
  category?: string;
  environment: string;
}): string {
  const timestamp = generateTimestamp();
  if (evalName) {
    return `${evalName}_${environment.toLowerCase()}_${timestamp}`;
  }
  if (category) {
    return `${category}_${environment.toLowerCase()}_${timestamp}`;
  }
  return `all_${environment.toLowerCase()}_${timestamp}`;
}

================
File: examples/2048.ts
================
import { Stagehand } from "../lib";
import { z } from "zod";
async function example() {
  console.log("🎮 Starting 2048 bot...");
  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1,
    debugDom: true,
    domSettleTimeoutMs: 100,
  });
  try {
    console.log("🌟 Initializing Stagehand...");
    await stagehand.init();
    console.log("🌐 Navigating to 2048...");
    await stagehand.page.goto("https://ovolve.github.io/2048-AI/");
    console.log("⌛ Waiting for game to initialize...");
    await stagehand.page.waitForSelector(".grid-container", { timeout: 10000 });
    // Main game loop
    while (true) {
      console.log("🔄 Game loop iteration...");
      // Add a small delay for UI updates
      await new Promise((resolve) => setTimeout(resolve, 300));
      // Get current game state
      const gameState = await stagehand.page.extract({
        instruction: `Extract the current game state:
          1. Score from the score counter
          2. All tile values in the 4x4 grid (empty spaces as 0)
          3. Highest tile value present`,
        schema: z.object({
          score: z.number(),
          highestTile: z.number(),
          grid: z.array(z.array(z.number())),
        }),
      });
      const transposedGrid = gameState.grid[0].map((_, colIndex) =>
        gameState.grid.map((row) => row[colIndex]),
      );
      const grid = transposedGrid.map((row, rowIndex) => ({
        [`row${rowIndex + 1}`]: row,
      }));
      console.log("Game State:", {
        score: gameState.score,
        highestTile: gameState.highestTile,
        grid: grid,
      });
      // Analyze board and decide next move
      const analysis = await stagehand.page.extract({
        instruction: `Based on the current game state:
          - Score: ${gameState.score}
          - Highest tile: ${gameState.highestTile}
          - Grid: This is a 4x4 matrix ordered by row (top to bottom) and column (left to right). The rows are stacked vertically, and tiles can move vertically between rows or horizontally between columns:\n${grid
            .map((row) => {
              const rowName = Object.keys(row)[0];
              return `             ${rowName}: ${row[rowName].join(", ")}`;
            })
            .join("\n")}
          What is the best move (up/down/left/right)? Consider:
          1. Keeping high value tiles in corners (bottom left, bottom right, top left, top right)
          2. Maintaining a clear path to merge tiles
          3. Avoiding moves that could block merges
          4. Only adjacent tiles of the same value can merge
          5. Making a move will move all tiles in that direction until they hit a tile of a different value or the edge of the board
          6. Tiles cannot move past the edge of the board
          7. Each move must move at least one tile`,
        schema: z.object({
          move: z.enum(["up", "down", "left", "right"]),
          confidence: z.number(),
          reasoning: z.string(),
        }),
      });
      console.log("Move Analysis:", analysis);
      const moveKey = {
        up: "ArrowUp",
        down: "ArrowDown",
        left: "ArrowLeft",
        right: "ArrowRight",
      }[analysis.move];
      await stagehand.page.keyboard.press(moveKey);
      console.log("🎯 Executed move:", analysis.move);
    }
  } catch (error) {
    console.error("❌ Error in game loop:", error);
    const isGameOver = await stagehand.page.evaluate(() => {
      return document.querySelector(".game-over") !== null;
    });
    if (isGameOver) {
      console.log("🏁 Game Over!");
      return;
    }
    throw error; // Re-throw non-game-over errors
  }
}
(async () => {
  await example();
})();

================
File: examples/debugUrl.ts
================
import { Stagehand } from "../lib";

async function debug(url: string) {
  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 2,
    debugDom: true,
  });
  await stagehand.init();
  await stagehand.page.goto(url);
}

(async () => {
  const url = process.argv.find((arg) => arg.startsWith("--url="));
  if (!url) {
    console.error("No URL flag provided. Usage: --url=https://example.com");
    process.exit(1);
  }
  const targetUrl = url.split("=")[1];
  console.log(`Navigating to: ${targetUrl}`);
  await debug(targetUrl);
})();

================
File: examples/example.ts
================
/**
 * This file is meant to be used as a scratchpad for developing new evals.
 * To create a Stagehand project with best practices and configuration, run:
 *
 * npx create-browser-app@latest my-browser-app
 */

import { Stagehand } from "../lib";
import StagehandConfig from "./stagehand.config";

async function example() {
  const stagehand = new Stagehand(StagehandConfig);
  await stagehand.init();
}

(async () => {
  await example();
})();

================
File: examples/parameterizeApiKey.ts
================
import { Stagehand } from "../lib";
import { z } from "zod";

/**
 * This example shows how to parameterize the API key for the LLM provider.
 *
 * In order to best demonstrate, unset the OPENAI_API_KEY environment variable and
 * set the USE_OPENAI_API_KEY environment variable to your OpenAI API key.
 *
 * export USE_OPENAI_API_KEY=$OPENAI_API_KEY
 * unset OPENAI_API_KEY
 */

async function example() {
  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1,
    debugDom: true,
    enableCaching: false,
    modelName: "gpt-4o",
    modelClientOptions: {
      apiKey: process.env.USE_OPENAI_API_KEY,
    },
  });

  await stagehand.init();
  await stagehand.page.goto("https://github.com/browserbase/stagehand");
  await stagehand.page.act({ action: "click on the contributors" });
  const contributor = await stagehand.page.extract({
    instruction: "extract the top contributor",
    schema: z.object({
      username: z.string(),
      url: z.string(),
    }),
  });
  console.log(`Our favorite contributor is ${contributor.username}`);
}

(async () => {
  await example();
})();

================
File: examples/stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "../lib";

const StagehandConfig: ConstructorParams = {
  env: "BROWSERBASE" /* Environment to run Stagehand in */,
  apiKey: process.env.BROWSERBASE_API_KEY /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID /* Project identifier */,
  verbose: 1 /* Logging verbosity level (0=quiet, 1=normal, 2=verbose) */,
  debugDom: true /* Enable DOM debugging features */,
  headless: false /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(
      `[stagehand::${message.category}] ${message.message}`,
    ) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
  modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};
export default StagehandConfig;

================
File: lib/cache/ActionCache.ts
================
import { LogLine } from "../../types/log";
import { BaseCache, CacheEntry } from "./BaseCache";

export interface PlaywrightCommand {
  method: string;
  args: string[];
}

export interface ActionEntry extends CacheEntry {
  data: {
    playwrightCommand: PlaywrightCommand;
    componentString: string;
    xpaths: string[];
    newStepString: string;
    completed: boolean;
    previousSelectors: string[];
    action: string;
  };
}

/**
 * ActionCache handles logging and retrieving actions along with their Playwright commands.
 */
export class ActionCache extends BaseCache<ActionEntry> {
  constructor(
    logger: (message: LogLine) => void,
    cacheDir?: string,
    cacheFile?: string,
  ) {
    super(logger, cacheDir, cacheFile || "action_cache.json");
  }

  public async addActionStep({
    url,
    action,
    previousSelectors,
    playwrightCommand,
    componentString,
    xpaths,
    newStepString,
    completed,
    requestId,
  }: {
    url: string;
    action: string;
    previousSelectors: string[];
    playwrightCommand: PlaywrightCommand;
    componentString: string;
    requestId: string;
    xpaths: string[];
    newStepString: string;
    completed: boolean;
  }): Promise<void> {
    this.logger({
      category: "action_cache",
      message: "adding action step to cache",
      level: 1,
      auxiliary: {
        action: {
          value: action,
          type: "string",
        },
        requestId: {
          value: requestId,
          type: "string",
        },
        url: {
          value: url,
          type: "string",
        },
        previousSelectors: {
          value: JSON.stringify(previousSelectors),
          type: "object",
        },
      },
    });

    await this.set(
      { url, action, previousSelectors },
      {
        playwrightCommand,
        componentString,
        xpaths,
        newStepString,
        completed,
        previousSelectors,
        action,
      },
      requestId,
    );
  }

  /**
   * Retrieves all actions for a specific trajectory.
   * @param trajectoryId - Unique identifier for the trajectory.
   * @param requestId - The identifier for the current request.
   * @returns An array of TrajectoryEntry objects or null if not found.
   */
  public async getActionStep({
    url,
    action,
    previousSelectors,
    requestId,
  }: {
    url: string;
    action: string;
    previousSelectors: string[];
    requestId: string;
  }): Promise<ActionEntry["data"] | null> {
    const data = await super.get({ url, action, previousSelectors }, requestId);
    if (!data) {
      return null;
    }

    return data;
  }

  public async removeActionStep(cacheHashObj: {
    url: string;
    action: string;
    previousSelectors: string[];
    requestId: string;
  }): Promise<void> {
    await super.delete(cacheHashObj);
  }

  /**
   * Clears all actions for a specific trajectory.
   * @param trajectoryId - Unique identifier for the trajectory.
   * @param requestId - The identifier for the current request.
   */
  public async clearAction(requestId: string): Promise<void> {
    await super.deleteCacheForRequestId(requestId);
    this.logger({
      category: "action_cache",
      message: "cleared action for ID",
      level: 1,
      auxiliary: {
        requestId: {
          value: requestId,
          type: "string",
        },
      },
    });
  }

  /**
   * Resets the entire action cache.
   */
  public async resetCache(): Promise<void> {
    await super.resetCache();
    this.logger({
      category: "action_cache",
      message: "Action cache has been reset.",
      level: 1,
    });
  }
}

================
File: lib/cache/BaseCache.ts
================
import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";
import { LogLine } from "../../types/log";

export interface CacheEntry {
  timestamp: number;
  data: unknown;
  requestId: string;
}

export interface CacheStore {
  [key: string]: CacheEntry;
}

export class BaseCache<T extends CacheEntry> {
  private readonly CACHE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 1 week in milliseconds
  private readonly CLEANUP_PROBABILITY = 0.01; // 1% chance

  protected cacheDir: string;
  protected cacheFile: string;
  protected lockFile: string;
  protected logger: (message: LogLine) => void;

  private readonly LOCK_TIMEOUT_MS = 1_000;
  protected lockAcquired = false;
  protected lockAcquireFailures = 0;

  // Added for request ID tracking
  protected requestIdToUsedHashes: { [key: string]: string[] } = {};

  constructor(
    logger: (message: LogLine) => void,
    cacheDir: string = path.join(process.cwd(), "tmp", ".cache"),
    cacheFile: string = "cache.json",
  ) {
    this.logger = logger;
    this.cacheDir = cacheDir;
    this.cacheFile = path.join(cacheDir, cacheFile);
    this.lockFile = path.join(cacheDir, "cache.lock");
    this.ensureCacheDirectory();
    this.setupProcessHandlers();
  }

  private setupProcessHandlers(): void {
    const releaseLockAndExit = () => {
      this.releaseLock();
      process.exit();
    };

    process.on("exit", releaseLockAndExit);
    process.on("SIGINT", releaseLockAndExit);
    process.on("SIGTERM", releaseLockAndExit);
    process.on("uncaughtException", (err) => {
      this.logger({
        category: "base_cache",
        message: "uncaught exception",
        level: 2,
        auxiliary: {
          error: {
            value: err.message,
            type: "string",
          },
          trace: {
            value: err.stack,
            type: "string",
          },
        },
      });
      if (this.lockAcquired) {
        releaseLockAndExit();
      }
    });
  }

  protected ensureCacheDirectory(): void {
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir, { recursive: true });
      this.logger({
        category: "base_cache",
        message: "created cache directory",
        level: 1,
        auxiliary: {
          cacheDir: {
            value: this.cacheDir,
            type: "string",
          },
        },
      });
    }
  }

  protected createHash(data: unknown): string {
    const hash = crypto.createHash("sha256");
    return hash.update(JSON.stringify(data)).digest("hex");
  }

  protected sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  public async acquireLock(): Promise<boolean> {
    const startTime = Date.now();
    while (Date.now() - startTime < this.LOCK_TIMEOUT_MS) {
      try {
        if (fs.existsSync(this.lockFile)) {
          const lockAge = Date.now() - fs.statSync(this.lockFile).mtimeMs;
          if (lockAge > this.LOCK_TIMEOUT_MS) {
            fs.unlinkSync(this.lockFile);
            this.logger({
              category: "base_cache",
              message: "Stale lock file removed",
              level: 1,
            });
          }
        }

        fs.writeFileSync(this.lockFile, process.pid.toString(), { flag: "wx" });
        this.lockAcquireFailures = 0;
        this.lockAcquired = true;
        this.logger({
          category: "base_cache",
          message: "Lock acquired",
          level: 1,
        });
        return true;
      } catch (e) {
        this.logger({
          category: "base_cache",
          message: "error acquiring lock",
          level: 2,
          auxiliary: {
            trace: {
              value: e.stack,
              type: "string",
            },
            message: {
              value: e.message,
              type: "string",
            },
          },
        });
        await this.sleep(5);
      }
    }
    this.logger({
      category: "base_cache",
      message: "Failed to acquire lock after timeout",
      level: 2,
    });
    this.lockAcquireFailures++;
    if (this.lockAcquireFailures >= 3) {
      this.logger({
        category: "base_cache",
        message:
          "Failed to acquire lock 3 times in a row. Releasing lock manually.",
        level: 1,
      });
      this.releaseLock();
    }
    return false;
  }

  public releaseLock(): void {
    try {
      if (fs.existsSync(this.lockFile)) {
        fs.unlinkSync(this.lockFile);
        this.logger({
          category: "base_cache",
          message: "Lock released",
          level: 1,
        });
      }
      this.lockAcquired = false;
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error releasing lock",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
    }
  }

  /**
   * Cleans up stale cache entries that exceed the maximum age.
   */
  public async cleanupStaleEntries(): Promise<void> {
    if (!(await this.acquireLock())) {
      this.logger({
        category: "llm_cache",
        message: "failed to acquire lock for cleanup",
        level: 2,
      });
      return;
    }

    try {
      const cache = this.readCache();
      const now = Date.now();
      let entriesRemoved = 0;

      for (const [hash, entry] of Object.entries(cache)) {
        if (now - entry.timestamp > this.CACHE_MAX_AGE_MS) {
          delete cache[hash];
          entriesRemoved++;
        }
      }

      if (entriesRemoved > 0) {
        this.writeCache(cache);
        this.logger({
          category: "llm_cache",
          message: "cleaned up stale cache entries",
          level: 1,
          auxiliary: {
            entriesRemoved: {
              value: entriesRemoved.toString(),
              type: "integer",
            },
          },
        });
      }
    } catch (error) {
      this.logger({
        category: "llm_cache",
        message: "error during cache cleanup",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
    } finally {
      this.releaseLock();
    }
  }

  protected readCache(): CacheStore {
    if (fs.existsSync(this.cacheFile)) {
      try {
        const data = fs.readFileSync(this.cacheFile, "utf-8");
        return JSON.parse(data) as CacheStore;
      } catch (error) {
        this.logger({
          category: "base_cache",
          message: "error reading cache file. resetting cache.",
          level: 1,
          auxiliary: {
            error: {
              value: error.message,
              type: "string",
            },
            trace: {
              value: error.stack,
              type: "string",
            },
          },
        });
        this.resetCache();
        return {};
      }
    }
    return {};
  }

  protected writeCache(cache: CacheStore): void {
    try {
      fs.writeFileSync(this.cacheFile, JSON.stringify(cache, null, 2));
      this.logger({
        category: "base_cache",
        message: "Cache written to file",
        level: 1,
      });
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error writing cache file",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
    } finally {
      this.releaseLock();
    }
  }

  /**
   * Retrieves data from the cache based on the provided options.
   * @param hashObj - The options used to generate the cache key.
   * @param requestId - The identifier for the current request.
   * @returns The cached data if available, otherwise null.
   */
  public async get(
    hashObj: Record<string, unknown> | string,
    requestId: string,
  ): Promise<T["data"] | null> {
    if (!(await this.acquireLock())) {
      this.logger({
        category: "base_cache",
        message: "Failed to acquire lock for getting cache",
        level: 2,
      });
      return null;
    }

    try {
      const hash = this.createHash(hashObj);
      const cache = this.readCache();

      if (cache[hash]) {
        this.trackRequestIdUsage(requestId, hash);
        return cache[hash].data;
      }
      return null;
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error getting cache. resetting cache.",
        level: 1,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });

      this.resetCache();
      return null;
    } finally {
      this.releaseLock();
    }
  }

  /**
   * Stores data in the cache based on the provided options and requestId.
   * @param hashObj - The options used to generate the cache key.
   * @param data - The data to be cached.
   * @param requestId - The identifier for the cache entry.
   */
  public async set(
    hashObj: Record<string, unknown>,
    data: T["data"],
    requestId: string,
  ): Promise<void> {
    if (!(await this.acquireLock())) {
      this.logger({
        category: "base_cache",
        message: "Failed to acquire lock for setting cache",
        level: 2,
      });
      return;
    }

    try {
      const hash = this.createHash(hashObj);
      const cache = this.readCache();
      cache[hash] = {
        data,
        timestamp: Date.now(),
        requestId,
      };

      this.writeCache(cache);
      this.trackRequestIdUsage(requestId, hash);
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error setting cache. resetting cache.",
        level: 1,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });

      this.resetCache();
    } finally {
      this.releaseLock();

      if (Math.random() < this.CLEANUP_PROBABILITY) {
        this.cleanupStaleEntries();
      }
    }
  }

  public async delete(hashObj: Record<string, unknown>): Promise<void> {
    if (!(await this.acquireLock())) {
      this.logger({
        category: "base_cache",
        message: "Failed to acquire lock for removing cache entry",
        level: 2,
      });
      return;
    }

    try {
      const hash = this.createHash(hashObj);
      const cache = this.readCache();

      if (cache[hash]) {
        delete cache[hash];
        this.writeCache(cache);
      } else {
        this.logger({
          category: "base_cache",
          message: "Cache entry not found to delete",
          level: 1,
        });
      }
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error removing cache entry",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
    } finally {
      this.releaseLock();
    }
  }

  /**
   * Tracks the usage of a hash with a specific requestId.
   * @param requestId - The identifier for the current request.
   * @param hash - The cache key hash.
   */
  protected trackRequestIdUsage(requestId: string, hash: string): void {
    this.requestIdToUsedHashes[requestId] ??= [];
    this.requestIdToUsedHashes[requestId].push(hash);
  }

  /**
   * Deletes all cache entries associated with a specific requestId.
   * @param requestId - The identifier for the request whose cache entries should be deleted.
   */
  public async deleteCacheForRequestId(requestId: string): Promise<void> {
    if (!(await this.acquireLock())) {
      this.logger({
        category: "base_cache",
        message: "Failed to acquire lock for deleting cache",
        level: 2,
      });
      return;
    }
    try {
      const cache = this.readCache();
      const hashes = this.requestIdToUsedHashes[requestId] ?? [];
      let entriesRemoved = 0;
      for (const hash of hashes) {
        if (cache[hash]) {
          delete cache[hash];
          entriesRemoved++;
        }
      }
      if (entriesRemoved > 0) {
        this.writeCache(cache);
      } else {
        this.logger({
          category: "base_cache",
          message: "no cache entries found for requestId",
          level: 1,
          auxiliary: {
            requestId: {
              value: requestId,
              type: "string",
            },
          },
        });
      }
      // Remove the requestId from the mapping after deletion
      delete this.requestIdToUsedHashes[requestId];
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error deleting cache for requestId",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
          requestId: {
            value: requestId,
            type: "string",
          },
        },
      });
    } finally {
      this.releaseLock();
    }
  }

  /**
   * Resets the entire cache by clearing the cache file.
   */
  public resetCache(): void {
    try {
      fs.writeFileSync(this.cacheFile, "{}");
      this.requestIdToUsedHashes = {}; // Reset requestId tracking
    } catch (error) {
      this.logger({
        category: "base_cache",
        message: "error resetting cache",
        level: 2,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
    } finally {
      this.releaseLock();
    }
  }
}

================
File: lib/cache/LLMCache.ts
================
import { BaseCache, CacheEntry } from "./BaseCache";

export class LLMCache extends BaseCache<CacheEntry> {
  constructor(
    logger: (message: {
      category?: string;
      message: string;
      level?: number;
    }) => void,
    cacheDir?: string,
    cacheFile?: string,
  ) {
    super(logger, cacheDir, cacheFile || "llm_calls.json");
  }

  /**
   * Overrides the get method to track used hashes by requestId.
   * @param options - The options used to generate the cache key.
   * @param requestId - The identifier for the current request.
   * @returns The cached data if available, otherwise null.
   */
  public async get<T>(
    options: Record<string, unknown>,
    requestId: string,
  ): Promise<T | null> {
    const data = await super.get(options, requestId);
    return data as T | null; // TODO: remove this cast
  }

  /**
   * Overrides the set method to include cache cleanup logic.
   * @param options - The options used to generate the cache key.
   * @param data - The data to be cached.
   * @param requestId - The identifier for the current request.
   */
  public async set(
    options: Record<string, unknown>,
    data: unknown,
    requestId: string,
  ): Promise<void> {
    await super.set(options, data, requestId);
    this.logger({
      category: "llm_cache",
      message: "Cache miss - saved new response",
      level: 1,
    });
  }
}

================
File: lib/dom/debug.ts
================
import { calculateViewportHeight } from "./utils";

export async function debugDom() {
  window.chunkNumber = 0;

  const { selectorMap: multiSelectorMap } = await window.processElements(
    window.chunkNumber,
  );

  const selectorMap = multiSelectorMapToSelectorMap(multiSelectorMap);

  drawChunk(selectorMap);
  setupChunkNav();
}

function multiSelectorMapToSelectorMap(
  multiSelectorMap: Record<number, string[]>,
) {
  return Object.fromEntries(
    Object.entries(multiSelectorMap).map(([key, selectors]) => [
      Number(key),
      selectors[0],
    ]),
  );
}

function drawChunk(selectorMap: Record<number, string>) {
  if (!window.showChunks) return;
  cleanupMarkers();
  Object.values(selectorMap).forEach((selector) => {
    const element = document.evaluate(
      selector as string,
      document,
      null,
      XPathResult.FIRST_ORDERED_NODE_TYPE,
      null,
    ).singleNodeValue as Element;

    if (element) {
      let rect;
      if (element.nodeType === Node.ELEMENT_NODE) {
        rect = element.getBoundingClientRect();
      } else {
        const range = document.createRange();
        range.selectNodeContents(element);
        rect = range.getBoundingClientRect();
      }
      const color = "grey";
      const overlay = document.createElement("div");
      overlay.style.position = "absolute";
      overlay.style.left = `${rect.left + window.scrollX}px`;
      overlay.style.top = `${rect.top + window.scrollY}px`;
      overlay.style.padding = "2px"; // Add 2px of padding to the overlay

      overlay.style.width = `${rect.width}px`;
      overlay.style.height = `${rect.height}px`;
      overlay.style.backgroundColor = color;
      overlay.className = "stagehand-marker";
      overlay.style.opacity = "0.3";
      overlay.style.zIndex = "1000000000"; // Ensure it's above the element
      overlay.style.border = "1px solid"; // Add a 1px solid border to the overlay
      overlay.style.pointerEvents = "none"; // Ensure the overlay does not capture mouse events
      document.body.appendChild(overlay);
    }
  });
}

async function cleanupDebug() {
  cleanupMarkers();
  cleanupNav();
}

function cleanupMarkers() {
  const markers = document.querySelectorAll(".stagehand-marker");
  markers.forEach((marker) => {
    marker.remove();
  });
}

function cleanupNav() {
  const stagehandNavElements = document.querySelectorAll(".stagehand-nav");
  stagehandNavElements.forEach((element) => {
    element.remove();
  });
}

function setupChunkNav() {
  const viewportHeight = calculateViewportHeight();
  const documentHeight = document.documentElement.scrollHeight;
  const totalChunks = Math.ceil(documentHeight / viewportHeight);

  if (window.chunkNumber > 0) {
    const prevChunkButton = document.createElement("button");
    prevChunkButton.className = "stagehand-nav";

    prevChunkButton.textContent = "Previous";
    prevChunkButton.style.marginLeft = "50px";
    prevChunkButton.style.position = "fixed";
    prevChunkButton.style.bottom = "10px";
    prevChunkButton.style.left = "50%";
    prevChunkButton.style.transform = "translateX(-50%)";
    prevChunkButton.style.zIndex = "1000000000";
    prevChunkButton.onclick = async () => {
      cleanupMarkers();
      cleanupNav();
      window.chunkNumber -= 1;
      window.scrollTo(0, window.chunkNumber * viewportHeight);
      await window.waitForDomSettle();
      const { selectorMap: multiSelectorMap } = await window.processElements(
        window.chunkNumber,
      );

      const selectorMap = multiSelectorMapToSelectorMap(multiSelectorMap);

      drawChunk(selectorMap);
      setupChunkNav();
    };
    document.body.appendChild(prevChunkButton);
  }
  if (totalChunks > window.chunkNumber) {
    const nextChunkButton = document.createElement("button");
    nextChunkButton.className = "stagehand-nav";
    nextChunkButton.textContent = "Next";
    nextChunkButton.style.marginRight = "50px";
    nextChunkButton.style.position = "fixed";
    nextChunkButton.style.bottom = "10px";
    nextChunkButton.style.right = "50%";
    nextChunkButton.style.transform = "translateX(50%)";
    nextChunkButton.style.zIndex = "1000000000";
    nextChunkButton.onclick = async () => {
      cleanupMarkers();
      cleanupNav();
      window.chunkNumber += 1;
      window.scrollTo(0, window.chunkNumber * viewportHeight);
      await window.waitForDomSettle();

      const { selectorMap: multiSelectorMap } = await window.processElements(
        window.chunkNumber,
      );
      const selectorMap = multiSelectorMapToSelectorMap(multiSelectorMap);
      drawChunk(selectorMap);
      setupChunkNav();
    };

    document.body.appendChild(nextChunkButton);
  }
}

window.debugDom = debugDom;
window.cleanupDebug = cleanupDebug;

================
File: lib/dom/genDomScripts.ts
================
/**
 * We have a collection of typescript functions that we need to run in the browser.
 * First, we build them into a single js file
 * Second, due to framework differences we need to get our script content as a string to avoid pathing issues due to file routing in frameworks like Next.js
 * Playwright allows us to pass in script content directly as a string instead of reading a file from a path
 * https://github.com/browserbase/stagehand/issues/180
 *
 * We can't rely on the normal build process for stagehand, because we need our script content as a string so that the import *just works*
 */
import fs from "fs";
import path from "path";
import esbuild from "esbuild";

fs.mkdirSync(path.join(__dirname, "./build"), { recursive: true });

esbuild.buildSync({
  entryPoints: [path.join(__dirname, "index.ts")],
  bundle: true,
  outdir: path.join(__dirname, "build"),
});

const scriptContent = fs.readFileSync(
  path.join(__dirname, "./build/index.js"),
  "utf8",
);

const output = `export const scriptContent = ${JSON.stringify(scriptContent)};`;

fs.writeFileSync(path.join(__dirname, "./build/scriptContent.ts"), output);

================
File: lib/dom/global.d.ts
================
export {};
declare global {
  interface Window {
    chunkNumber: number;
    showChunks?: boolean;
    processDom: (chunksSeen: Array<number>) => Promise<{
      outputString: string;
      selectorMap: Record<number, string[]>;
      chunk: number;
      chunks: number[];
    }>;
    processAllOfDom: () => Promise<{
      outputString: string;
      selectorMap: Record<number, string[]>;
    }>;
    processElements: (chunk: number) => Promise<{
      outputString: string;
      selectorMap: Record<number, string[]>;
    }>;
    debugDom: () => Promise<void>;
    cleanupDebug: () => void;
    scrollToHeight: (height: number) => Promise<void>;
    waitForDomSettle: () => Promise<void>;
    __playwright?: unknown;
    __pw_manual?: unknown;
    __PW_inspect?: unknown;
    storeDOM: () => string;
    restoreDOM: (storedDOM: string) => void;
    createTextBoundingBoxes: () => void;
    getElementBoundingBoxes: (xpath: string) => Array<{
      text: string;
      top: number;
      left: number;
      width: number;
      height: number;
    }>;
  }
}

================
File: lib/dom/index.ts
================
export * from "./process";
export * from "./utils";
export * from "./debug";

================
File: lib/dom/process.ts
================
import { generateXPathsForElement as generateXPaths } from "./xpathUtils";
import { calculateViewportHeight } from "./utils";

export function isElementNode(node: Node): node is Element {
  return node.nodeType === Node.ELEMENT_NODE;
}

export function isTextNode(node: Node): node is Text {
  return node.nodeType === Node.TEXT_NODE && Boolean(node.textContent?.trim());
}

export async function processDom(chunksSeen: Array<number>) {
  const { chunk, chunksArray } = await pickChunk(chunksSeen);
  const { outputString, selectorMap } = await processElements(chunk);

  console.log(
    `Stagehand (Browser Process): Extracted dom elements:\n${outputString}`,
  );

  return {
    outputString,
    selectorMap,
    chunk,
    chunks: chunksArray,
  };
}

export async function processAllOfDom() {
  console.log("Stagehand (Browser Process): Processing all of DOM");

  const viewportHeight = calculateViewportHeight();
  const documentHeight = document.documentElement.scrollHeight;
  const totalChunks = Math.ceil(documentHeight / viewportHeight);

  let index = 0;
  const results = [];
  for (let chunk = 0; chunk < totalChunks; chunk++) {
    const result = await processElements(chunk, true, index);
    results.push(result);
    index += Object.keys(result.selectorMap).length;
  }

  await scrollToHeight(0);

  const allOutputString = results.map((result) => result.outputString).join("");
  const allSelectorMap = results.reduce(
    (acc, result) => ({ ...acc, ...result.selectorMap }),
    {},
  );

  console.log(
    `Stagehand (Browser Process): All dom elements: ${allOutputString}`,
  );

  return {
    outputString: allOutputString,
    selectorMap: allSelectorMap,
  };
}

export async function scrollToHeight(height: number) {
  window.scrollTo({ top: height, left: 0, behavior: "smooth" });

  // Wait for scrolling to finish using the scrollend event
  await new Promise<void>((resolve) => {
    let scrollEndTimer: number;
    const handleScrollEnd = () => {
      clearTimeout(scrollEndTimer);
      scrollEndTimer = window.setTimeout(() => {
        window.removeEventListener("scroll", handleScrollEnd);
        resolve();
      }, 100);
    };

    window.addEventListener("scroll", handleScrollEnd, { passive: true });
    handleScrollEnd();
  });
}

const xpathCache: Map<Node, string[]> = new Map();

export async function processElements(
  chunk: number,
  scrollToChunk: boolean = true,
  indexOffset: number = 0,
): Promise<{
  outputString: string;
  selectorMap: Record<number, string[]>;
}> {
  console.time("processElements:total");
  const viewportHeight = calculateViewportHeight();
  const chunkHeight = viewportHeight * chunk;

  // Calculate the maximum scrollable offset
  const maxScrollTop = document.documentElement.scrollHeight - viewportHeight;

  // Adjust the offsetTop to not exceed the maximum scrollable offset
  const offsetTop = Math.min(chunkHeight, maxScrollTop);

  if (scrollToChunk) {
    console.time("processElements:scroll");
    await scrollToHeight(offsetTop);
    console.timeEnd("processElements:scroll");
  }

  const candidateElements: Array<ChildNode> = [];
  const DOMQueue: Array<ChildNode> = [...document.body.childNodes];

  console.log("Stagehand (Browser Process): Generating candidate elements");
  console.time("processElements:findCandidates");

  while (DOMQueue.length > 0) {
    const element = DOMQueue.pop();

    let shouldAddElement = false;

    if (element && isElementNode(element)) {
      const childrenCount = element.childNodes.length;

      // Always traverse child nodes
      for (let i = childrenCount - 1; i >= 0; i--) {
        const child = element.childNodes[i];
        DOMQueue.push(child as ChildNode);
      }

      // Check if element is interactive
      if (isInteractiveElement(element)) {
        if (isActive(element) && isVisible(element)) {
          shouldAddElement = true;
        }
      }

      if (isLeafElement(element)) {
        if (isActive(element) && isVisible(element)) {
          shouldAddElement = true;
        }
      }
    }

    if (element && isTextNode(element) && isTextVisible(element)) {
      shouldAddElement = true;
    }

    if (shouldAddElement) {
      candidateElements.push(element);
    }
  }

  console.timeEnd("processElements:findCandidates");

  const selectorMap: Record<number, string[]> = {};
  let outputString = "";

  console.log(
    `Stagehand (Browser Process): Processing candidate elements: ${candidateElements.length}`,
  );

  console.time("processElements:processCandidates");
  console.time("processElements:generateXPaths");
  const xpathLists = await Promise.all(
    candidateElements.map(async (element) => {
      if (xpathCache.has(element)) {
        return xpathCache.get(element);
      }

      const xpaths = await generateXPaths(element);
      xpathCache.set(element, xpaths);
      return xpaths;
    }),
  );
  console.timeEnd("processElements:generateXPaths");

  candidateElements.forEach((element, index) => {
    const xpaths = xpathLists[index];
    let elementOutput = "";

    if (isTextNode(element)) {
      const textContent = element.textContent?.trim();
      if (textContent) {
        elementOutput += `${index + indexOffset}:${textContent}\n`;
      }
    } else if (isElementNode(element)) {
      const tagName = element.tagName.toLowerCase();
      const attributes = collectEssentialAttributes(element);

      const openingTag = `<${tagName}${attributes ? " " + attributes : ""}>`;
      const closingTag = `</${tagName}>`;
      const textContent = element.textContent?.trim() || "";

      elementOutput += `${index + indexOffset}:${openingTag}${textContent}${closingTag}\n`;
    }

    outputString += elementOutput;
    selectorMap[index + indexOffset] = xpaths;
  });
  console.timeEnd("processElements:processCandidates");

  console.timeEnd("processElements:total");
  return {
    outputString,
    selectorMap,
  };
}

/**
 * Collects essential attributes from an element.
 * @param element The DOM element.
 * @returns A string of formatted attributes.
 */
function collectEssentialAttributes(element: Element): string {
  const essentialAttributes = [
    "id",
    "class",
    "href",
    "src",
    "aria-label",
    "aria-name",
    "aria-role",
    "aria-description",
    "aria-expanded",
    "aria-haspopup",
    "type",
    "value",
  ];

  const attrs: string[] = essentialAttributes
    .map((attr) => {
      const value = element.getAttribute(attr);
      return value ? `${attr}="${value}"` : "";
    })
    .filter((attr) => attr !== "");

  // Collect data- attributes
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith("data-")) {
      attrs.push(`${attr.name}="${attr.value}"`);
    }
  });

  return attrs.join(" ");
}

export function storeDOM(): string {
  const originalDOM = document.body.cloneNode(true) as HTMLElement;
  console.log("DOM state stored.");
  return originalDOM.outerHTML;
}

export function restoreDOM(storedDOM: string): void {
  console.log("Restoring DOM");
  if (storedDOM) {
    document.body.innerHTML = storedDOM;
  } else {
    console.error("No DOM state was provided.");
  }
}

export function createTextBoundingBoxes(): void {
  const style = document.createElement("style");
  document.head.appendChild(style);
  if (style.sheet) {
    style.sheet.insertRule(
      `
      .stagehand-highlighted-word, .stagehand-space {
        border: 0px solid orange;
        display: inline-block !important;
        visibility: visible;
      }
    `,
      0,
    );

    style.sheet.insertRule(
      `
        code .stagehand-highlighted-word, code .stagehand-space,
        pre .stagehand-highlighted-word, pre .stagehand-space {
          white-space: pre-wrap;
          display: inline !important;
      }
     `,
      1,
    );
  }

  function applyHighlighting(root: Document | HTMLElement): void {
    root.querySelectorAll("body *").forEach((element) => {
      if (element.closest(".stagehand-nav, .stagehand-marker")) {
        return;
      }
      if (
        ["SCRIPT", "STYLE", "IFRAME", "INPUT", "TEXTAREA"].includes(
          element.tagName,
        )
      ) {
        return;
      }

      const childNodes = Array.from(element.childNodes);
      childNodes.forEach((node) => {
        if (node.nodeType === 3 && node.textContent?.trim().length > 0) {
          const textContent = node.textContent.replace(/\u00A0/g, " ");
          const tokens = textContent.split(/(\s+)/g); // Split text by spaces
          const fragment = document.createDocumentFragment();
          const parentIsCode = element.tagName === "CODE";

          tokens.forEach((token) => {
            const span = document.createElement("span");
            span.textContent = token;
            if (parentIsCode) {
              // Special handling for <code> tags
              span.style.whiteSpace = "pre-wrap";
              span.style.display = "inline";
            }
            span.className =
              token.trim().length === 0
                ? "stagehand-space"
                : "stagehand-highlighted-word";
            fragment.appendChild(span);
          });

          if (fragment.childNodes.length > 0 && node.parentNode) {
            element.insertBefore(fragment, node);
            node.remove();
          }
        }
      });
    });
  }

  applyHighlighting(document);

  document.querySelectorAll("iframe").forEach((iframe) => {
    try {
      iframe.contentWindow?.postMessage({ action: "highlight" }, "*");
    } catch (error) {
      console.error("Error accessing iframe content: ", error);
    }
  });
}

export function getElementBoundingBoxes(xpath: string): Array<{
  text: string;
  top: number;
  left: number;
  width: number;
  height: number;
}> {
  const element = document.evaluate(
    xpath,
    document,
    null,
    XPathResult.FIRST_ORDERED_NODE_TYPE,
    null,
  ).singleNodeValue as HTMLElement;

  if (!element) return [];

  const isValidText = (text: string) => text && text.trim().length > 0;
  let dropDownElem = element.querySelector("option[selected]");

  if (!dropDownElem) {
    dropDownElem = element.querySelector("option");
  }

  if (dropDownElem) {
    const elemText = dropDownElem.textContent || "";
    if (isValidText(elemText)) {
      const parentRect = element.getBoundingClientRect();
      return [
        {
          text: elemText.trim(),
          top: parentRect.top + window.scrollY,
          left: parentRect.left + window.scrollX,
          width: parentRect.width,
          height: parentRect.height,
        },
      ];
    } else {
      return [];
    }
  }

  let placeholderText = "";
  if (
    (element.tagName.toLowerCase() === "input" ||
      element.tagName.toLowerCase() === "textarea") &&
    (element as HTMLInputElement).placeholder
  ) {
    placeholderText = (element as HTMLInputElement).placeholder;
  } else if (element.tagName.toLowerCase() === "a") {
    placeholderText = "";
  } else if (element.tagName.toLowerCase() === "img") {
    placeholderText = (element as HTMLImageElement).alt || "";
  }

  const words = element.querySelectorAll(
    ".stagehand-highlighted-word",
  ) as NodeListOf<HTMLElement>;

  const boundingBoxes = Array.from(words)
    .map((word) => {
      const rect = word.getBoundingClientRect();
      return {
        text: word.innerText || "",
        top: rect.top + window.scrollY,
        left: rect.left + window.scrollX,
        width: rect.width,
        height: rect.height * 0.75,
      };
    })
    .filter(
      (box) =>
        box.width > 0 &&
        box.height > 0 &&
        box.top >= 0 &&
        box.left >= 0 &&
        isValidText(box.text),
    );

  if (boundingBoxes.length === 0) {
    const elementRect = element.getBoundingClientRect();
    return [
      {
        text: placeholderText,
        top: elementRect.top + window.scrollY,
        left: elementRect.left + window.scrollX,
        width: elementRect.width,
        height: elementRect.height * 0.75,
      },
    ];
  }

  return boundingBoxes;
}

window.processDom = processDom;
window.processAllOfDom = processAllOfDom;
window.processElements = processElements;
window.scrollToHeight = scrollToHeight;
window.storeDOM = storeDOM;
window.restoreDOM = restoreDOM;
window.createTextBoundingBoxes = createTextBoundingBoxes;
window.getElementBoundingBoxes = getElementBoundingBoxes;

const leafElementDenyList = ["SVG", "IFRAME", "SCRIPT", "STYLE", "LINK"];

const interactiveElementTypes = [
  "A",
  "BUTTON",
  "DETAILS",
  "EMBED",
  "INPUT",
  "LABEL",
  "MENU",
  "MENUITEM",
  "OBJECT",
  "SELECT",
  "TEXTAREA",
  "SUMMARY",
];

const interactiveRoles = [
  "button",
  "menu",
  "menuitem",
  "link",
  "checkbox",
  "radio",
  "slider",
  "tab",
  "tabpanel",
  "textbox",
  "combobox",
  "grid",
  "listbox",
  "option",
  "progressbar",
  "scrollbar",
  "searchbox",
  "switch",
  "tree",
  "treeitem",
  "spinbutton",
  "tooltip",
];
const interactiveAriaRoles = ["menu", "menuitem", "button"];

/*
 * Checks if an element is visible and therefore relevant for LLMs to consider. We check:
 * - Size
 * - Display properties
 * - Opacity
 * If the element is a child of a previously hidden element, it should not be included, so we don't consider downstream effects of a parent element here
 */
const isVisible = (element: Element) => {
  const rect = element.getBoundingClientRect();
  // Ensure the element is within the viewport
  if (
    rect.width === 0 ||
    rect.height === 0 ||
    rect.top < 0 ||
    rect.top > window.innerHeight
  ) {
    return false;
  }
  if (!isTopElement(element, rect)) {
    return false;
  }

  const visible = element.checkVisibility({
    checkOpacity: true,
    checkVisibilityCSS: true,
  });

  return visible;
};

const isTextVisible = (element: ChildNode) => {
  const range = document.createRange();
  range.selectNodeContents(element);
  const rect = range.getBoundingClientRect();

  if (
    rect.width === 0 ||
    rect.height === 0 ||
    rect.top < 0 ||
    rect.top > window.innerHeight
  ) {
    return false;
  }
  const parent = element.parentElement;
  if (!parent) {
    return false;
  }
  if (!isTopElement(parent, rect)) {
    return false;
  }

  const visible = parent.checkVisibility({
    checkOpacity: true,
    checkVisibilityCSS: true,
  });

  return visible;
};

function isTopElement(elem: ChildNode, rect: DOMRect) {
  const points = [
    { x: rect.left + rect.width * 0.25, y: rect.top + rect.height * 0.25 },
    { x: rect.left + rect.width * 0.75, y: rect.top + rect.height * 0.25 },
    { x: rect.left + rect.width * 0.25, y: rect.top + rect.height * 0.75 },
    { x: rect.left + rect.width * 0.75, y: rect.top + rect.height * 0.75 },
    { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 },
  ];

  return points.some((point) => {
    const topEl = document.elementFromPoint(point.x, point.y);
    let current = topEl;
    while (current && current !== document.body) {
      if (current.isSameNode(elem)) {
        return true;
      }
      current = current.parentElement;
    }
    return false;
  });
}

const isActive = (element: Element) => {
  if (
    element.hasAttribute("disabled") ||
    element.hasAttribute("hidden") ||
    element.getAttribute("aria-disabled") === "true"
  ) {
    return false;
  }

  return true;
};
const isInteractiveElement = (element: Element) => {
  const elementType = element.tagName;
  const elementRole = element.getAttribute("role");
  const elementAriaRole = element.getAttribute("aria-role");

  return (
    (elementType && interactiveElementTypes.includes(elementType)) ||
    (elementRole && interactiveRoles.includes(elementRole)) ||
    (elementAriaRole && interactiveAriaRoles.includes(elementAriaRole))
  );
};

const isLeafElement = (element: Element) => {
  if (element.textContent === "") {
    return false;
  }

  if (element.childNodes.length === 0) {
    return !leafElementDenyList.includes(element.tagName);
  }

  // This case ensures that extra context will be included for simple element nodes that contain only text
  if (element.childNodes.length === 1 && isTextNode(element.childNodes[0])) {
    return true;
  }

  return false;
};

async function pickChunk(chunksSeen: Array<number>) {
  const viewportHeight = calculateViewportHeight();
  const documentHeight = document.documentElement.scrollHeight;

  const chunks = Math.ceil(documentHeight / viewportHeight);

  const chunksArray = Array.from({ length: chunks }, (_, i) => i);
  const chunksRemaining = chunksArray.filter((chunk) => {
    return !chunksSeen.includes(chunk);
  });

  const currentScrollPosition = window.scrollY;
  const closestChunk = chunksRemaining.reduce((closest, current) => {
    const currentChunkTop = viewportHeight * current;
    const closestChunkTop = viewportHeight * closest;
    return Math.abs(currentScrollPosition - currentChunkTop) <
      Math.abs(currentScrollPosition - closestChunkTop)
      ? current
      : closest;
  }, chunksRemaining[0]);
  const chunk = closestChunk;

  if (chunk === undefined) {
    throw new Error(`No chunks remaining to check: ${chunksRemaining}`);
  }
  return {
    chunk,
    chunksArray,
  };
}

================
File: lib/dom/utils.ts
================
export async function waitForDomSettle() {
  return new Promise<void>((resolve) => {
    const createTimeout = () => {
      return setTimeout(() => {
        resolve();
      }, 2000);
    };
    let timeout = createTimeout();
    const observer = new MutationObserver(() => {
      clearTimeout(timeout);
      timeout = createTimeout();
    });
    observer.observe(window.document.body, { childList: true, subtree: true });
  });
}

window.waitForDomSettle = waitForDomSettle;

export function calculateViewportHeight() {
  return Math.ceil(window.innerHeight * 0.75);
}

================
File: lib/dom/xpathUtils.ts
================
import { isTextNode } from "./process";
import { isElementNode } from "./process";

function getParentElement(node: ChildNode): Element | null {
  return isElementNode(node)
    ? node.parentElement
    : (node.parentNode as Element);
}

/**
 * Generates all possible combinations of a given array of attributes.
 * @param attributes Array of attributes.
 * @param size The size of each combination.
 * @returns An array of attribute combinations.
 */
function getCombinations(
  attributes: { attr: string; value: string }[],
  size: number,
): { attr: string; value: string }[][] {
  const results: { attr: string; value: string }[][] = [];

  function helper(start: number, combo: { attr: string; value: string }[]) {
    if (combo.length === size) {
      results.push([...combo]);
      return;
    }
    for (let i = start; i < attributes.length; i++) {
      combo.push(attributes[i]);
      helper(i + 1, combo);
      combo.pop();
    }
  }

  helper(0, []);
  return results;
}

/**
 * Checks if the generated XPath uniquely identifies the target element.
 * @param xpath The XPath string to test.
 * @param target The target DOM element.
 * @returns True if unique, else false.
 */
function isXPathFirstResultElement(xpath: string, target: Element): boolean {
  try {
    const result = document.evaluate(
      xpath,
      document.documentElement,
      null,
      XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
      null,
    );
    return result.snapshotItem(0) === target;
  } catch (error) {
    // If there's an error evaluating the XPath, consider it not unique
    console.warn(`Invalid XPath expression: ${xpath}`, error);
    return false;
  }
}

/**
 * Escapes a string for use in an XPath expression.
 * Handles special characters, including single and double quotes.
 * @param value - The string to escape.
 * @returns The escaped string safe for XPath.
 */
export function escapeXPathString(value: string): string {
  if (value.includes("'")) {
    if (value.includes('"')) {
      // If the value contains both single and double quotes, split into parts
      return (
        "concat(" +
        value
          .split(/('+)/)
          .map((part) => {
            if (part === "'") {
              return `"'"`;
            } else if (part.startsWith("'") && part.endsWith("'")) {
              return `"${part}"`;
            } else {
              return `'${part}'`;
            }
          })
          .join(",") +
        ")"
      );
    } else {
      // Contains single quotes but not double quotes; use double quotes
      return `"${value}"`;
    }
  } else {
    // Does not contain single quotes; use single quotes
    return `'${value}'`;
  }
}

/**
 * Generates both a complicated XPath and a standard XPath for a given DOM element.
 * @param element - The target DOM element.
 * @param documentOverride - Optional document override.
 * @returns An object containing both XPaths.
 */
export async function generateXPathsForElement(
  element: ChildNode,
): Promise<string[]> {
  // Generate the standard XPath
  if (!element) return [];
  const [complexXPath, standardXPath, idBasedXPath] = await Promise.all([
    generateComplexXPath(element),
    generateStandardXPath(element),
    generatedIdBasedXPath(element),
  ]);

  // This should return in order from most accurate on current page to most cachable.
  // Do not change the order if you are not sure what you are doing.
  // Contact Navid if you need help understanding it.
  return [standardXPath, ...(idBasedXPath ? [idBasedXPath] : []), complexXPath];
}

async function generateComplexXPath(element: ChildNode): Promise<string> {
  // Generate the complicated XPath
  const parts: string[] = [];
  let currentElement: ChildNode | null = element;

  while (
    currentElement &&
    (isTextNode(currentElement) || isElementNode(currentElement))
  ) {
    if (isElementNode(currentElement)) {
      const el = currentElement as Element;
      let selector = el.tagName.toLowerCase();

      // List of attributes to consider for uniqueness
      const attributePriority = [
        "data-qa",
        "data-component",
        "data-role",
        "role",
        "aria-role",
        "type",
        "name",
        "aria-label",
        "placeholder",
        "title",
        "alt",
      ];

      // Collect attributes present on the element
      const attributes = attributePriority
        .map((attr) => {
          let value = el.getAttribute(attr);
          if (attr === "href-full" && value) {
            value = el.getAttribute("href");
          }
          return value
            ? { attr: attr === "href-full" ? "href" : attr, value }
            : null;
        })
        .filter((attr) => attr !== null) as { attr: string; value: string }[];

      // Attempt to find a combination of attributes that uniquely identifies the element
      let uniqueSelector = "";
      for (let i = 1; i <= attributes.length; i++) {
        const combinations = getCombinations(attributes, i);
        for (const combo of combinations) {
          const conditions = combo
            .map((a) => `@${a.attr}=${escapeXPathString(a.value)}`)
            .join(" and ");
          const xpath = `//${selector}[${conditions}]`;
          if (isXPathFirstResultElement(xpath, el)) {
            uniqueSelector = xpath;
            break;
          }
        }
        if (uniqueSelector) break;
      }

      if (uniqueSelector) {
        parts.unshift(uniqueSelector.replace("//", ""));
        break;
      } else {
        // Fallback to positional selector
        const parent = getParentElement(el);
        if (parent) {
          const siblings = Array.from(parent.children).filter(
            (sibling) => sibling.tagName === el.tagName,
          );
          const index = siblings.indexOf(el as HTMLElement) + 1;
          selector += siblings.length > 1 ? `[${index}]` : "";
        }
        parts.unshift(selector);
      }
    }

    currentElement = getParentElement(currentElement);
  }

  const xpath = "//" + parts.join("/");
  return xpath;
}

/**
 * Generates a standard XPath for a given DOM element.
 * @param element - The target DOM element.
 * @returns A standard XPath string.
 */
async function generateStandardXPath(element: ChildNode): Promise<string> {
  const parts: string[] = [];
  while (element && (isTextNode(element) || isElementNode(element))) {
    let index = 0;
    let hasSameTypeSiblings = false;
    const siblings = element.parentElement
      ? Array.from(element.parentElement.childNodes)
      : [];
    for (let i = 0; i < siblings.length; i++) {
      const sibling = siblings[i];
      if (
        sibling.nodeType === element.nodeType &&
        sibling.nodeName === element.nodeName
      ) {
        index = index + 1;
        hasSameTypeSiblings = true;
        if (sibling.isSameNode(element)) {
          break;
        }
      }
    }
    // text "nodes" are selected differently than elements with xPaths
    if (element.nodeName !== "#text") {
      const tagName = element.nodeName.toLowerCase();
      const pathIndex = hasSameTypeSiblings ? `[${index}]` : "";
      parts.unshift(`${tagName}${pathIndex}`);
    }
    element = element.parentElement as HTMLElement;
  }
  return parts.length ? `/${parts.join("/")}` : "";
}

async function generatedIdBasedXPath(
  element: ChildNode,
): Promise<string | null> {
  if (isElementNode(element) && element.id) {
    return `//*[@id='${element.id}']`;
  }
  return null;
}

================
File: lib/handlers/actHandler.ts
================
import { Locator, Page } from "@playwright/test";
import { LogLine } from "../../types/log";
import {
  PlaywrightCommandException,
  PlaywrightCommandMethodNotSupportedException,
} from "../../types/playwright";
import { ActionCache } from "../cache/ActionCache";
import { act, fillInVariables, verifyActCompletion } from "../inference";
import { LLMClient } from "../llm/LLMClient";
import { LLMProvider } from "../llm/LLMProvider";
import { generateId } from "../utils";
import { ScreenshotService } from "../vision";
import { StagehandPage } from "../StagehandPage";
import { StagehandContext } from "../StagehandContext";

export class StagehandActHandler {
  private readonly stagehandPage: StagehandPage;
  private readonly verbose: 0 | 1 | 2;
  private readonly llmProvider: LLMProvider;
  private readonly enableCaching: boolean;
  private readonly logger: (logLine: LogLine) => void;
  private readonly actionCache: ActionCache | undefined;
  private readonly actions: {
    [key: string]: { result: string; action: string };
  };

  constructor({
    verbose,
    llmProvider,
    enableCaching,
    logger,
    stagehandPage,
  }: {
    verbose: 0 | 1 | 2;
    llmProvider: LLMProvider;
    enableCaching: boolean;
    logger: (logLine: LogLine) => void;
    llmClient: LLMClient;
    stagehandPage: StagehandPage;
    stagehandContext: StagehandContext;
  }) {
    this.verbose = verbose;
    this.llmProvider = llmProvider;
    this.enableCaching = enableCaching;
    this.logger = logger;
    this.actionCache = enableCaching ? new ActionCache(this.logger) : undefined;
    this.actions = {};
    this.stagehandPage = stagehandPage;
  }

  private async _recordAction(action: string, result: string): Promise<string> {
    const id = generateId(action);

    this.actions[id] = { result, action };

    return id;
  }

  private async _verifyActionCompletion({
    completed,
    verifierUseVision,
    requestId,
    action,
    steps,
    llmClient,
    domSettleTimeoutMs,
  }: {
    completed: boolean;
    verifierUseVision: boolean;
    requestId: string;
    action: string;
    steps: string;
    llmClient: LLMClient;
    domSettleTimeoutMs?: number;
  }): Promise<boolean> {
    await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);

    // o1 is overkill for this task + this task uses a lot of tokens. So we switch it 4o
    let verifyLLmClient = llmClient;
    if (
      llmClient.modelName === "o1-mini" ||
      llmClient.modelName === "o1-preview" ||
      llmClient.modelName.startsWith("o1-")
    ) {
      verifyLLmClient = this.llmProvider.getClient(
        "gpt-4o",
        llmClient.clientOptions,
      );
    }

    const { selectorMap } = await this.stagehandPage.page.evaluate(() => {
      return window.processAllOfDom();
    });

    let actionCompleted = false;
    if (completed) {
      // Run action completion verifier
      this.logger({
        category: "action",
        message: "action marked as completed, verifying if this is true...",
        level: 1,
        auxiliary: {
          action: {
            value: action,
            type: "string",
          },
        },
      });

      let domElements: string | undefined = undefined;
      let fullpageScreenshot: Buffer | undefined = undefined;

      if (verifierUseVision) {
        try {
          const screenshotService = new ScreenshotService(
            this.stagehandPage.page,
            selectorMap,
            this.verbose,
            this.logger,
          );

          fullpageScreenshot = await screenshotService.getScreenshot(true, 15);
        } catch (e) {
          this.logger({
            category: "action",
            message: "error getting full page screenshot. trying again...",
            level: 1,
            auxiliary: {
              error: {
                value: e.message,
                type: "string",
              },
              trace: {
                value: e.stack,
                type: "string",
              },
            },
          });

          const screenshotService = new ScreenshotService(
            this.stagehandPage.page,
            selectorMap,
            this.verbose,
            this.logger,
          );

          fullpageScreenshot = await screenshotService.getScreenshot(true, 15);
        }
      } else {
        ({ outputString: domElements } = await this.stagehandPage.page.evaluate(
          () => {
            return window.processAllOfDom();
          },
        ));
      }

      actionCompleted = await verifyActCompletion({
        goal: action,
        steps,
        llmProvider: this.llmProvider,
        llmClient: verifyLLmClient,
        screenshot: fullpageScreenshot,
        domElements,
        logger: this.logger,
        requestId,
      });

      this.logger({
        category: "action",
        message: "action completion verification result",
        level: 1,
        auxiliary: {
          action: {
            value: action,
            type: "string",
          },
          result: {
            value: actionCompleted.toString(),
            type: "boolean",
          },
        },
      });
    }

    return actionCompleted;
  }

  private async _performPlaywrightMethod(
    method: string,
    args: unknown[],
    xpath: string,
    domSettleTimeoutMs?: number,
  ) {
    const locator = this.stagehandPage.page.locator(`xpath=${xpath}`).first();
    const initialUrl = this.stagehandPage.page.url();

    this.logger({
      category: "action",
      message: "performing playwright method",
      level: 2,
      auxiliary: {
        xpath: {
          value: xpath,
          type: "string",
        },
        method: {
          value: method,
          type: "string",
        },
      },
    });

    if (method === "scrollIntoView") {
      this.logger({
        category: "action",
        message: "scrolling element into view",
        level: 2,
        auxiliary: {
          xpath: {
            value: xpath,
            type: "string",
          },
        },
      });
      try {
        await locator
          .evaluate((element: HTMLElement) => {
            element.scrollIntoView({ behavior: "smooth", block: "center" });
          })
          .catch((e: Error) => {
            this.logger({
              category: "action",
              message: "error scrolling element into view",
              level: 1,
              auxiliary: {
                error: {
                  value: e.message,
                  type: "string",
                },
                trace: {
                  value: e.stack,
                  type: "string",
                },
                xpath: {
                  value: xpath,
                  type: "string",
                },
              },
            });
          });
      } catch (e) {
        this.logger({
          category: "action",
          message: "error scrolling element into view",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
            xpath: {
              value: xpath,
              type: "string",
            },
          },
        });

        throw new PlaywrightCommandException(e.message);
      }
    } else if (method === "fill" || method === "type") {
      try {
        await locator.fill("");
        await locator.click();
        const text = args[0]?.toString();
        for (const char of text) {
          await this.stagehandPage.page.keyboard.type(char, {
            delay: Math.random() * 50 + 25,
          });
        }
      } catch (e) {
        this.logger({
          category: "action",
          message: "error filling element",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
            xpath: {
              value: xpath,
              type: "string",
            },
          },
        });

        throw new PlaywrightCommandException(e.message);
      }
    } else if (method === "press") {
      try {
        const key = args[0]?.toString();
        await this.stagehandPage.page.keyboard.press(key);
      } catch (e) {
        this.logger({
          category: "action",
          message: "error pressing key",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
            key: {
              value: args[0]?.toString() ?? "unknown",
              type: "string",
            },
          },
        });

        throw new PlaywrightCommandException(e.message);
      }
    } else if (typeof locator[method as keyof typeof locator] === "function") {
      // Log current URL before action
      this.logger({
        category: "action",
        message: "page URL before action",
        level: 2,
        auxiliary: {
          url: {
            value: this.stagehandPage.page.url(),
            type: "string",
          },
        },
      });

      // Perform the action
      try {
        await (
          locator[method as keyof Locator] as unknown as (
            ...args: string[]
          ) => Promise<void>
        )(...args.map((arg) => arg?.toString() || ""));
      } catch (e) {
        this.logger({
          category: "action",
          message: "error performing method",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
            xpath: {
              value: xpath,
              type: "string",
            },
            method: {
              value: method,
              type: "string",
            },
            args: {
              value: JSON.stringify(args),
              type: "object",
            },
          },
        });

        throw new PlaywrightCommandException(e.message);
      }

      // Handle navigation if a new page is opened
      if (method === "click") {
        this.logger({
          category: "action",
          message: "clicking element, checking for page navigation",
          level: 1,
          auxiliary: {
            xpath: {
              value: xpath,
              type: "string",
            },
          },
        });

        // NAVIDNOTE: Should this happen before we wait for locator[method]?
        const newOpenedTab = await Promise.race([
          new Promise<Page | null>((resolve) => {
            // TODO: This is a hack to get the new page
            // We should find a better way to do this
            this.stagehandPage.context.once("page", (page) => resolve(page));
            setTimeout(() => resolve(null), 1_500);
          }),
        ]);

        this.logger({
          category: "action",
          message: "clicked element",
          level: 1,
          auxiliary: {
            newOpenedTab: {
              value: newOpenedTab ? "opened a new tab" : "no new tabs opened",
              type: "string",
            },
          },
        });

        if (newOpenedTab) {
          this.logger({
            category: "action",
            message: "new page detected (new tab) with URL",
            level: 1,
            auxiliary: {
              url: {
                value: newOpenedTab.url(),
                type: "string",
              },
            },
          });
          await newOpenedTab.close();
          await this.stagehandPage.page.goto(newOpenedTab.url());
          await this.stagehandPage.page.waitForLoadState("domcontentloaded");
          await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
        }

        await Promise.race([
          this.stagehandPage.page.waitForLoadState("networkidle"),
          new Promise((resolve) => setTimeout(resolve, 5_000)),
        ]).catch((e) => {
          this.logger({
            category: "action",
            message: "network idle timeout hit",
            level: 1,
            auxiliary: {
              trace: {
                value: e.stack,
                type: "string",
              },
              message: {
                value: e.message,
                type: "string",
              },
            },
          });
        });

        this.logger({
          category: "action",
          message: "finished waiting for (possible) page navigation",
          level: 1,
        });

        if (this.stagehandPage.page.url() !== initialUrl) {
          this.logger({
            category: "action",
            message: "new page detected with URL",
            level: 1,
            auxiliary: {
              url: {
                value: this.stagehandPage.page.url(),
                type: "string",
              },
            },
          });
        }
      }
    } else {
      this.logger({
        category: "action",
        message: "chosen method is invalid",
        level: 1,
        auxiliary: {
          method: {
            value: method,
            type: "string",
          },
        },
      });

      throw new PlaywrightCommandMethodNotSupportedException(
        `Method ${method} not supported`,
      );
    }

    await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
  }

  private async _getComponentString(locator: Locator) {
    return await locator.evaluate((el) => {
      // Create a clone of the element to avoid modifying the original
      const clone = el.cloneNode(true) as HTMLElement;

      // Keep only specific stable attributes that help identify elements
      const attributesToKeep = [
        "type",
        "name",
        "placeholder",
        "aria-label",
        "role",
        "href",
        "title",
        "alt",
      ];

      // Remove all attributes except those we want to keep
      Array.from(clone.attributes).forEach((attr) => {
        if (!attributesToKeep.includes(attr.name)) {
          clone.removeAttribute(attr.name);
        }
      });

      const outerHtml = clone.outerHTML;

      //   const variables = {
      //     // Replace with your actual variables and their values
      //     // Example:
      //     username: "JohnDoe",
      //     email: "john@example.com",
      //   };

      //   // Function to replace variable values with variable names
      //   const replaceVariables = (element: Element) => {
      //     if (element instanceof HTMLElement) {
      //       for (const [key, value] of Object.entries(variables)) {
      //         if (value) {
      //           element.innerText = element.innerText.replace(
      //             new RegExp(value, "g"),
      //             key,
      //           );
      //         }
      //       }
      //     }

      //     if (
      //       element instanceof HTMLInputElement ||
      //       element instanceof HTMLTextAreaElement
      //     ) {
      //       for (const [key, value] of Object.entries(variables)) {
      //         if (value) {
      //           element.value = element.value.replace(
      //             new RegExp(value, "g"),
      //             key,
      //           );
      //         }
      //       }
      //     }
      //   };

      //   // Replace variables in the cloned element
      //   replaceVariables(clone);

      //   // Replace variables in all child elements
      //   clone.querySelectorAll("*").forEach(replaceVariables);
      return outerHtml.trim().replace(/\s+/g, " ");
    });
  }

  private async getElement(
    xpath: string,
    timeout: number = 5_000,
  ): Promise<Locator | null> {
    try {
      const element = this.stagehandPage.page.locator(`xpath=${xpath}`).first();
      await element.waitFor({ state: "attached", timeout });
      return element;
    } catch {
      this.logger({
        category: "action",
        message: "element not found within timeout",
        level: 1,
        auxiliary: {
          xpath: {
            value: xpath,
            type: "string",
          },
          timeout_ms: {
            value: timeout.toString(),
            type: "integer",
          },
        },
      });
      return null;
    }
  }

  private async _checkIfCachedStepIsValid_oneXpath(cachedStep: {
    xpath: string;
    savedComponentString: string;
  }) {
    this.logger({
      category: "action",
      message: "checking if cached step is valid",
      level: 1,
      auxiliary: {
        xpath: {
          value: cachedStep.xpath,
          type: "string",
        },
        savedComponentString: {
          value: cachedStep.savedComponentString,
          type: "string",
        },
      },
    });
    try {
      const locator = await this.getElement(cachedStep.xpath);
      if (!locator) {
        this.logger({
          category: "action",
          message: "locator not found for xpath",
          level: 1,
          auxiliary: {
            xpath: {
              value: cachedStep.xpath,
              type: "string",
            },
          },
        });
        return false;
      }

      this.logger({
        category: "action",
        message: "locator element",
        level: 1,
        auxiliary: {
          componentString: {
            value: await this._getComponentString(locator),
            type: "string",
          },
        },
      });

      // First try to get the value (for input/textarea elements)
      const currentComponent = await this._getComponentString(locator);

      this.logger({
        category: "action",
        message: "current text",
        level: 1,
        auxiliary: {
          componentString: {
            value: currentComponent,
            type: "string",
          },
        },
      });

      if (!currentComponent || !cachedStep.savedComponentString) {
        this.logger({
          category: "action",
          message: "current text or cached text is undefined",
          level: 1,
        });
        return false;
      }

      // Normalize whitespace and trim both strings before comparing
      const normalizedCurrentText = currentComponent
        .trim()
        .replace(/\s+/g, " ");
      const normalizedCachedText = cachedStep.savedComponentString
        .trim()
        .replace(/\s+/g, " ");

      if (normalizedCurrentText !== normalizedCachedText) {
        this.logger({
          category: "action",
          message: "current text and cached text do not match",
          level: 1,
          auxiliary: {
            currentText: {
              value: normalizedCurrentText,
              type: "string",
            },
            cachedText: {
              value: normalizedCachedText,
              type: "string",
            },
          },
        });
        return false;
      }

      return true;
    } catch (e) {
      this.logger({
        category: "action",
        message: "error checking if cached step is valid",
        level: 1,
        auxiliary: {
          error: {
            value: e.message,
            type: "string",
          },
          trace: {
            value: e.stack,
            type: "string",
          },
        },
      });
      return false; // Added explicit return false for error cases
    }
  }

  private async _getValidCachedStepXpath(cachedStep: {
    xpaths: string[];
    savedComponentString: string;
  }) {
    const reversedXpaths = [...cachedStep.xpaths].reverse(); // We reverse the xpaths to try the most cachable ones first
    for (const xpath of reversedXpaths) {
      const isValid = await this._checkIfCachedStepIsValid_oneXpath({
        xpath,
        savedComponentString: cachedStep.savedComponentString,
      });

      if (isValid) {
        return xpath;
      }
    }
    return null;
  }

  private async _runCachedActionIfAvailable({
    action,
    previousSelectors,
    requestId,
    steps,
    chunksSeen,
    llmClient,
    useVision,
    verifierUseVision,
    retries,
    variables,
    domSettleTimeoutMs,
  }: {
    action: string;
    previousSelectors: string[];
    requestId: string;
    steps: string;
    chunksSeen: number[];
    llmClient: LLMClient;
    useVision: boolean | "fallback";
    verifierUseVision: boolean;
    retries: number;
    variables: Record<string, string>;
    domSettleTimeoutMs?: number;
  }) {
    if (!this.enableCaching) {
      return null;
    }

    const cacheObj = {
      url: this.stagehandPage.page.url(),
      action,
      previousSelectors,
      requestId,
    };

    this.logger({
      category: "action",
      message: "checking action cache",
      level: 1,
      auxiliary: {
        cacheObj: {
          value: JSON.stringify(cacheObj),
          type: "object",
        },
      },
    });

    const cachedStep = await this.actionCache.getActionStep(cacheObj);

    if (!cachedStep) {
      this.logger({
        category: "action",
        message: "action cache miss",
        level: 1,
        auxiliary: {
          cacheObj: {
            value: JSON.stringify(cacheObj),
            type: "object",
          },
        },
      });
      return null;
    }

    this.logger({
      category: "action",
      message: "action cache semi-hit",
      level: 1,
      auxiliary: {
        playwrightCommand: {
          value: JSON.stringify(cachedStep.playwrightCommand),
          type: "object",
        },
      },
    });

    try {
      const validXpath = await this._getValidCachedStepXpath({
        xpaths: cachedStep.xpaths,
        savedComponentString: cachedStep.componentString,
      });

      this.logger({
        category: "action",
        message: "cached action step is valid",
        level: 1,
        auxiliary: {
          validXpath: {
            value: validXpath,
            type: "string",
          },
        },
      });

      if (!validXpath) {
        this.logger({
          category: "action",
          message: "cached action step is invalid, removing...",
          level: 1,
          auxiliary: {
            cacheObj: {
              value: JSON.stringify(cacheObj),
              type: "object",
            },
          },
        });

        await this.actionCache?.removeActionStep(cacheObj);
        return null;
      }

      this.logger({
        category: "action",
        message: "action cache hit",
        level: 1,
        auxiliary: {
          playwrightCommand: {
            value: JSON.stringify(cachedStep.playwrightCommand),
            type: "object",
          },
        },
      });

      cachedStep.playwrightCommand.args = cachedStep.playwrightCommand.args.map(
        (arg) => {
          return fillInVariables(arg, variables);
        },
      );

      await this._performPlaywrightMethod(
        cachedStep.playwrightCommand.method,
        cachedStep.playwrightCommand.args,
        validXpath,
        domSettleTimeoutMs,
      );

      steps = steps + cachedStep.newStepString;
      await this.stagehandPage.page.evaluate(
        ({ chunksSeen }: { chunksSeen: number[] }) => {
          return window.processDom(chunksSeen);
        },
        { chunksSeen },
      );

      if (cachedStep.completed) {
        // Verify the action was completed successfully
        const actionCompleted = await this._verifyActionCompletion({
          completed: true,
          verifierUseVision,
          llmClient,
          steps,
          requestId,
          action,
          domSettleTimeoutMs,
        });

        this.logger({
          category: "action",
          message: "action completion verification result from cache",
          level: 1,
          auxiliary: {
            actionCompleted: {
              value: actionCompleted.toString(),
              type: "boolean",
            },
          },
        });

        if (actionCompleted) {
          return {
            success: true,
            message: "action completed successfully using cached step",
            action,
          };
        }
      }

      return this.act({
        action,
        steps,
        chunksSeen,
        llmClient,
        useVision,
        verifierUseVision,
        retries,
        requestId,
        variables,
        previousSelectors: [...previousSelectors, cachedStep.xpaths[0]],
        skipActionCacheForThisStep: false,
        domSettleTimeoutMs,
      });
    } catch (exception) {
      this.logger({
        category: "action",
        message: "error performing cached action step",
        level: 1,
        auxiliary: {
          error: {
            value: exception.message,
            type: "string",
          },
          trace: {
            value: exception.stack,
            type: "string",
          },
        },
      });

      await this.actionCache?.removeActionStep(cacheObj);
      return null;
    }
  }

  public async act({
    action,
    steps = "",
    chunksSeen,
    llmClient,
    useVision,
    verifierUseVision,
    retries = 0,
    requestId,
    variables,
    previousSelectors,
    skipActionCacheForThisStep = false,
    domSettleTimeoutMs,
  }: {
    action: string;
    steps?: string;
    chunksSeen: number[];
    llmClient: LLMClient;
    useVision: boolean | "fallback";
    verifierUseVision: boolean;
    retries?: number;
    requestId?: string;
    variables: Record<string, string>;
    previousSelectors: string[];
    skipActionCacheForThisStep: boolean;
    domSettleTimeoutMs?: number;
  }): Promise<{ success: boolean; message: string; action: string }> {
    try {
      await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
      await this.stagehandPage.startDomDebug();

      if (this.enableCaching && !skipActionCacheForThisStep) {
        const response = await this._runCachedActionIfAvailable({
          action,
          previousSelectors,
          requestId,
          steps,
          chunksSeen,
          llmClient,
          useVision,
          verifierUseVision,
          retries,
          variables,
          domSettleTimeoutMs,
        });

        if (response !== null) {
          return response;
        } else {
          return this.act({
            action,
            steps,
            chunksSeen,
            llmClient,
            useVision,
            verifierUseVision,
            retries,
            requestId,
            variables,
            previousSelectors,
            skipActionCacheForThisStep: true,
            domSettleTimeoutMs,
          });
        }
      }

      if (!llmClient.hasVision && (useVision !== false || verifierUseVision)) {
        this.logger({
          category: "action",
          message:
            "model does not support vision but useVision was not false. defaulting to false.",
          level: 1,
          auxiliary: {
            model: {
              value: llmClient.modelName,
              type: "string",
            },
            useVision: {
              value: useVision.toString(),
              type: "boolean",
            },
          },
        });
        useVision = false;
        verifierUseVision = false;
      }

      this.logger({
        category: "action",
        message: "running / continuing action",
        level: 2,
        auxiliary: {
          action: {
            value: action,
            type: "string",
          },
          pageUrl: {
            value: this.stagehandPage.page.url(),
            type: "string",
          },
        },
      });

      this.logger({
        category: "action",
        message: "processing DOM",
        level: 2,
      });

      const { outputString, selectorMap, chunk, chunks } =
        await this.stagehandPage.page.evaluate(
          ({ chunksSeen }: { chunksSeen: number[] }) => {
            return window.processDom(chunksSeen);
          },
          { chunksSeen },
        );

      this.logger({
        category: "action",
        message: "looking at chunk",
        level: 1,
        auxiliary: {
          chunk: {
            value: chunk.toString(),
            type: "integer",
          },
          chunks: {
            value: chunks.length.toString(),
            type: "integer",
          },
          chunksSeen: {
            value: chunksSeen.length.toString(),
            type: "integer",
          },
          chunksLeft: {
            value: (chunks.length - chunksSeen.length).toString(),
            type: "integer",
          },
        },
      });

      // Prepare annotated screenshot if vision is enabled
      let annotatedScreenshot: Buffer | undefined;
      if (useVision === true) {
        if (!llmClient.hasVision) {
          this.logger({
            category: "action",
            message:
              "model does not support vision. skipping vision processing.",
            level: 1,
            auxiliary: {
              model: {
                value: llmClient.modelName,
                type: "string",
              },
            },
          });
        } else {
          const screenshotService = new ScreenshotService(
            this.stagehandPage.page,
            selectorMap,
            this.verbose,
            this.logger,
          );

          annotatedScreenshot =
            await screenshotService.getAnnotatedScreenshot(false);
        }
      }

      const response = await act({
        action,
        domElements: outputString,
        steps,
        llmClient,
        screenshot: annotatedScreenshot,
        logger: this.logger,
        requestId,
        variables,
      });

      this.logger({
        category: "action",
        message: "received response from LLM",
        level: 1,
        auxiliary: {
          response: {
            value: JSON.stringify(response),
            type: "object",
          },
        },
      });

      await this.stagehandPage.cleanupDomDebug();

      if (!response) {
        if (chunksSeen.length + 1 < chunks.length) {
          chunksSeen.push(chunk);

          this.logger({
            category: "action",
            message: "no action found in current chunk",
            level: 1,
            auxiliary: {
              chunksSeen: {
                value: chunksSeen.length.toString(),
                type: "integer",
              },
            },
          });

          return this.act({
            action,
            steps:
              steps +
              (!steps.endsWith("\n") ? "\n" : "") +
              "## Step: Scrolled to another section\n",
            chunksSeen,
            llmClient,
            useVision,
            verifierUseVision,
            requestId,
            variables,
            previousSelectors,
            skipActionCacheForThisStep,
            domSettleTimeoutMs,
          });
        } else if (useVision === "fallback") {
          this.logger({
            category: "action",
            message: "switching to vision-based processing",
            level: 1,
            auxiliary: {
              useVision: {
                value: useVision.toString(),
                type: "string",
              },
            },
          });
          await this.stagehandPage.page.evaluate(() =>
            window.scrollToHeight(0),
          );
          return await this.act({
            action,
            steps,
            chunksSeen,
            llmClient,
            useVision: true,
            verifierUseVision,
            requestId,
            variables,
            previousSelectors,
            skipActionCacheForThisStep,
            domSettleTimeoutMs,
          });
        } else {
          if (this.enableCaching) {
            this.llmProvider.cleanRequestCache(requestId);
            this.actionCache?.deleteCacheForRequestId(requestId);
          }

          return {
            success: false,
            message: `Action was not able to be completed.`,
            action: action,
          };
        }
      }

      // Action found, proceed to execute
      const elementId = response["element"];
      const xpaths = selectorMap[elementId];
      const method = response["method"];
      const args = response["args"];

      // Get the element text from the outputString
      const elementLines = outputString.split("\n");
      const elementText =
        elementLines
          .find((line) => line.startsWith(`${elementId}:`))
          ?.split(":")[1] || "Element not found";

      this.logger({
        category: "action",
        message: "executing method",
        level: 1,
        auxiliary: {
          method: {
            value: method,
            type: "string",
          },
          elementId: {
            value: elementId.toString(),
            type: "integer",
          },
          xpaths: {
            value: JSON.stringify(xpaths),
            type: "object",
          },
          args: {
            value: JSON.stringify(args),
            type: "object",
          },
        },
      });

      try {
        const initialUrl = this.stagehandPage.page.url();
        const locator = this.stagehandPage.page
          .locator(`xpath=${xpaths[0]}`)
          .first();
        const originalUrl = this.stagehandPage.page.url();
        const componentString = await this._getComponentString(locator);
        const responseArgs = [...args];
        if (variables) {
          responseArgs.forEach((arg, index) => {
            if (typeof arg === "string") {
              args[index] = fillInVariables(arg, variables);
            }
          });
        }
        await this._performPlaywrightMethod(
          method,
          args,
          xpaths[0],
          domSettleTimeoutMs,
        );

        const newStepString =
          (!steps.endsWith("\n") ? "\n" : "") +
          `## Step: ${response.step}\n` +
          `  Element: ${elementText}\n` +
          `  Action: ${response.method}\n` +
          `  Reasoning: ${response.why}\n`;

        steps += newStepString;

        if (this.enableCaching) {
          this.actionCache
            .addActionStep({
              action,
              url: originalUrl,
              previousSelectors,
              playwrightCommand: {
                method,
                args: responseArgs.map((arg) => arg?.toString() || ""),
              },
              componentString,
              requestId,
              xpaths: xpaths,
              newStepString,
              completed: response.completed,
            })
            .catch((e) => {
              this.logger({
                category: "action",
                message: "error adding action step to cache",
                level: 1,
                auxiliary: {
                  error: {
                    value: e.message,
                    type: "string",
                  },
                  trace: {
                    value: e.stack,
                    type: "string",
                  },
                },
              });
            });
        }

        if (this.stagehandPage.page.url() !== initialUrl) {
          steps += `  Result (Important): Page URL changed from ${initialUrl} to ${this.stagehandPage.page.url()}\n\n`;
        }

        const actionCompleted = await this._verifyActionCompletion({
          completed: response.completed,
          verifierUseVision,
          requestId,
          action,
          steps,
          llmClient,
          domSettleTimeoutMs,
        }).catch((error) => {
          this.logger({
            category: "action",
            message:
              "error verifying action completion. Assuming action completed.",
            level: 1,
            auxiliary: {
              error: {
                value: error.message,
                type: "string",
              },
            },
          });

          return true;
        });

        if (!actionCompleted) {
          this.logger({
            category: "action",
            message: "continuing to next action step",
            level: 1,
          });

          return this.act({
            action,
            steps,
            llmClient,
            chunksSeen,
            useVision,
            verifierUseVision,
            requestId,
            variables,
            previousSelectors: [...previousSelectors, xpaths[0]],
            skipActionCacheForThisStep: false,
            domSettleTimeoutMs,
          });
        } else {
          this.logger({
            category: "action",
            message: "action completed successfully",
            level: 1,
          });
          await this._recordAction(action, response.step);
          return {
            success: true,
            message: `Action completed successfully: ${steps}${response.step}`,
            action: action,
          };
        }
      } catch (error) {
        this.logger({
          category: "action",
          message: "error performing action - d",
          level: 1,
          auxiliary: {
            error: {
              value: error.message,
              type: "string",
            },
            trace: {
              value: error.stack,
              type: "string",
            },
            retries: {
              value: retries.toString(),
              type: "integer",
            },
          },
        });

        if (retries < 2) {
          return this.act({
            action,
            steps,
            llmClient,
            useVision,
            verifierUseVision,
            retries: retries + 1,
            chunksSeen,
            requestId,
            variables,
            previousSelectors,
            skipActionCacheForThisStep,
            domSettleTimeoutMs,
          });
        }

        await this._recordAction(action, "");
        if (this.enableCaching) {
          this.llmProvider.cleanRequestCache(requestId);
          this.actionCache.deleteCacheForRequestId(requestId);
        }

        return {
          success: false,
          message: "error performing action - a",
          action: action,
        };
      }
    } catch (error) {
      this.logger({
        category: "action",
        message: "error performing action - b",
        level: 1,
        auxiliary: {
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });

      if (this.enableCaching) {
        this.llmProvider.cleanRequestCache(requestId);
        this.actionCache.deleteCacheForRequestId(requestId);
      }

      return {
        success: false,
        message: `Error performing action - C: ${error.message}`,
        action: action,
      };
    }
  }
}

================
File: lib/handlers/extractHandler.ts
================
import { z } from "zod";
import { LogLine } from "../../types/log";
import { TextAnnotation } from "../../types/textannotation";
import { extract } from "../inference";
import { LLMClient } from "../llm/LLMClient";
import { formatText } from "../utils";
import { StagehandPage } from "../StagehandPage";
import { Stagehand } from "../index";

const PROXIMITY_THRESHOLD = 15;

/**
 * The `StagehandExtractHandler` class is responsible for extracting structured data from a webpage.
 * It provides two approaches: `textExtract` and `domExtract`. `textExtract` is used by default.
 *
 * Here is what `textExtract` does at a high level:
 *
 * **1. Wait for the DOM to settle and start DOM debugging.**
 *    - Ensures the page is fully loaded and stable before extraction.
 *
 * **2. Store the original DOM before any mutations.**
 *    - Preserves the initial state of the DOM to restore later.
 *    - We do this because creating spans around every word in the DOM (see step 4)
 *      becomes very difficult to revert. Text nodes can be finicky, and directly
 *      removing the added spans often corrupts the structure of the DOM.
 *
 * **3. Process the DOM to generate a selector map of candidate elements.**
 *    - Identifies potential elements that contain the data to extract.
 *
 * **4. Create text bounding boxes around every word in the webpage.**
 *    - Wraps words in spans so that their bounding boxes can be used to
 *      determine their positions on the text-rendered-webpage.
 *
 * **5. Collect all text annotations (with positions and dimensions) from each of the candidate elements.**
 *    - Gathers text and positional data for each word.
 *
 * **6. Group annotations by text and deduplicate them based on proximity.**
 *    - There is no guarantee that the text annotations are unique (candidate elements can be nested).
 *    - Thus, we must remove duplicate words that are close to each other on the page.
 *
 * **7. Restore the original DOM after mutations.**
 *    - Returns the DOM to its original state after processing.
 *
 * **8. Format the deduplicated annotations into a text representation.**
 *    - Prepares the text data for the extraction process.
 *
 * **9. Pass the formatted text to an LLM for extraction according to the given instruction and schema.**
 *    - Uses a language model to extract structured data based on instructions.
 *
 * **10. Handle the extraction response and logging the results.**
 *     - Processes the output from the LLM and logs relevant information.
 *
 *
 * Here is what `domExtract` does at a high level:
 *
 * **1. Wait for the DOM to settle and start DOM debugging.**
 *   - Ensures the page is fully loaded and stable before extraction.
 *
 * **2. Process the DOM in chunks.**
 *   - The `processDom` function:
 *     - Divides the page into vertical "chunks" based on viewport height.
 *     - Picks the next chunk that hasn't been processed yet.
 *     - Scrolls to that chunk and extracts candidate elements.
 *     - Returns `outputString` (HTML snippets of candidate elements),
 *       `selectorMap` (the XPaths of the candidate elements),
 *       `chunk` (the current chunk index), and `chunks` (the array of all chunk indices).
 *   - This chunk-based approach ensures that large or lengthy pages can be processed in smaller, manageable sections.
 *
 * **3. Pass the extracted DOM elements (in `outputString`) to the LLM for structured data extraction.**
 *   - Uses the instructions, schema, and previously extracted content as context to
 *     guide the LLM in extracting the structured data.
 *
 * **4. Check if extraction is complete.**
 *    - If the extraction is complete (all chunks have been processed or the LLM determines
 *      that we do not need to continue), return the final result.
 *    - If not, repeat steps 1-4 with the next chunk until extraction is complete or no more chunks remain.
 *
 * @remarks
 * Each step corresponds to specific code segments, as noted in the comments throughout the code.
 */

export class StagehandExtractHandler {
  private readonly stagehand: Stagehand;
  private readonly stagehandPage: StagehandPage;
  private readonly logger: (logLine: LogLine) => void;

  constructor({
    stagehand,
    logger,
    stagehandPage,
  }: {
    stagehand: Stagehand;
    logger: (message: {
      category?: string;
      message: string;
      level?: number;
      auxiliary?: { [key: string]: { value: string; type: string } };
    }) => void;
    stagehandPage: StagehandPage;
  }) {
    this.stagehand = stagehand;
    this.logger = logger;
    this.stagehandPage = stagehandPage;
  }

  public async extract<T extends z.AnyZodObject>({
    instruction,
    schema,
    content = {},
    chunksSeen = [],
    llmClient,
    requestId,
    domSettleTimeoutMs,
    useTextExtract = false,
  }: {
    instruction: string;
    schema: T;
    content?: z.infer<T>;
    chunksSeen?: Array<number>;
    llmClient: LLMClient;
    requestId?: string;
    domSettleTimeoutMs?: number;
    useTextExtract?: boolean;
  }): Promise<z.infer<T>> {
    if (useTextExtract) {
      return this.textExtract({
        instruction,
        schema,
        content,
        llmClient,
        requestId,
        domSettleTimeoutMs,
      });
    } else {
      return this.domExtract({
        instruction,
        schema,
        content,
        chunksSeen,
        llmClient,
        requestId,
        domSettleTimeoutMs,
      });
    }
  }

  private async textExtract<T extends z.AnyZodObject>({
    instruction,
    schema,
    content = {},
    llmClient,
    requestId,
    domSettleTimeoutMs,
  }: {
    instruction: string;
    schema: T;
    content?: z.infer<T>;
    llmClient: LLMClient;
    requestId?: string;
    domSettleTimeoutMs?: number;
  }): Promise<z.infer<T>> {
    this.logger({
      category: "extraction",
      message: "starting extraction",
      level: 1,
      auxiliary: {
        instruction: {
          value: instruction,
          type: "string",
        },
      },
    });

    // **1:** Wait for the DOM to settle and start DOM debugging
    await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
    await this.stagehandPage.startDomDebug();

    // **2:** Store the original DOM before any mutations
    // we need to store the original DOM here because calling createTextBoundingBoxes()
    // will mutate the DOM by adding spans around every word
    const originalDOM = await this.stagehandPage.page.evaluate(() =>
      window.storeDOM(),
    );

    // **3:** Process the DOM to generate a selector map of candidate elements
    const { selectorMap }: { selectorMap: Record<number, string[]> } =
      await this.stagehand.page.evaluate(() => window.processAllOfDom());

    this.logger({
      category: "extraction",
      message: `received output from processAllOfDom. selectorMap has ${Object.keys(selectorMap).length} entries`,
      level: 1,
    });

    // **4:** Create text bounding boxes around every word in the webpage
    // calling createTextBoundingBoxes() will create a span around every word on the
    // webpage. The bounding boxes of these spans will be used to determine their
    // positions in the text rendered webpage
    await this.stagehand.page.evaluate(() => window.createTextBoundingBoxes());
    const pageWidth = await this.stagehand.page.evaluate(
      () => window.innerWidth,
    );
    const pageHeight = await this.stagehand.page.evaluate(
      () => window.innerHeight,
    );

    // **5:** Collect all text annotations (with positions and dimensions) from the candidate elements
    // allAnnotations will store all the TextAnnotations BEFORE deduplication
    const allAnnotations: TextAnnotation[] = [];

    // here we will loop through all the xpaths in the selectorMap,
    // and get the bounding boxes for each one. These are xpaths to "candidate elements"
    for (const xpaths of Object.values(selectorMap)) {
      const xpath = xpaths[0];

      // boundingBoxes is an array because there may be multiple bounding boxes within a single element
      // (since each bounding box is around a single word)
      const boundingBoxes: Array<{
        text: string;
        left: number;
        top: number;
        width: number;
        height: number;
      }> = await this.stagehandPage.page.evaluate(
        (xpath) => window.getElementBoundingBoxes(xpath),
        xpath,
      );

      for (const box of boundingBoxes) {
        const bottom_left = {
          x: box.left,
          y: box.top + box.height,
        };
        const bottom_left_normalized = {
          x: box.left / pageWidth,
          y: (box.top + box.height) / pageHeight,
        };

        const annotation: TextAnnotation = {
          text: box.text,
          bottom_left,
          bottom_left_normalized,
          width: box.width,
          height: box.height,
        };
        allAnnotations.push(annotation);
      }
    }

    // **6:** Group annotations by text and deduplicate them based on proximity
    const annotationsGroupedByText = new Map<string, TextAnnotation[]>();

    for (const annotation of allAnnotations) {
      if (!annotationsGroupedByText.has(annotation.text)) {
        annotationsGroupedByText.set(annotation.text, []);
      }
      annotationsGroupedByText.get(annotation.text)!.push(annotation);
    }

    const deduplicatedTextAnnotations: TextAnnotation[] = [];

    // here, we deduplicate annotations per text group
    for (const [text, annotations] of annotationsGroupedByText.entries()) {
      for (const annotation of annotations) {
        // check if this annotation is close to any existing deduplicated annotation
        const isDuplicate = deduplicatedTextAnnotations.some(
          (existingAnnotation) => {
            if (existingAnnotation.text !== text) return false;

            const dx =
              existingAnnotation.bottom_left.x - annotation.bottom_left.x;
            const dy =
              existingAnnotation.bottom_left.y - annotation.bottom_left.y;
            const distance = Math.hypot(dx, dy);
            // the annotation is a duplicate if it has the same text and its bottom_left
            // position is within the PROXIMITY_THRESHOLD of an existing annotation.
            // we calculate the Euclidean distance between the two bottom_left points,
            // and if the distance is less than PROXIMITY_THRESHOLD,
            // the annotation is considered a duplicate.
            return distance < PROXIMITY_THRESHOLD;
          },
        );

        if (!isDuplicate) {
          deduplicatedTextAnnotations.push(annotation);
        }
      }
    }

    // **7:** Restore the original DOM after mutations
    await this.stagehandPage.page.evaluate(
      (dom) => window.restoreDOM(dom),
      originalDOM,
    );

    // **8:** Format the deduplicated annotations into a text representation
    const formattedText = formatText(deduplicatedTextAnnotations, pageWidth);

    // **9:** Pass the formatted text to an LLM for extraction according to the given instruction and schema
    const extractionResponse = await extract({
      instruction,
      previouslyExtractedContent: content,
      domElements: formattedText,
      schema,
      chunksSeen: 1,
      chunksTotal: 1,
      llmClient,
      requestId,
    });

    const {
      metadata: { completed },
      ...output
    } = extractionResponse;
    await this.stagehandPage.cleanupDomDebug();

    // **10:** Handle the extraction response and log the results
    this.logger({
      category: "extraction",
      message: "received extraction response",
      auxiliary: {
        extraction_response: {
          value: JSON.stringify(extractionResponse),
          type: "object",
        },
      },
    });

    if (completed) {
      this.logger({
        category: "extraction",
        message: "extraction completed successfully",
        level: 1,
        auxiliary: {
          extraction_response: {
            value: JSON.stringify(extractionResponse),
            type: "object",
          },
        },
      });
    } else {
      this.logger({
        category: "extraction",
        message: "extraction incomplete after processing all data",
        level: 1,
        auxiliary: {
          extraction_response: {
            value: JSON.stringify(extractionResponse),
            type: "object",
          },
        },
      });
    }
    return output;
  }

  private async domExtract<T extends z.AnyZodObject>({
    instruction,
    schema,
    content = {},
    chunksSeen = [],
    llmClient,
    requestId,
    domSettleTimeoutMs,
  }: {
    instruction: string;
    schema: T;
    content?: z.infer<T>;
    chunksSeen?: Array<number>;
    llmClient: LLMClient;
    requestId?: string;
    domSettleTimeoutMs?: number;
  }): Promise<z.infer<T>> {
    this.logger({
      category: "extraction",
      message: "starting extraction using old approach",
      level: 1,
      auxiliary: {
        instruction: {
          value: instruction,
          type: "string",
        },
      },
    });

    // **1:** Wait for the DOM to settle and start DOM debugging
    // This ensures the page is stable before extracting any data.
    await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
    await this.stagehandPage.startDomDebug();

    // **2:** Call processDom() to handle chunk-based extraction
    // processDom determines which chunk of the page to process next.
    // It will:
    //   - Identify all chunks (vertical segments of the page),
    //   - Pick the next unprocessed chunk,
    //   - Scroll to that chunk's region,
    //   - Extract candidate elements and their text,
    //   - Return the extracted text (outputString), a selectorMap (for referencing elements),
    //     the current chunk index, and the full list of chunks.
    const { outputString, chunk, chunks } = await this.stagehand.page.evaluate(
      (chunksSeen?: number[]) => window.processDom(chunksSeen ?? []),
      chunksSeen,
    );

    this.logger({
      category: "extraction",
      message: "received output from processDom.",
      auxiliary: {
        chunk: {
          value: chunk.toString(),
          type: "integer",
        },
        chunks_left: {
          value: (chunks.length - chunksSeen.length).toString(),
          type: "integer",
        },
        chunks_total: {
          value: chunks.length.toString(),
          type: "integer",
        },
      },
    });

    // **3:** Pass the list of candidate HTML snippets to the LLM
    // The LLM uses the provided instruction and schema to parse and extract
    // structured data.
    const extractionResponse = await extract({
      instruction,
      previouslyExtractedContent: content,
      domElements: outputString,
      schema,
      llmClient,
      chunksSeen: chunksSeen.length,
      chunksTotal: chunks.length,
      requestId,
      isUsingTextExtract: false,
    });

    const {
      metadata: { completed },
      ...output
    } = extractionResponse;

    await this.stagehandPage.cleanupDomDebug();

    this.logger({
      category: "extraction",
      message: "received extraction response",
      auxiliary: {
        extraction_response: {
          value: JSON.stringify(extractionResponse),
          type: "object",
        },
      },
    });

    // Mark the current chunk as processed by adding it to chunksSeen
    chunksSeen.push(chunk);

    // **4:** Check if extraction is complete
    // If the LLM deems the extraction complete or we've processed all chunks, return the final result.
    // Otherwise, call domExtract again for the next chunk.
    if (completed || chunksSeen.length === chunks.length) {
      this.logger({
        category: "extraction",
        message: "got response",
        auxiliary: {
          extraction_response: {
            value: JSON.stringify(extractionResponse),
            type: "object",
          },
        },
      });

      return output;
    } else {
      this.logger({
        category: "extraction",
        message: "continuing extraction",
        auxiliary: {
          extraction_response: {
            value: JSON.stringify(extractionResponse),
            type: "object",
          },
        },
      });
      await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);

      // Recursively continue with the next chunk
      return this.domExtract({
        instruction,
        schema,
        content: output,
        chunksSeen,
        llmClient,
        domSettleTimeoutMs,
      });
    }
  }
}

================
File: lib/handlers/observeHandler.ts
================
import { LogLine } from "../../types/log";
import { Stagehand } from "../index";
import { observe } from "../inference";
import { LLMClient } from "../llm/LLMClient";
import { generateId } from "../utils";
import { ScreenshotService } from "../vision";
import { StagehandPage } from "../StagehandPage";

export class StagehandObserveHandler {
  private readonly stagehand: Stagehand;
  private readonly logger: (logLine: LogLine) => void;
  private readonly stagehandPage: StagehandPage;
  private readonly verbose: 0 | 1 | 2;
  private observations: {
    [key: string]: {
      result: { selector: string; description: string }[];
      instruction: string;
    };
  };

  constructor({
    stagehand,
    logger,
    stagehandPage,
  }: {
    stagehand: Stagehand;
    logger: (logLine: LogLine) => void;
    stagehandPage: StagehandPage;
  }) {
    this.stagehand = stagehand;
    this.logger = logger;
    this.stagehandPage = stagehandPage;
    this.observations = {};
  }

  private async _recordObservation(
    instruction: string,
    result: { selector: string; description: string }[],
  ): Promise<string> {
    const id = generateId(instruction);

    this.observations[id] = { result, instruction };

    return id;
  }

  public async observe({
    instruction,
    useVision,
    fullPage,
    llmClient,
    requestId,
    domSettleTimeoutMs,
  }: {
    instruction: string;
    useVision: boolean;
    fullPage: boolean;
    llmClient: LLMClient;
    requestId?: string;
    domSettleTimeoutMs?: number;
  }): Promise<{ selector: string; description: string }[]> {
    if (!instruction) {
      instruction = `Find elements that can be used for any future actions in the page. These may be navigation links, related pages, section/subsection links, buttons, or other interactive elements. Be comprehensive: if there are multiple elements that may be relevant for future actions, return all of them.`;
    }
    this.logger({
      category: "observation",
      message: "starting observation",
      level: 1,
      auxiliary: {
        instruction: {
          value: instruction,
          type: "string",
        },
      },
    });

    await this.stagehandPage._waitForSettledDom(domSettleTimeoutMs);
    await this.stagehandPage.startDomDebug();
    const evalResult = await this.stagehand.page.evaluate(
      (fullPage: boolean) =>
        fullPage ? window.processAllOfDom() : window.processDom([]),
      fullPage,
    );

    const { selectorMap } = evalResult;
    // has to be like this atm because of the re-assignment
    let { outputString } = evalResult;

    let annotatedScreenshot: Buffer | undefined;
    if (useVision === true) {
      if (!llmClient.hasVision) {
        this.logger({
          category: "observation",
          message: "Model does not support vision. Skipping vision processing.",
          level: 1,
          auxiliary: {
            model: {
              value: llmClient.modelName,
              type: "string",
            },
          },
        });
      } else {
        const screenshotService = new ScreenshotService(
          this.stagehand.page,
          selectorMap,
          this.verbose,
          this.logger,
        );

        annotatedScreenshot =
          await screenshotService.getAnnotatedScreenshot(fullPage);
        outputString = "n/a. use the image to find the elements.";
      }
    }

    const observationResponse = await observe({
      instruction,
      domElements: outputString,
      llmClient,
      image: annotatedScreenshot,
      requestId,
    });

    const elementsWithSelectors = observationResponse.elements.map(
      (element) => {
        const { elementId, ...rest } = element;

        return {
          ...rest,
          selector: `xpath=${selectorMap[elementId][0]}`,
        };
      },
    );

    await this.stagehandPage.cleanupDomDebug();

    this.logger({
      category: "observation",
      message: "found elements",
      level: 1,
      auxiliary: {
        elements: {
          value: JSON.stringify(elementsWithSelectors),
          type: "object",
        },
      },
    });

    await this._recordObservation(instruction, elementsWithSelectors);
    return elementsWithSelectors;
  }
}

================
File: lib/llm/AnthropicClient.ts
================
import Anthropic, { ClientOptions } from "@anthropic-ai/sdk";
import {
  ImageBlockParam,
  MessageParam,
  TextBlockParam,
  Tool,
} from "@anthropic-ai/sdk/resources";
import { zodToJsonSchema } from "zod-to-json-schema";
import { LogLine } from "../../types/log";
import {
  AnthropicJsonSchemaObject,
  AnthropicTransformedResponse,
  AvailableModel,
} from "../../types/model";
import { LLMCache } from "../cache/LLMCache";
import { ChatCompletionOptions, LLMClient } from "./LLMClient";

export class AnthropicClient extends LLMClient {
  public type = "anthropic" as const;
  private client: Anthropic;
  private cache: LLMCache | undefined;
  public logger: (message: LogLine) => void;
  private enableCaching: boolean;
  public clientOptions: ClientOptions;

  constructor(
    logger: (message: LogLine) => void,
    enableCaching = false,
    cache: LLMCache | undefined,
    modelName: AvailableModel,
    clientOptions?: ClientOptions,
  ) {
    super(modelName);
    this.client = new Anthropic(clientOptions);
    this.logger = logger;
    this.cache = cache;
    this.enableCaching = enableCaching;
    this.modelName = modelName;
    this.clientOptions = clientOptions;
  }

  async createChatCompletion<T = AnthropicTransformedResponse>(
    options: ChatCompletionOptions & { retries?: number },
  ): Promise<T> {
    const optionsWithoutImage = { ...options };
    delete optionsWithoutImage.image;

    this.logger({
      category: "anthropic",
      message: "creating chat completion",
      level: 1,
      auxiliary: {
        options: {
          value: JSON.stringify(optionsWithoutImage),
          type: "object",
        },
      },
    });
    // Try to get cached response
    const cacheOptions = {
      model: this.modelName,
      messages: options.messages,
      temperature: options.temperature,
      image: options.image,
      response_model: options.response_model,
      tools: options.tools,
      retries: options.retries,
    };

    if (this.enableCaching) {
      const cachedResponse = await this.cache.get<T>(
        cacheOptions,
        options.requestId,
      );
      if (cachedResponse) {
        this.logger({
          category: "llm_cache",
          message: "LLM cache hit - returning cached response",
          level: 1,
          auxiliary: {
            cachedResponse: {
              value: JSON.stringify(cachedResponse),
              type: "object",
            },
            requestId: {
              value: options.requestId,
              type: "string",
            },
            cacheOptions: {
              value: JSON.stringify(cacheOptions),
              type: "object",
            },
          },
        });
        return cachedResponse as T;
      } else {
        this.logger({
          category: "llm_cache",
          message: "LLM cache miss - no cached response found",
          level: 1,
          auxiliary: {
            cacheOptions: {
              value: JSON.stringify(cacheOptions),
              type: "object",
            },
            requestId: {
              value: options.requestId,
              type: "string",
            },
          },
        });
      }
    }

    const systemMessage = options.messages.find((msg) => {
      if (msg.role === "system") {
        if (typeof msg.content === "string") {
          return true;
        } else if (Array.isArray(msg.content)) {
          return msg.content.every((content) => content.type !== "image_url");
        }
      }
      return false;
    });

    const userMessages = options.messages.filter(
      (msg) => msg.role !== "system",
    );

    const formattedMessages: MessageParam[] = userMessages.map((msg) => {
      if (typeof msg.content === "string") {
        return {
          role: msg.role as "user" | "assistant", // ensure its not checking for system types
          content: msg.content,
        };
      } else {
        return {
          role: msg.role as "user" | "assistant",
          content: msg.content.map((content) => {
            if ("image_url" in content) {
              const formattedContent: ImageBlockParam = {
                type: "image",
                source: {
                  type: "base64",
                  media_type: "image/jpeg",
                  data: content.image_url.url,
                },
              };

              return formattedContent;
            } else {
              return { type: "text", text: content.text };
            }
          }),
        };
      }
    });

    if (options.image) {
      const screenshotMessage: MessageParam = {
        role: "user",
        content: [
          {
            type: "image",
            source: {
              type: "base64",
              media_type: "image/jpeg",
              data: options.image.buffer.toString("base64"),
            },
          },
        ],
      };

      if (
        options.image.description &&
        Array.isArray(screenshotMessage.content)
      ) {
        screenshotMessage.content.push({
          type: "text",
          text: options.image.description,
        });
      }

      formattedMessages.push(screenshotMessage);
    }

    let anthropicTools: Tool[] = options.tools?.map((tool) => {
      if (tool.type === "function") {
        return {
          name: tool.function.name,
          description: tool.function.description,
          input_schema: {
            type: "object",
            properties: tool.function.parameters.properties,
            required: tool.function.parameters.required,
          },
        };
      }
    });

    let toolDefinition: Tool | undefined;
    if (options.response_model) {
      const jsonSchema = zodToJsonSchema(options.response_model.schema);
      const { properties: schemaProperties, required: schemaRequired } =
        extractSchemaProperties(jsonSchema);

      toolDefinition = {
        name: "print_extracted_data",
        description: "Prints the extracted data based on the provided schema.",
        input_schema: {
          type: "object",
          properties: schemaProperties,
          required: schemaRequired,
        },
      };
    }

    if (toolDefinition) {
      anthropicTools = anthropicTools ?? [];
      anthropicTools.push(toolDefinition);
    }

    const response = await this.client.messages.create({
      model: this.modelName,
      max_tokens: options.maxTokens || 8192,
      messages: formattedMessages,
      tools: anthropicTools,
      system: systemMessage
        ? (systemMessage.content as string | TextBlockParam[]) // we can cast because we already filtered out image content
        : undefined,
      temperature: options.temperature,
    });

    this.logger({
      category: "anthropic",
      message: "response",
      level: 1,
      auxiliary: {
        response: {
          value: JSON.stringify(response),
          type: "object",
        },
        requestId: {
          value: options.requestId,
          type: "string",
        },
      },
    });

    const transformedResponse: AnthropicTransformedResponse = {
      id: response.id,
      object: "chat.completion",
      created: Date.now(),
      model: response.model,
      choices: [
        {
          index: 0,
          message: {
            role: "assistant",
            content:
              response.content.find((c) => c.type === "text")?.text || null,
            tool_calls: response.content
              .filter((c) => c.type === "tool_use")
              .map((toolUse) => ({
                id: toolUse.id,
                type: "function",
                function: {
                  name: toolUse.name,
                  arguments: JSON.stringify(toolUse.input),
                },
              })),
          },
          finish_reason: response.stop_reason,
        },
      ],
      usage: {
        prompt_tokens: response.usage.input_tokens,
        completion_tokens: response.usage.output_tokens,
        total_tokens:
          response.usage.input_tokens + response.usage.output_tokens,
      },
    };

    this.logger({
      category: "anthropic",
      message: "transformed response",
      level: 1,
      auxiliary: {
        transformedResponse: {
          value: JSON.stringify(transformedResponse),
          type: "object",
        },
        requestId: {
          value: options.requestId,
          type: "string",
        },
      },
    });

    if (options.response_model) {
      const toolUse = response.content.find((c) => c.type === "tool_use");
      if (toolUse && "input" in toolUse) {
        const result = toolUse.input;
        if (this.enableCaching) {
          this.cache.set(cacheOptions, result, options.requestId);
        }

        return result as T; // anthropic returns this as `unknown`, so we need to cast
      } else {
        if (!options.retries || options.retries < 5) {
          return this.createChatCompletion({
            ...options,
            retries: (options.retries ?? 0) + 1,
          });
        }
        this.logger({
          category: "anthropic",
          message: "error creating chat completion",
          level: 1,
          auxiliary: {
            requestId: {
              value: options.requestId,
              type: "string",
            },
          },
        });
        throw new Error(
          "Create Chat Completion Failed: No tool use with input in response",
        );
      }
    }

    if (this.enableCaching) {
      this.cache.set(cacheOptions, transformedResponse, options.requestId);
      this.logger({
        category: "anthropic",
        message: "cached response",
        level: 1,
        auxiliary: {
          requestId: {
            value: options.requestId,
            type: "string",
          },
          transformedResponse: {
            value: JSON.stringify(transformedResponse),
            type: "object",
          },
          cacheOptions: {
            value: JSON.stringify(cacheOptions),
            type: "object",
          },
        },
      });
    }

    // if the function was called with a response model, it would have returned earlier
    // so we can safely cast here to T, which defaults to AnthropicTransformedResponse
    return transformedResponse as T;
  }
}

const extractSchemaProperties = (jsonSchema: AnthropicJsonSchemaObject) => {
  const schemaRoot = jsonSchema.definitions?.MySchema || jsonSchema;

  return {
    properties: schemaRoot.properties,
    required: schemaRoot.required,
  };
};

================
File: lib/llm/LLMClient.ts
================
import {
  ChatCompletion,
  ChatCompletionToolChoiceOption,
} from "openai/resources";
import { ZodType } from "zod";
import {
  AnthropicTransformedResponse,
  AvailableModel,
  ClientOptions,
  ToolCall,
} from "../../types/model";

export interface ChatMessage {
  role: "system" | "user" | "assistant";
  content: ChatMessageContent;
}

export type ChatMessageContent =
  | string
  | (ChatMessageImageContent | ChatMessageTextContent)[];

export interface ChatMessageImageContent {
  type: "image_url";
  image_url: { url: string };
  text?: string;
}

export interface ChatMessageTextContent {
  type: string;
  text: string;
}

export const modelsWithVision: AvailableModel[] = [
  "gpt-4o",
  "gpt-4o-mini",
  "claude-3-5-sonnet-latest",
  "claude-3-5-sonnet-20240620",
  "claude-3-5-sonnet-20241022",
  "gpt-4o-2024-08-06",
];

export const AnnotatedScreenshotText =
  "This is a screenshot of the current page state with the elements annotated on it. Each element id is annotated with a number to the top left of it. Duplicate annotations at the same location are under each other vertically.";

export interface ChatCompletionOptions {
  messages: ChatMessage[];
  temperature?: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  image?: {
    buffer: Buffer;
    description?: string;
  };
  response_model?: {
    name: string;
    schema: ZodType;
  };
  tools?: ToolCall[];
  tool_choice?: "auto" | ChatCompletionToolChoiceOption;
  maxTokens?: number;
  requestId: string;
}

export type LLMResponse = AnthropicTransformedResponse | ChatCompletion;

export abstract class LLMClient {
  public type: "openai" | "anthropic";
  public modelName: AvailableModel;
  public hasVision: boolean;
  public clientOptions: ClientOptions;

  constructor(modelName: AvailableModel) {
    this.modelName = modelName;
    this.hasVision = modelsWithVision.includes(modelName);
  }

  abstract createChatCompletion<T = LLMResponse>(
    options: ChatCompletionOptions,
  ): Promise<T>;
  abstract logger: (message: { category?: string; message: string }) => void;
}

================
File: lib/llm/LLMProvider.ts
================
import { LogLine } from "../../types/log";
import {
  AvailableModel,
  ClientOptions,
  ModelProvider,
} from "../../types/model";
import { LLMCache } from "../cache/LLMCache";
import { AnthropicClient } from "./AnthropicClient";
import { LLMClient } from "./LLMClient";
import { OpenAIClient } from "./OpenAIClient";

export class LLMProvider {
  private modelToProviderMap: { [key in AvailableModel]: ModelProvider } = {
    "gpt-4o": "openai",
    "gpt-4o-mini": "openai",
    "gpt-4o-2024-08-06": "openai",
    "o1-mini": "openai",
    "o1-preview": "openai",
    "claude-3-5-sonnet-latest": "anthropic",
    "claude-3-5-sonnet-20240620": "anthropic",
    "claude-3-5-sonnet-20241022": "anthropic",
  };

  private logger: (message: LogLine) => void;
  private enableCaching: boolean;
  private cache: LLMCache | undefined;

  constructor(logger: (message: LogLine) => void, enableCaching: boolean) {
    this.logger = logger;
    this.enableCaching = enableCaching;
    this.cache = enableCaching ? new LLMCache(logger) : undefined;
  }

  cleanRequestCache(requestId: string): void {
    if (!this.enableCaching) {
      return;
    }

    this.logger({
      category: "llm_cache",
      message: "cleaning up cache",
      level: 1,
      auxiliary: {
        requestId: {
          value: requestId,
          type: "string",
        },
      },
    });
    this.cache.deleteCacheForRequestId(requestId);
  }

  getClient(
    modelName: AvailableModel,
    clientOptions?: ClientOptions,
  ): LLMClient {
    const provider = this.modelToProviderMap[modelName];
    if (!provider) {
      throw new Error(`Unsupported model: ${modelName}`);
    }

    switch (provider) {
      case "openai":
        return new OpenAIClient(
          this.logger,
          this.enableCaching,
          this.cache,
          modelName,
          clientOptions,
        );
      case "anthropic":
        return new AnthropicClient(
          this.logger,
          this.enableCaching,
          this.cache,
          modelName,
          clientOptions,
        );
      default:
        throw new Error(`Unsupported provider: ${provider}`);
    }
  }
}

================
File: lib/llm/OpenAIClient.ts
================
import OpenAI, { ClientOptions } from "openai";
import { zodResponseFormat } from "openai/helpers/zod";
import {
  ChatCompletion,
  ChatCompletionAssistantMessageParam,
  ChatCompletionContentPartImage,
  ChatCompletionContentPartText,
  ChatCompletionCreateParamsNonStreaming,
  ChatCompletionMessageParam,
  ChatCompletionSystemMessageParam,
  ChatCompletionUserMessageParam,
} from "openai/resources/chat";
import zodToJsonSchema from "zod-to-json-schema";
import { LogLine } from "../../types/log";
import { AvailableModel } from "../../types/model";
import { LLMCache } from "../cache/LLMCache";
import { validateZodSchema } from "../utils";
import { ChatCompletionOptions, ChatMessage, LLMClient } from "./LLMClient";

export class OpenAIClient extends LLMClient {
  public type = "openai" as const;
  private client: OpenAI;
  private cache: LLMCache | undefined;
  public logger: (message: LogLine) => void;
  private enableCaching: boolean;
  public clientOptions: ClientOptions;

  constructor(
    logger: (message: LogLine) => void,
    enableCaching = false,
    cache: LLMCache | undefined,
    modelName: AvailableModel,
    clientOptions?: ClientOptions,
  ) {
    super(modelName);
    this.clientOptions = clientOptions;
    this.client = new OpenAI(clientOptions);
    this.logger = logger;
    this.cache = cache;
    this.enableCaching = enableCaching;
    this.modelName = modelName;
  }

  async createChatCompletion<T = ChatCompletion>(
    optionsInitial: ChatCompletionOptions,
    retries: number = 3,
  ): Promise<T> {
    let options: Partial<ChatCompletionOptions> = optionsInitial;

    // O1 models do not support most of the options. So we override them.
    // For schema and tools, we add them as user messages.
    let isToolsOverridedForO1 = false;
    if (this.modelName === "o1-mini" || this.modelName === "o1-preview") {
      /* eslint-disable */
      // Remove unsupported options
      let {
        tool_choice,
        top_p,
        frequency_penalty,
        presence_penalty,
        temperature,
      } = options;
      ({
        tool_choice,
        top_p,
        frequency_penalty,
        presence_penalty,
        temperature,
        ...options
      } = options);
      /* eslint-enable */
      // Remove unsupported options
      options.messages = options.messages.map((message) => ({
        ...message,
        role: "user",
      }));
      if (options.tools && options.response_model) {
        throw new Error(
          "Cannot use both tool and response_model for o1 models",
        );
      }

      if (options.tools) {
        // Remove unsupported options
        let { tools } = options;
        ({ tools, ...options } = options);
        isToolsOverridedForO1 = true;
        options.messages.push({
          role: "user",
          content: `You have the following tools available to you:\n${JSON.stringify(
            tools,
          )}

          Respond with the following zod schema format to use a method: {
            "name": "<tool_name>",
            "arguments": <tool_args>
          }
          
          Do not include any other text or formattings like \`\`\` in your response. Just the JSON object.`,
        });
      }
    }
    if (
      options.temperature &&
      (this.modelName === "o1-mini" || this.modelName === "o1-preview")
    ) {
      throw new Error("Temperature is not supported for o1 models");
    }

    const { image, requestId, ...optionsWithoutImageAndRequestId } = options;

    this.logger({
      category: "openai",
      message: "creating chat completion",
      level: 1,
      auxiliary: {
        options: {
          value: JSON.stringify({
            ...optionsWithoutImageAndRequestId,
            requestId,
          }),
          type: "object",
        },
        modelName: {
          value: this.modelName,
          type: "string",
        },
      },
    });

    const cacheOptions = {
      model: this.modelName,
      messages: options.messages,
      temperature: options.temperature,
      top_p: options.top_p,
      frequency_penalty: options.frequency_penalty,
      presence_penalty: options.presence_penalty,
      image: image,
      response_model: options.response_model,
    };

    if (this.enableCaching) {
      const cachedResponse = await this.cache.get<T>(
        cacheOptions,
        options.requestId,
      );
      if (cachedResponse) {
        this.logger({
          category: "llm_cache",
          message: "LLM cache hit - returning cached response",
          level: 1,
          auxiliary: {
            requestId: {
              value: options.requestId,
              type: "string",
            },
            cachedResponse: {
              value: JSON.stringify(cachedResponse),
              type: "object",
            },
          },
        });
        return cachedResponse;
      } else {
        this.logger({
          category: "llm_cache",
          message: "LLM cache miss - no cached response found",
          level: 1,
          auxiliary: {
            requestId: {
              value: options.requestId,
              type: "string",
            },
          },
        });
      }
    }

    if (options.image) {
      const screenshotMessage: ChatMessage = {
        role: "user",
        content: [
          {
            type: "image_url",
            image_url: {
              url: `data:image/jpeg;base64,${options.image.buffer.toString("base64")}`,
            },
          },
          ...(options.image.description
            ? [{ type: "text", text: options.image.description }]
            : []),
        ],
      };

      options.messages.push(screenshotMessage);
    }

    let responseFormat = undefined;
    if (options.response_model) {
      // For O1 models, we need to add the schema as a user message.
      if (this.modelName === "o1-mini" || this.modelName === "o1-preview") {
        try {
          const parsedSchema = JSON.stringify(
            zodToJsonSchema(options.response_model.schema),
          );
          options.messages.push({
            role: "user",
            content: `Respond in this zod schema format:\n${parsedSchema}\n

          Do not include any other text, formating or markdown in your output. Do not include \`\`\` or \`\`\`json in your response. Only the JSON object itself.`,
          });
        } catch (error) {
          this.logger({
            category: "openai",
            message: "Failed to parse response model schema",
            level: 0,
          });

          if (retries > 0) {
            // as-casting to account for o1 models not supporting all options
            return this.createChatCompletion(
              options as ChatCompletionOptions,
              retries - 1,
            );
          }

          throw error;
        }
      } else {
        responseFormat = zodResponseFormat(
          options.response_model.schema,
          options.response_model.name,
        );
      }
    }

    /* eslint-disable */
    // Remove unsupported options
    const { response_model, ...openAiOptions } = {
      ...optionsWithoutImageAndRequestId,
      model: this.modelName,
    };
    /* eslint-enable */

    this.logger({
      category: "openai",
      message: "creating chat completion",
      level: 1,
      auxiliary: {
        openAiOptions: {
          value: JSON.stringify(openAiOptions),
          type: "object",
        },
      },
    });

    const formattedMessages: ChatCompletionMessageParam[] =
      options.messages.map((message) => {
        if (Array.isArray(message.content)) {
          const contentParts = message.content.map((content) => {
            if ("image_url" in content) {
              const imageContent: ChatCompletionContentPartImage = {
                image_url: {
                  url: content.image_url.url,
                },
                type: "image_url",
              };
              return imageContent;
            } else {
              const textContent: ChatCompletionContentPartText = {
                text: content.text,
                type: "text",
              };
              return textContent;
            }
          });

          if (message.role === "system") {
            const formattedMessage: ChatCompletionSystemMessageParam = {
              ...message,
              role: "system",
              content: contentParts.filter(
                (content): content is ChatCompletionContentPartText =>
                  content.type === "text",
              ),
            };
            return formattedMessage;
          } else if (message.role === "user") {
            const formattedMessage: ChatCompletionUserMessageParam = {
              ...message,
              role: "user",
              content: contentParts,
            };
            return formattedMessage;
          } else {
            const formattedMessage: ChatCompletionAssistantMessageParam = {
              ...message,
              role: "assistant",
              content: contentParts.filter(
                (content): content is ChatCompletionContentPartText =>
                  content.type === "text",
              ),
            };
            return formattedMessage;
          }
        }

        const formattedMessage: ChatCompletionUserMessageParam = {
          role: "user",
          content: message.content,
        };

        return formattedMessage;
      });

    const body: ChatCompletionCreateParamsNonStreaming = {
      ...openAiOptions,
      model: this.modelName,
      messages: formattedMessages,
      response_format: responseFormat,
      stream: false,
      tools: options.tools?.filter((tool) => "function" in tool), // ensure only OpenAI tools are used
    };

    const response = await this.client.chat.completions.create(body);

    // For O1 models, we need to parse the tool call response manually and add it to the response.
    if (isToolsOverridedForO1) {
      try {
        const parsedContent = JSON.parse(response.choices[0].message.content);

        response.choices[0].message.tool_calls = [
          {
            function: {
              name: parsedContent["name"],
              arguments: JSON.stringify(parsedContent["arguments"]),
            },
            type: "function",
            id: "-1",
          },
        ];
        response.choices[0].message.content = null;
      } catch (error) {
        this.logger({
          category: "openai",
          message: "Failed to parse tool call response",
          level: 0,
          auxiliary: {
            error: {
              value: error.message,
              type: "string",
            },
            content: {
              value: response.choices[0].message.content,
              type: "string",
            },
          },
        });

        if (retries > 0) {
          // as-casting to account for o1 models not supporting all options
          return this.createChatCompletion(
            options as ChatCompletionOptions,
            retries - 1,
          );
        }

        throw error;
      }
    }

    this.logger({
      category: "openai",
      message: "response",
      level: 1,
      auxiliary: {
        response: {
          value: JSON.stringify(response),
          type: "object",
        },
        requestId: {
          value: requestId,
          type: "string",
        },
      },
    });

    if (options.response_model) {
      const extractedData = response.choices[0].message.content;
      const parsedData = JSON.parse(extractedData);

      if (!validateZodSchema(options.response_model.schema, parsedData)) {
        if (retries > 0) {
          // as-casting to account for o1 models not supporting all options
          return this.createChatCompletion(
            options as ChatCompletionOptions,
            retries - 1,
          );
        }

        throw new Error("Invalid response schema");
      }

      if (this.enableCaching) {
        this.cache.set(
          cacheOptions,
          {
            ...parsedData,
          },
          options.requestId,
        );
      }

      return parsedData;
    }

    if (this.enableCaching) {
      this.logger({
        category: "llm_cache",
        message: "caching response",
        level: 1,
        auxiliary: {
          requestId: {
            value: options.requestId,
            type: "string",
          },
          cacheOptions: {
            value: JSON.stringify(cacheOptions),
            type: "object",
          },
          response: {
            value: JSON.stringify(response),
            type: "object",
          },
        },
      });
      this.cache.set(cacheOptions, response, options.requestId);
    }

    // if the function was called with a response model, it would have returned earlier
    // so we can safely cast here to T, which defaults to ChatCompletion
    return response as T;
  }
}

================
File: lib/cache.ts
================
import fs from "fs";
const observationsPath = "./.cache/observations.json";
const actionsPath = "./.cache/actions.json";

/**
 * A file system cache to skip inference when repeating steps
 * It also acts as the source of truth for identifying previously seen actions and observations
 */
class Cache {
  disabled: boolean;

  constructor({ disabled = false } = {}) {
    this.disabled = disabled;
    if (!this.disabled) {
      this.initCache();
    }
  }

  readObservations() {
    if (this.disabled) {
      return {};
    }
    try {
      return JSON.parse(fs.readFileSync(observationsPath, "utf8"));
    } catch (error) {
      console.error("Error reading from observations.json", error);
      return {};
    }
  }

  readActions() {
    if (this.disabled) {
      return {};
    }
    try {
      return JSON.parse(fs.readFileSync(actionsPath, "utf8"));
    } catch (error) {
      console.error("Error reading from actions.json", error);
      return {};
    }
  }

  writeObservations({
    key,
    value,
  }: {
    key: string;
    value: { id: string; result: string };
  }) {
    if (this.disabled) {
      return;
    }

    const observations = this.readObservations();
    observations[key] = value;
    fs.writeFileSync(observationsPath, JSON.stringify(observations, null, 2));
  }

  writeActions({
    key,
    value,
  }: {
    key: string;
    value: { id: string; result: string };
  }) {
    if (this.disabled) {
      return;
    }

    const actions = this.readActions();
    actions[key] = value;
    fs.writeFileSync(actionsPath, JSON.stringify(actions, null, 2));
  }

  evictCache() {
    throw new Error("implement me");
  }

  private initCache() {
    if (this.disabled) {
      return;
    }
    const cacheDir = ".cache";

    if (!fs.existsSync(cacheDir)) {
      fs.mkdirSync(cacheDir);
    }
    if (!fs.existsSync(actionsPath)) {
      fs.writeFileSync(actionsPath, JSON.stringify({}));
    }

    if (!fs.existsSync(observationsPath)) {
      fs.writeFileSync(observationsPath, JSON.stringify({}));
    }
  }
}

export default Cache;

================
File: lib/index.ts
================
import { Browserbase } from "@browserbasehq/sdk";
import { chromium } from "@playwright/test";
import { randomUUID } from "crypto";
import dotenv from "dotenv";
import fs from "fs";
import os from "os";
import path from "path";
import { z } from "zod";
import { BrowserResult } from "../types/browser";
import { LogLine } from "../types/log";
import { GotoOptions } from "../types/playwright";
import { Page, BrowserContext } from "../types/page";
import {
  ActOptions,
  ActResult,
  ConstructorParams,
  ExtractOptions,
  ExtractResult,
  InitFromPageOptions,
  InitFromPageResult,
  InitOptions,
  InitResult,
  ObserveOptions,
  ObserveResult,
} from "../types/stagehand";
import { scriptContent } from "./dom/build/scriptContent";
import { StagehandExtractHandler } from "./handlers/extractHandler";
import { StagehandObserveHandler } from "./handlers/observeHandler";
import { LLMClient } from "./llm/LLMClient";
import { LLMProvider } from "./llm/LLMProvider";
import { logLineToString } from "./utils";
import { StagehandPage } from "./StagehandPage";
import { StagehandContext } from "./StagehandContext";

dotenv.config({ path: ".env" });

const DEFAULT_MODEL_NAME = "gpt-4o";
const BROWSERBASE_REGION_DOMAIN = {
  "us-west-2": "wss://connect.usw2.browserbase.com",
  "us-east-1": "wss://connect.use1.browserbase.com",
  "eu-central-1": "wss://connect.euc1.browserbase.com",
  "ap-southeast-1": "wss://connect.apse1.browserbase.com",
};

async function getBrowser(
  apiKey: string | undefined,
  projectId: string | undefined,
  env: "LOCAL" | "BROWSERBASE" = "LOCAL",
  headless: boolean = false,
  logger: (message: LogLine) => void,
  browserbaseSessionCreateParams?: Browserbase.Sessions.SessionCreateParams,
  browserbaseSessionID?: string,
): Promise<BrowserResult> {
  if (env === "BROWSERBASE") {
    if (!apiKey) {
      logger({
        category: "init",
        message:
          "BROWSERBASE_API_KEY is required to use BROWSERBASE env. Defaulting to LOCAL.",
        level: 0,
      });
      env = "LOCAL";
    }
    if (!projectId) {
      logger({
        category: "init",
        message:
          "BROWSERBASE_PROJECT_ID is required for some Browserbase features that may not work without it.",
        level: 1,
      });
    }
  }

  if (env === "BROWSERBASE") {
    if (!apiKey) {
      throw new Error("BROWSERBASE_API_KEY is required.");
    }

    let debugUrl: string | undefined = undefined;
    let sessionUrl: string | undefined = undefined;
    let sessionId: string;
    let connectUrl: string;

    const browserbase = new Browserbase({
      apiKey,
    });

    if (browserbaseSessionID) {
      // Validate the session status
      try {
        const sessionStatus =
          await browserbase.sessions.retrieve(browserbaseSessionID);

        if (sessionStatus.status !== "RUNNING") {
          throw new Error(
            `Session ${browserbaseSessionID} is not running (status: ${sessionStatus.status})`,
          );
        }

        sessionId = browserbaseSessionID;
        const browserbaseDomain =
          BROWSERBASE_REGION_DOMAIN[sessionStatus.region] ||
          "wss://connect.browserbase.com";
        connectUrl = `${browserbaseDomain}?apiKey=${apiKey}&sessionId=${sessionId}`;

        logger({
          category: "init",
          message: "resuming existing browserbase session...",
          level: 1,
          auxiliary: {
            sessionId: {
              value: sessionId,
              type: "string",
            },
          },
        });
      } catch (error) {
        logger({
          category: "init",
          message: "failed to resume session",
          level: 1,
          auxiliary: {
            error: {
              value: error.message,
              type: "string",
            },
            trace: {
              value: error.stack,
              type: "string",
            },
          },
        });
        throw error;
      }
    } else {
      // Create new session (existing code)
      logger({
        category: "init",
        message: "creating new browserbase session...",
        level: 0,
      });

      if (!projectId) {
        throw new Error(
          "BROWSERBASE_PROJECT_ID is required for new Browserbase sessions.",
        );
      }

      const session = await browserbase.sessions.create({
        projectId,
        ...browserbaseSessionCreateParams,
      });

      sessionId = session.id;
      connectUrl = session.connectUrl;
      logger({
        category: "init",
        message: "created new browserbase session",
        level: 1,
        auxiliary: {
          sessionId: {
            value: sessionId,
            type: "string",
          },
        },
      });
    }

    const browser = await chromium.connectOverCDP(connectUrl);
    const { debuggerUrl } = await browserbase.sessions.debug(sessionId);

    debugUrl = debuggerUrl;
    sessionUrl = `https://www.browserbase.com/sessions/${sessionId}`;

    logger({
      category: "init",
      message: browserbaseSessionID
        ? "browserbase session resumed"
        : "browserbase session started",
      level: 0,
      auxiliary: {
        sessionUrl: {
          value: sessionUrl,
          type: "string",
        },
        debugUrl: {
          value: debugUrl,
          type: "string",
        },
        sessionId: {
          value: sessionId,
          type: "string",
        },
      },
    });

    const context = browser.contexts()[0];

    return { browser, context, debugUrl, sessionUrl, sessionId, env };
  } else {
    logger({
      category: "init",
      message: "launching local browser",
      level: 0,
      auxiliary: {
        headless: {
          value: headless.toString(),
          type: "boolean",
        },
      },
    });

    const tmpDirPath = path.join(os.tmpdir(), "stagehand");
    if (!fs.existsSync(tmpDirPath)) {
      fs.mkdirSync(tmpDirPath, { recursive: true });
    }

    const tmpDir = fs.mkdtempSync(path.join(tmpDirPath, "ctx_"));
    fs.mkdirSync(path.join(tmpDir, "userdir/Default"), { recursive: true });

    const defaultPreferences = {
      plugins: {
        always_open_pdf_externally: true,
      },
    };

    fs.writeFileSync(
      path.join(tmpDir, "userdir/Default/Preferences"),
      JSON.stringify(defaultPreferences),
    );

    const downloadsPath = path.join(process.cwd(), "downloads");
    fs.mkdirSync(downloadsPath, { recursive: true });

    const context = await chromium.launchPersistentContext(
      path.join(tmpDir, "userdir"),
      {
        acceptDownloads: true,
        headless: headless,
        viewport: {
          width: 1250,
          height: 800,
        },
        locale: "en-US",
        timezoneId: "America/New_York",
        deviceScaleFactor: 1,
        args: [
          "--enable-webgl",
          "--use-gl=swiftshader",
          "--enable-accelerated-2d-canvas",
          "--disable-blink-features=AutomationControlled",
          "--disable-web-security",
        ],
        bypassCSP: true,
      },
    );

    logger({
      category: "init",
      message: "local browser started successfully.",
    });

    await applyStealthScripts(context);

    return { context, contextPath: tmpDir, env: "LOCAL" };
  }
}

async function applyStealthScripts(context: BrowserContext) {
  await context.addInitScript(() => {
    // Override the navigator.webdriver property
    Object.defineProperty(navigator, "webdriver", {
      get: () => undefined,
    });

    // Mock languages and plugins to mimic a real browser
    Object.defineProperty(navigator, "languages", {
      get: () => ["en-US", "en"],
    });

    Object.defineProperty(navigator, "plugins", {
      get: () => [1, 2, 3, 4, 5],
    });

    // Remove Playwright-specific properties
    delete window.__playwright;
    delete window.__pw_manual;
    delete window.__PW_inspect;

    // Redefine the headless property
    Object.defineProperty(navigator, "headless", {
      get: () => false,
    });

    // Override the permissions API
    const originalQuery = window.navigator.permissions.query;
    window.navigator.permissions.query = (parameters) =>
      parameters.name === "notifications"
        ? Promise.resolve({
            state: Notification.permission,
          } as PermissionStatus)
        : originalQuery(parameters);
  });
}

const defaultLogger = async (logLine: LogLine) => {
  console.log(logLineToString(logLine));
};

export class Stagehand {
  private stagehandPage!: StagehandPage;
  private stagehandContext!: StagehandContext;
  private intEnv: "LOCAL" | "BROWSERBASE";

  public browserbaseSessionID?: string;
  public readonly domSettleTimeoutMs: number;
  public readonly debugDom: boolean;
  public readonly headless: boolean;
  public verbose: 0 | 1 | 2;
  public llmProvider: LLMProvider;
  public enableCaching: boolean;

  private internalLogger: (logLine: LogLine) => void;
  private apiKey: string | undefined;
  private projectId: string | undefined;
  // We want external logger to accept async functions
  private externalLogger?: (logLine: LogLine) => void | Promise<void>;
  private browserbaseSessionCreateParams?: Browserbase.Sessions.SessionCreateParams;
  public variables: { [key: string]: unknown };
  private contextPath?: string;
  private llmClient: LLMClient;

  private extractHandler?: StagehandExtractHandler;
  private observeHandler?: StagehandObserveHandler;

  constructor(
    {
      env,
      apiKey,
      projectId,
      verbose,
      debugDom,
      llmProvider,
      headless,
      logger,
      browserbaseSessionCreateParams,
      domSettleTimeoutMs,
      enableCaching,
      browserbaseSessionID,
      modelName,
      modelClientOptions,
    }: ConstructorParams = {
      env: "BROWSERBASE",
    },
  ) {
    this.externalLogger = logger || defaultLogger;
    this.internalLogger = this.log.bind(this);
    this.enableCaching =
      enableCaching ??
      (process.env.ENABLE_CACHING && process.env.ENABLE_CACHING === "true");
    this.llmProvider =
      llmProvider || new LLMProvider(this.logger, this.enableCaching);
    this.intEnv = env;
    this.apiKey = apiKey ?? process.env.BROWSERBASE_API_KEY;
    this.projectId = projectId ?? process.env.BROWSERBASE_PROJECT_ID;
    this.verbose = verbose ?? 0;
    this.debugDom = debugDom ?? false;
    this.llmClient = this.llmProvider.getClient(
      modelName ?? DEFAULT_MODEL_NAME,
      modelClientOptions,
    );
    this.domSettleTimeoutMs = domSettleTimeoutMs ?? 30_000;
    this.headless = headless ?? false;
    this.browserbaseSessionCreateParams = browserbaseSessionCreateParams;
    this.browserbaseSessionID = browserbaseSessionID;
  }

  public get logger(): (logLine: LogLine) => void {
    return (logLine: LogLine) => {
      this.log(logLine);
    };
  }

  public get page(): Page {
    // End users should not be able to access the StagehandPage directly
    // This is a proxy to the underlying Playwright Page
    if (!this.stagehandPage) {
      throw new Error(
        "Stagehand not initialized. Make sure to await stagehand.init() first.",
      );
    }
    return this.stagehandPage.page;
  }

  public get env(): "LOCAL" | "BROWSERBASE" {
    if (this.intEnv === "BROWSERBASE" && this.apiKey && this.projectId) {
      return "BROWSERBASE";
    }
    return "LOCAL";
  }

  public get context(): BrowserContext {
    return this.stagehandContext.context;
  }

  async init(
    /** @deprecated Use constructor options instead */
    initOptions?: InitOptions,
  ): Promise<InitResult> {
    if (initOptions) {
      console.warn(
        "Passing parameters to init() is deprecated and will be removed in the next major version. Use constructor options instead.",
      );
    }
    const { context, debugUrl, sessionUrl, contextPath, sessionId, env } =
      await getBrowser(
        this.apiKey,
        this.projectId,
        this.env,
        this.headless,
        this.logger,
        this.browserbaseSessionCreateParams,
        this.browserbaseSessionID,
      ).catch((e) => {
        console.error("Error in init:", e);
        const br: BrowserResult = {
          context: undefined,
          debugUrl: undefined,
          sessionUrl: undefined,
          sessionId: undefined,
          env: this.env,
        };
        return br;
      });
    this.intEnv = env;
    this.contextPath = contextPath;
    this.stagehandContext = await StagehandContext.init(context, this);
    const defaultPage = this.context.pages()[0];
    this.stagehandPage = await new StagehandPage(
      defaultPage,
      this,
      this.stagehandContext,
      this.llmClient,
    ).init();

    // Set the browser to headless mode if specified
    if (this.headless) {
      await this.page.setViewportSize({ width: 1280, height: 720 });
    }

    await this.context.addInitScript({
      content: scriptContent,
    });

    this.browserbaseSessionID = sessionId;

    return { debugUrl, sessionUrl, sessionId };
  }

  /** @deprecated initFromPage is deprecated and will be removed in the next major version. */
  async initFromPage({
    page,
  }: InitFromPageOptions): Promise<InitFromPageResult> {
    console.warn(
      "initFromPage is deprecated and will be removed in the next major version. To instantiate from a page, use `browserbaseSessionID` in the constructor.",
    );
    this.stagehandPage = await new StagehandPage(
      page,
      this,
      this.stagehandContext,
      this.llmClient,
    ).init();
    this.stagehandContext = await StagehandContext.init(page.context(), this);

    const originalGoto = this.page.goto.bind(this.page);
    this.page.goto = async (url: string, options?: GotoOptions) => {
      const result = await originalGoto(url, options);
      if (this.debugDom) {
        await this.page.evaluate(() => (window.showChunks = this.debugDom));
      }
      await this.page.waitForLoadState("domcontentloaded");
      await this.stagehandPage._waitForSettledDom();
      return result;
    };

    // Set the browser to headless mode if specified
    if (this.headless) {
      await this.page.setViewportSize({ width: 1280, height: 720 });
    }

    // Add initialization scripts
    await this.context.addInitScript({
      content: scriptContent,
    });

    return { context: this.context };
  }

  private pending_logs_to_send_to_browserbase: LogLine[] = [];

  private is_processing_browserbase_logs: boolean = false;

  log(logObj: LogLine): void {
    logObj.level = logObj.level || 1;

    // Normal Logging
    if (this.externalLogger) {
      this.externalLogger(logObj);
    }

    // Add the logs to the browserbase session
    this.pending_logs_to_send_to_browserbase.push({
      ...logObj,
      id: randomUUID(),
    });
    this._run_browserbase_log_processing_cycle();
  }

  private async _run_browserbase_log_processing_cycle() {
    if (this.is_processing_browserbase_logs) {
      return;
    }
    this.is_processing_browserbase_logs = true;
    const pending_logs = [...this.pending_logs_to_send_to_browserbase];
    for (const logObj of pending_logs) {
      await this._log_to_browserbase(logObj);
    }
    this.is_processing_browserbase_logs = false;
  }

  private async _log_to_browserbase(logObj: LogLine) {
    logObj.level = logObj.level || 1;

    if (!this.stagehandPage) {
      return;
    }

    if (this.verbose >= logObj.level) {
      await this.page
        .evaluate((logObj) => {
          const logMessage = logLineToString(logObj);
          if (
            logObj.message.toLowerCase().includes("trace") ||
            logObj.message.toLowerCase().includes("error:")
          ) {
            console.error(logMessage);
          } else {
            console.log(logMessage);
          }
        }, logObj)
        .then(() => {
          this.pending_logs_to_send_to_browserbase =
            this.pending_logs_to_send_to_browserbase.filter(
              (log) => log.id !== logObj.id,
            );
        })
        .catch(() => {
          // NAVIDTODO: Rerun the log call on the new page
          // This is expected to happen when the user is changing pages
          // console.error("Logging Error:", e);
          // this.log({
          //   category: "browserbase",
          //   message: "error logging to browserbase",
          //   level: 1,
          //   auxiliary: {
          //     trace: {
          //       value: e.stack,
          //       type: "string",
          //     },
          //     message: {
          //       value: e.message,
          //       type: "string",
          //     },
          //   },
          // });
        });
    }
  }

  /** @deprecated Use stagehand.page.act() instead. This will be removed in the next major release. */
  async act(options: ActOptions): Promise<ActResult> {
    return await this.stagehandPage.act(options);
  }

  /** @deprecated Use stagehand.page.extract() instead. This will be removed in the next major release. */
  async extract<T extends z.AnyZodObject>(
    options: ExtractOptions<T>,
  ): Promise<ExtractResult<T>> {
    return await this.stagehandPage.extract(options);
  }

  /** @deprecated Use stagehand.page.observe() instead. This will be removed in the next major release. */
  async observe(options?: ObserveOptions): Promise<ObserveResult[]> {
    return await this.stagehandPage.observe(options);
  }

  async close(): Promise<void> {
    await this.context.close();

    if (this.contextPath) {
      try {
        fs.rmSync(this.contextPath, { recursive: true, force: true });
      } catch (e) {
        console.error("Error deleting context directory:", e);
      }
    }
  }
}

export * from "../types/browser";
export * from "../types/log";
export * from "../types/model";
export * from "../types/playwright";
export * from "../types/stagehand";
export * from "../types/page";

================
File: lib/inference.ts
================
import {
  actTools,
  buildActSystemPrompt,
  buildActUserPrompt,
  buildAskSystemPrompt,
  buildExtractSystemPrompt,
  buildExtractUserPrompt,
  buildObserveSystemPrompt,
  buildObserveUserMessage,
  buildAskUserPrompt,
  buildVerifyActCompletionSystemPrompt,
  buildVerifyActCompletionUserPrompt,
  buildRefineSystemPrompt,
  buildRefineUserPrompt,
  buildMetadataSystemPrompt,
  buildMetadataPrompt,
} from "./prompt";
import { z } from "zod";
import {
  AnnotatedScreenshotText,
  ChatMessage,
  LLMClient,
} from "./llm/LLMClient";
import { VerifyActCompletionParams } from "../types/inference";
import { ActResult, ActParams } from "../types/act";

export async function verifyActCompletion({
  goal,
  steps,
  llmClient,
  screenshot,
  domElements,
  logger,
  requestId,
}: VerifyActCompletionParams): Promise<boolean> {
  const verificationSchema = z.object({
    completed: z.boolean().describe("true if the goal is accomplished"),
  });

  type VerificationResponse = z.infer<typeof verificationSchema>;

  const response = await llmClient.createChatCompletion<VerificationResponse>({
    messages: [
      buildVerifyActCompletionSystemPrompt(),
      buildVerifyActCompletionUserPrompt(goal, steps, domElements),
    ],
    temperature: 0.1,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    image: screenshot
      ? {
          buffer: screenshot,
          description: "This is a screenshot of the whole visible page.",
        }
      : undefined,
    response_model: {
      name: "Verification",
      schema: verificationSchema,
    },
    requestId,
  });

  if (!response || typeof response !== "object") {
    logger({
      category: "VerifyAct",
      message: "Unexpected response format: " + JSON.stringify(response),
    });
    return false;
  }

  if (response.completed === undefined) {
    logger({
      category: "VerifyAct",
      message: "Missing 'completed' field in response",
    });
    return false;
  }

  return response.completed;
}

export function fillInVariables(
  text: string,
  variables: Record<string, string>,
) {
  let processedText = text;
  Object.entries(variables).forEach(([key, value]) => {
    const placeholder = `<|${key.toUpperCase()}|>`;
    processedText = processedText.replace(placeholder, value);
  });
  return processedText;
}

export async function act({
  action,
  domElements,
  steps,
  llmClient,
  screenshot,
  retries = 0,
  logger,
  requestId,
  variables,
}: ActParams): Promise<ActResult | null> {
  const messages: ChatMessage[] = [
    buildActSystemPrompt(),
    buildActUserPrompt(action, steps, domElements, variables),
  ];

  const response = await llmClient.createChatCompletion({
    messages,
    temperature: 0.1,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    tool_choice: "auto" as const,
    tools: actTools,
    image: screenshot
      ? { buffer: screenshot, description: AnnotatedScreenshotText }
      : undefined,
    requestId,
  });

  const toolCalls = response.choices[0].message.tool_calls;

  if (toolCalls && toolCalls.length > 0) {
    if (toolCalls[0].function.name === "skipSection") {
      return null;
    }

    return JSON.parse(toolCalls[0].function.arguments);
  } else {
    if (retries >= 2) {
      logger({
        category: "Act",
        message: "No tool calls found in response",
      });
      return null;
    }

    return act({
      action,
      domElements,
      steps,
      llmClient,
      retries: retries + 1,
      logger,
      requestId,
    });
  }
}

export async function extract({
  instruction,
  previouslyExtractedContent,
  domElements,
  schema,
  llmClient,
  chunksSeen,
  chunksTotal,
  requestId,
  isUsingTextExtract,
}: {
  instruction: string;
  previouslyExtractedContent: object;
  domElements: string;
  schema: z.ZodObject<z.ZodRawShape>;
  llmClient: LLMClient;
  chunksSeen: number;
  chunksTotal: number;
  requestId: string;
  isUsingTextExtract?: boolean;
}) {
  type ExtractionResponse = z.infer<typeof schema>;
  type MetadataResponse = z.infer<typeof metadataSchema>;
  const isUsingAnthropic = llmClient.type === "anthropic";

  const extractionResponse = await llmClient.createChatCompletion({
    messages: [
      buildExtractSystemPrompt(isUsingAnthropic, isUsingTextExtract),
      buildExtractUserPrompt(instruction, domElements, isUsingAnthropic),
    ],
    response_model: {
      schema: schema,
      name: "Extraction",
    },
    temperature: 0.1,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    requestId,
  });

  const refinedResponse =
    await llmClient.createChatCompletion<ExtractionResponse>({
      messages: [
        buildRefineSystemPrompt(),
        buildRefineUserPrompt(
          instruction,
          previouslyExtractedContent,
          extractionResponse,
        ),
      ],
      response_model: {
        schema: schema,
        name: "RefinedExtraction",
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      requestId,
    });

  const metadataSchema = z.object({
    progress: z
      .string()
      .describe(
        "progress of what has been extracted so far, as concise as possible",
      ),
    completed: z
      .boolean()
      .describe(
        "true if the goal is now accomplished. Use this conservatively, only when you are sure that the goal has been completed.",
      ),
  });

  const metadataResponse =
    await llmClient.createChatCompletion<MetadataResponse>({
      messages: [
        buildMetadataSystemPrompt(),
        buildMetadataPrompt(
          instruction,
          refinedResponse,
          chunksSeen,
          chunksTotal,
        ),
      ],
      response_model: {
        name: "Metadata",
        schema: metadataSchema,
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      requestId,
    });

  return {
    ...refinedResponse,
    metadata: metadataResponse,
  };
}

export async function observe({
  instruction,
  domElements,
  llmClient,
  image,
  requestId,
}: {
  instruction: string;
  domElements: string;
  llmClient: LLMClient;
  image?: Buffer;
  requestId: string;
}): Promise<{
  elements: { elementId: number; description: string }[];
}> {
  const observeSchema = z.object({
    elements: z
      .array(
        z.object({
          elementId: z.number().describe("the number of the element"),
          description: z
            .string()
            .describe(
              "a description of the element and what it is relevant for",
            ),
        }),
      )
      .describe("an array of elements that match the instruction"),
  });

  type ObserveResponse = z.infer<typeof observeSchema>;

  const observationResponse =
    await llmClient.createChatCompletion<ObserveResponse>({
      messages: [
        buildObserveSystemPrompt(),
        buildObserveUserMessage(instruction, domElements),
      ],
      image: image
        ? { buffer: image, description: AnnotatedScreenshotText }
        : undefined,
      response_model: {
        schema: observeSchema,
        name: "Observation",
      },
      temperature: 0.1,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
      requestId,
    });

  const parsedResponse = {
    elements:
      observationResponse.elements?.map((el) => ({
        elementId: Number(el.elementId),
        description: String(el.description),
      })) ?? [],
  } satisfies { elements: { elementId: number; description: string }[] };

  return parsedResponse;
}

export async function ask({
  question,
  llmClient,
  requestId,
}: {
  question: string;
  llmClient: LLMClient;
  requestId: string;
}) {
  const response = await llmClient.createChatCompletion({
    messages: [buildAskSystemPrompt(), buildAskUserPrompt(question)],
    temperature: 0.1,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
    requestId,
  });

  // The parsing is now handled in the LLM clients
  return response.choices[0].message.content;
}

================
File: lib/prompt.ts
================
import OpenAI from "openai";
import { ChatMessage } from "./llm/LLMClient";

// act
const actSystemPrompt = `
# Instructions
You are a browser automation assistant. Your job is to accomplish the user's goal across multiple model calls by running playwright commands.

## Input
You will receive:
1. the user's overall goal
2. the steps that you've taken so far
3. a list of active DOM elements in this chunk to consider to get closer to the goal. 
4. Optionally, a list of variable names that the user has provided that you may use to accomplish the goal. To use the variables, you must use the special <|VARIABLE_NAME|> syntax.


## Your Goal / Specification
You have 2 tools that you can call: doAction, and skipSection. Do action only performs Playwright actions. Do exactly what the user's goal is. Do not perform any other actions or exceed the scope of the goal.
If the user's goal will be accomplished after running the playwright action, set completed to true. Better to have completed set to true if your are not sure.

Note 1: If there is a popup on the page for cookies or advertising that has nothing to do with the goal, try to close it first before proceeding. As this can block the goal from being completed.
Note 2: Sometimes what your are looking for is hidden behind and element you need to interact with. For example, sliders, buttons, etc...

Again, if the user's goal will be accomplished after running the playwright action, set completed to true.
`;

const verifyActCompletionSystemPrompt = `
You are a browser automation assistant. The job has given you a goal and a list of steps that have been taken so far. Your job is to determine if the user's goal has been completed based on the provided information.

# Input
You will receive:
1. The user's goal: A clear description of what the user wants to achieve.
2. Steps taken so far: A list of actions that have been performed up to this point.
3. An image of the current page

# Your Task
Analyze the provided information to determine if the user's goal has been fully completed.

# Output
Return a boolean value:
- true: If the goal has been definitively completed based on the steps taken and the current page.
- false: If the goal has not been completed or if there's any uncertainty about its completion.

# Important Considerations
- False positives are okay. False negatives are not okay.
- Look for evidence of errors on the page or something having gone wrong in completing the goal. If one does not exist, return true.
`;

// ## Examples for completion check
// ### Example 1
// 1. User's goal: "input data scientist into role"
// 2. Steps you've taken so far: "The role input field was filled with 'data scientist'."
// 3. Active DOM elements: ["<input id="c9" class="VfPpkd-fmcmS-wGMbrd " aria-expanded="false" data-axe="mdc-autocomplete">data scientist</input>", "<button class="VfPpkd-LgbsSe VfPpkd-LgbsSe-OWXEXe-INsAgc lJ9FBc nDgy9d" type="submit">Search</button>"]

// Output: Will need to have completed set to true. Nothing else matters.
// Reasoning: The goal the user set has already been accomplished. We should not take any extra actions outside of the scope of the goal (for example, clicking on the search button is an invalid action - ie: not acceptable).

// ### Example 2
// 1. User's goal: "Sign up for the newsletter"
// 2. Steps you've taken so far: ["The email input field was filled with 'test@test.com'."]
// 3. Active DOM elements: ["<input type='email' id='newsletter-email' placeholder='Enter your email'></input>", "<button id='subscribe-button'>Subscribe</button>"]

// Output: Will need to have click on the subscribe button as action. And completed set to false.
// Reasoning: There might be an error when trying to submit the form and you need to make sure the goal is accomplished properly. So you set completed to false.

export function buildVerifyActCompletionSystemPrompt(): ChatMessage {
  return {
    role: "system",
    content: verifyActCompletionSystemPrompt,
  };
}

export function buildVerifyActCompletionUserPrompt(
  goal: string,
  steps = "None",
  domElements: string | undefined,
): ChatMessage {
  let actUserPrompt = `
# My Goal
${goal}

# Steps You've Taken So Far
${steps}
`;

  if (domElements) {
    actUserPrompt += `
# Active DOM Elements on the current page
${domElements}
`;
  }

  return {
    role: "user",
    content: actUserPrompt,
  };
}

export function buildActSystemPrompt(): ChatMessage {
  return {
    role: "system",
    content: actSystemPrompt,
  };
}

export function buildActUserPrompt(
  action: string,
  steps = "None",
  domElements: string,
  variables?: Record<string, string>,
): ChatMessage {
  let actUserPrompt = `
# My Goal
${action}

# Steps You've Taken So Far
${steps}

# Current Active Dom Elements
${domElements}
`;

  if (variables && Object.keys(variables).length > 0) {
    actUserPrompt += `
# Variables
${Object.keys(variables)
  .map((key) => `<|${key.toUpperCase()}|>`)
  .join("\n")}
`;
  }

  return {
    role: "user",
    content: actUserPrompt,
  };
}

export const actTools: Array<OpenAI.ChatCompletionTool> = [
  {
    type: "function",
    function: {
      name: "doAction",
      description:
        "execute the next playwright step that directly accomplishes the goal",
      parameters: {
        type: "object",
        required: ["method", "element", "args", "step", "completed"],
        properties: {
          method: {
            type: "string",
            description: "The playwright function to call.",
          },
          element: {
            type: "number",
            description: "The element number to act on",
          },
          args: {
            type: "array",
            description: "The required arguments",
            items: {
              type: "string",
              description: "The argument to pass to the function",
            },
          },
          step: {
            type: "string",
            description:
              "human readable description of the step that is taken in the past tense. Please be very detailed.",
          },
          why: {
            type: "string",
            description:
              "why is this step taken? how does it advance the goal?",
          },
          completed: {
            type: "boolean",
            description:
              "true if the goal should be accomplished after this step",
          },
        },
      },
    },
  },
  {
    type: "function",
    function: {
      name: "skipSection",
      description:
        "skips this area of the webpage because the current goal cannot be accomplished here",
      parameters: {
        type: "object",
        properties: {
          reason: {
            type: "string",
            description: "reason that no action is taken",
          },
        },
      },
    },
  },
];

// extract
export function buildExtractSystemPrompt(
  isUsingPrintExtractedDataTool: boolean = false,
  useTextExtract: boolean = true,
): ChatMessage {
  const baseContent = `You are extracting content on behalf of a user.
  If a user asks you to extract a 'list' of information, or 'all' information, 
  YOU MUST EXTRACT ALL OF THE INFORMATION THAT THE USER REQUESTS.
   
  You will be given:
1. An instruction
2. `;

  const contentDetail = useTextExtract
    ? `A text representation of a webpage to extract information from.`
    : `A list of DOM elements to extract from.`;

  const instructions = `
Print the exact text from the ${
    useTextExtract ? "text-rendered webpage" : "DOM elements"
  } with all symbols, characters, and endlines as is.
Print null or an empty string if no new information is found.
  `.trim();

  const toolInstructions = isUsingPrintExtractedDataTool
    ? `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.
  `.trim()
    : "";

  const additionalInstructions = useTextExtract
    ? `Once you are given the text-rendered webpage, 
    you must thoroughly and meticulously analyze it. Be very careful to ensure that you
    do not miss any important information.`
    : "";

  const content =
    `${baseContent}${contentDetail}\n\n${instructions}\n${toolInstructions}${
      additionalInstructions ? `\n\n${additionalInstructions}` : ""
    }`.replace(/\s+/g, " ");

  return {
    role: "system",
    content,
  };
}

export function buildExtractUserPrompt(
  instruction: string,
  domElements: string,
  isUsingPrintExtractedDataTool: boolean = false,
): ChatMessage {
  let content = `Instruction: ${instruction}
DOM: ${domElements}`;

  if (isUsingPrintExtractedDataTool) {
    content += `
ONLY print the content using the print_extracted_data tool provided.
ONLY print the content using the print_extracted_data tool provided.`;
  }

  return {
    role: "user",
    content,
  };
}

const refineSystemPrompt = `You are tasked with refining and filtering information for the final output based on newly extracted and previously extracted content. Your responsibilities are:
1. Remove exact duplicates for elements in arrays and objects.
2. For text fields, append or update relevant text if the new content is an extension, replacement, or continuation.
3. For non-text fields (e.g., numbers, booleans), update with new values if they differ.
4. Add any completely new fields or objects.

Return the updated content that includes both the previous content and the new, non-duplicate, or extended information.`;

export function buildRefineSystemPrompt(): ChatMessage {
  return {
    role: "system",
    content: refineSystemPrompt,
  };
}

export function buildRefineUserPrompt(
  instruction: string,
  previouslyExtractedContent: object,
  newlyExtractedContent: object,
): ChatMessage {
  return {
    role: "user",
    content: `Instruction: ${instruction}
Previously extracted content: ${JSON.stringify(previouslyExtractedContent, null, 2)}
Newly extracted content: ${JSON.stringify(newlyExtractedContent, null, 2)}
Refined content:`,
  };
}

const metadataSystemPrompt = `You are an AI assistant tasked with evaluating the progress and completion status of an extraction task.
Analyze the extraction response and determine if the task is completed or if more information is needed.

Strictly abide by the following criteria:
1. Once the instruction has been satisfied by the current extraction response, ALWAYS set completion status to true and stop processing, regardless of remaining chunks.
2. Only set completion status to false if BOTH of these conditions are true:
   - The instruction has not been satisfied yet
   - There are still chunks left to process (chunksTotal > chunksSeen)`;

export function buildMetadataSystemPrompt(): ChatMessage {
  return {
    role: "system",
    content: metadataSystemPrompt,
  };
}

export function buildMetadataPrompt(
  instruction: string,
  extractionResponse: object,
  chunksSeen: number,
  chunksTotal: number,
): ChatMessage {
  return {
    role: "user",
    content: `Instruction: ${instruction}
Extracted content: ${JSON.stringify(extractionResponse, null, 2)}
chunksSeen: ${chunksSeen}
chunksTotal: ${chunksTotal}`,
  };
}

// observe
const observeSystemPrompt = `
You are helping the user automate the browser by finding elements based on what the user wants to observe in the page.
You will be given:
1. a instruction of elements to observe
2. a numbered list of possible elements or an annotated image of the page

Return an array of elements that match the instruction.
`;
export function buildObserveSystemPrompt(): ChatMessage {
  const content = observeSystemPrompt.replace(/\s+/g, " ");

  return {
    role: "system",
    content,
  };
}

export function buildObserveUserMessage(
  instruction: string,
  domElements: string,
): ChatMessage {
  return {
    role: "user",
    content: `instruction: ${instruction}
DOM: ${domElements}`,
  };
}

// ask
const askSystemPrompt = `
you are a simple question answering assistent given the user's question. respond with only the answer.
`;
export function buildAskSystemPrompt(): ChatMessage {
  return {
    role: "system",
    content: askSystemPrompt,
  };
}

export function buildAskUserPrompt(question: string): ChatMessage {
  return {
    role: "user",
    content: `question: ${question}`,
  };
}

================
File: lib/StagehandContext.ts
================
import type { BrowserContext as PlaywrightContext } from "@playwright/test";
import { Stagehand } from "./index";

export class StagehandContext {
  private readonly stagehand: Stagehand;
  private readonly intContext: PlaywrightContext;

  private constructor(context: PlaywrightContext, stagehand: Stagehand) {
    this.intContext = context;
    this.stagehand = stagehand;
  }

  static async init(
    context: PlaywrightContext,
    stagehand: Stagehand,
  ): Promise<StagehandContext> {
    const proxyContext = new Proxy(context, {
      get: (target, prop) => {
        return target[prop as keyof PlaywrightContext];
      },
    });
    const instance = new StagehandContext(proxyContext, stagehand);
    return instance;
  }

  public get context(): PlaywrightContext {
    return this.intContext;
  }
}

================
File: lib/StagehandPage.ts
================
import type {
  Page as PlaywrightPage,
  BrowserContext as PlaywrightContext,
} from "@playwright/test";
import { LLMClient } from "./llm/LLMClient";
import { ActOptions, ActResult, GotoOptions, Stagehand } from "./index";
import { StagehandActHandler } from "./handlers/actHandler";
import { StagehandContext } from "./StagehandContext";
import { Page } from "../types/page";
import {
  ExtractOptions,
  ExtractResult,
  ObserveOptions,
  ObserveResult,
} from "../types/stagehand";
import { z } from "zod";
import { StagehandExtractHandler } from "./handlers/extractHandler";
import { StagehandObserveHandler } from "./handlers/observeHandler";

export class StagehandPage {
  private stagehand: Stagehand;
  private intPage: Page;
  private intContext: StagehandContext;
  private actHandler: StagehandActHandler;
  private extractHandler: StagehandExtractHandler;
  private observeHandler: StagehandObserveHandler;
  private llmClient: LLMClient;

  constructor(
    page: PlaywrightPage,
    stagehand: Stagehand,
    context: StagehandContext,
    llmClient: LLMClient,
  ) {
    this.intPage = Object.assign(page, {
      act: () => {
        throw new Error("act() is not implemented on the base page object");
      },
      extract: () => {
        throw new Error("extract() is not implemented on the base page object");
      },
      observe: () => {
        throw new Error("observe() is not implemented on the base page object");
      },
    });
    this.stagehand = stagehand;
    this.intContext = context;
    this.actHandler = new StagehandActHandler({
      verbose: this.stagehand.verbose,
      llmProvider: this.stagehand.llmProvider,
      enableCaching: this.stagehand.enableCaching,
      logger: this.stagehand.logger,
      stagehandPage: this,
      stagehandContext: this.intContext,
      llmClient: llmClient,
    });
    this.extractHandler = new StagehandExtractHandler({
      stagehand: this.stagehand,
      logger: this.stagehand.logger,
      stagehandPage: this,
    });
    this.observeHandler = new StagehandObserveHandler({
      stagehand: this.stagehand,
      logger: this.stagehand.logger,
      stagehandPage: this,
    });
    this.llmClient = llmClient;
  }

  async init(): Promise<StagehandPage> {
    const page = this.intPage;
    const stagehand = this.stagehand;
    this.intPage = new Proxy(page, {
      get: (target, prop) => {
        // Override the goto method to add debugDom and waitForSettledDom
        if (prop === "goto")
          return async (url: string, options: GotoOptions) => {
            const result = await page.goto(url, options);
            if (stagehand.debugDom) {
              await page.evaluate(
                (debugDom) => (window.showChunks = debugDom),
                stagehand.debugDom,
              );
            }
            await this.intPage.waitForLoadState("domcontentloaded");
            await this._waitForSettledDom();
            return result;
          };

        if (prop === "act") {
          return async (options: ActOptions) => {
            return this.act(options);
          };
        }

        if (prop === "extract") {
          return async (options: ExtractOptions<z.AnyZodObject>) => {
            return this.extract(options);
          };
        }

        if (prop === "observe") {
          return async (options: ObserveOptions) => {
            return this.observe(options);
          };
        }

        return target[prop as keyof PlaywrightPage];
      },
    });
    await this._waitForSettledDom();
    return this;
  }

  public get page(): Page {
    return this.intPage;
  }

  public get context(): PlaywrightContext {
    return this.intContext.context;
  }

  // We can make methods public because StagehandPage is private to the Stagehand class.
  // When a user gets stagehand.page, they are getting a proxy to the Playwright page.
  // We can override the methods on the proxy to add our own behavior
  public async _waitForSettledDom(timeoutMs?: number) {
    try {
      const timeout = timeoutMs ?? this.stagehand.domSettleTimeoutMs;
      let timeoutHandle: NodeJS.Timeout;

      await this.page.waitForLoadState("domcontentloaded");

      const timeoutPromise = new Promise<void>((resolve) => {
        timeoutHandle = setTimeout(() => {
          this.stagehand.log({
            category: "dom",
            message: "DOM settle timeout exceeded, continuing anyway",
            level: 1,
            auxiliary: {
              timeout_ms: {
                value: timeout.toString(),
                type: "integer",
              },
            },
          });
          resolve();
        }, timeout);
      });

      try {
        await Promise.race([
          this.page.evaluate(() => {
            return new Promise<void>((resolve) => {
              if (typeof window.waitForDomSettle === "function") {
                window.waitForDomSettle().then(resolve);
              } else {
                console.warn(
                  "waitForDomSettle is not defined, considering DOM as settled",
                );
                resolve();
              }
            });
          }),
          this.page.waitForLoadState("domcontentloaded"),
          this.page.waitForSelector("body"),
          timeoutPromise,
        ]);
      } finally {
        clearTimeout(timeoutHandle!);
      }
    } catch (e) {
      this.stagehand.log({
        category: "dom",
        message: "Error in waitForSettledDom",
        level: 1,
        auxiliary: {
          error: {
            value: e.message,
            type: "string",
          },
          trace: {
            value: e.stack,
            type: "string",
          },
        },
      });
    }
  }

  public async startDomDebug() {
    if (this.stagehand.debugDom) {
      try {
        await this.page
          .evaluate(() => {
            if (typeof window.debugDom === "function") {
              window.debugDom();
            } else {
              this.stagehand.log({
                category: "dom",
                message: "debugDom is not defined",
                level: 1,
              });
            }
          })
          .catch(() => {});
      } catch (e) {
        this.stagehand.log({
          category: "dom",
          message: "Error in startDomDebug",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
          },
        });
      }
    }
  }

  public async cleanupDomDebug() {
    if (this.stagehand.debugDom) {
      await this.page.evaluate(() => window.cleanupDebug()).catch(() => {});
    }
  }

  async act({
    action,
    modelName,
    modelClientOptions,
    useVision = "fallback",
    variables = {},
    domSettleTimeoutMs,
  }: ActOptions): Promise<ActResult> {
    if (!this.actHandler) {
      throw new Error("Act handler not initialized");
    }

    useVision = useVision ?? "fallback";
    const requestId = Math.random().toString(36).substring(2);
    const llmClient: LLMClient = modelName
      ? this.stagehand.llmProvider.getClient(modelName, modelClientOptions)
      : this.llmClient;

    this.stagehand.log({
      category: "act",
      message: "running act",
      level: 1,
      auxiliary: {
        action: {
          value: action,
          type: "string",
        },
        requestId: {
          value: requestId,
          type: "string",
        },
        modelName: {
          value: llmClient.modelName,
          type: "string",
        },
      },
    });

    return this.actHandler
      .act({
        action,
        llmClient,
        chunksSeen: [],
        useVision,
        verifierUseVision: useVision !== false,
        requestId,
        variables,
        previousSelectors: [],
        skipActionCacheForThisStep: false,
        domSettleTimeoutMs,
      })
      .catch((e) => {
        this.stagehand.log({
          category: "act",
          message: "error acting",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
          },
        });

        return {
          success: false,
          message: `Internal error: Error acting: ${e.message}`,
          action: action,
        };
      });
  }

  async extract<T extends z.AnyZodObject>({
    instruction,
    schema,
    modelName,
    modelClientOptions,
    domSettleTimeoutMs,
    useTextExtract,
  }: ExtractOptions<T>): Promise<ExtractResult<T>> {
    if (!this.extractHandler) {
      throw new Error("Extract handler not initialized");
    }

    const requestId = Math.random().toString(36).substring(2);
    const llmClient = modelName
      ? this.stagehand.llmProvider.getClient(modelName, modelClientOptions)
      : this.llmClient;

    this.stagehand.log({
      category: "extract",
      message: "running extract",
      level: 1,
      auxiliary: {
        instruction: {
          value: instruction,
          type: "string",
        },
        requestId: {
          value: requestId,
          type: "string",
        },
        modelName: {
          value: llmClient.modelName,
          type: "string",
        },
      },
    });

    return this.extractHandler
      .extract({
        instruction,
        schema,
        llmClient,
        requestId,
        domSettleTimeoutMs,
        useTextExtract,
      })
      .catch((e) => {
        this.stagehand.log({
          category: "extract",
          message: "error extracting",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
          },
        });

        if (this.stagehand.enableCaching) {
          this.stagehand.llmProvider.cleanRequestCache(requestId);
        }

        throw e;
      });
  }

  async observe(options?: ObserveOptions): Promise<ObserveResult[]> {
    if (!this.observeHandler) {
      throw new Error("Observe handler not initialized");
    }

    const requestId = Math.random().toString(36).substring(2);
    const llmClient = options?.modelName
      ? this.stagehand.llmProvider.getClient(
          options.modelName,
          options.modelClientOptions,
        )
      : this.llmClient;

    this.stagehand.log({
      category: "observe",
      message: "running observe",
      level: 1,
      auxiliary: {
        instruction: {
          value: options?.instruction,
          type: "string",
        },
        requestId: {
          value: requestId,
          type: "string",
        },
        modelName: {
          value: llmClient.modelName,
          type: "string",
        },
      },
    });

    return this.observeHandler
      .observe({
        instruction:
          options?.instruction ??
          "Find actions that can be performed on this page.",
        llmClient,
        useVision: options?.useVision ?? false,
        fullPage: false,
        requestId,
        domSettleTimeoutMs: options?.domSettleTimeoutMs,
      })
      .catch((e) => {
        this.stagehand.log({
          category: "observe",
          message: "error observing",
          level: 1,
          auxiliary: {
            error: {
              value: e.message,
              type: "string",
            },
            trace: {
              value: e.stack,
              type: "string",
            },
            requestId: {
              value: requestId,
              type: "string",
            },
            instruction: {
              value: options?.instruction,
              type: "string",
            },
          },
        });

        if (this.stagehand.enableCaching) {
          this.stagehand.llmProvider.cleanRequestCache(requestId);
        }

        throw e;
      });
  }
}

================
File: lib/utils.ts
================
import crypto from "crypto";
import { LogLine } from "../types/log";
import { TextAnnotation } from "../types/textannotation";
import { z } from "zod";

export function generateId(operation: string) {
  return crypto.createHash("sha256").update(operation).digest("hex");
}

/**
 * `formatText` converts a list of text annotations into a formatted text representation.
 * Each annotation represents a piece of text at a certain position on a webpage.
 * The formatting attempts to reconstruct a textual "screenshot" of the page by:
 * - Grouping annotations into lines based on their vertical positions.
 * - Adjusting spacing to reflect line gaps.
 * - Attempting to preserve relative positions and formatting.
 *
 * The output is a text block, optionally surrounded by lines of dashes, that aims
 * to closely mirror the visual layout of the text on the page.
 *
 * @param textAnnotations - An array of TextAnnotations describing text and their positions.
 * @param pageWidth - The width of the page in pixels, used to normalize positions.
 * @returns A string representing the text layout of the page.
 */
export function formatText(
  textAnnotations: TextAnnotation[],
  pageWidth: number,
): string {
  // **1:** Estimate the average character width in pixels by examining the text annotations.
  // If no reliable measurement is found, default to 10 pixels per character.
  const charWidth = estimateCharacterWidth(textAnnotations) || 10;

  // **2:** Create a copy of textAnnotations and sort them by their vertical position (y-coordinate),
  // ensuring that topmost annotations appear first and bottommost appear last.
  const sortedAnnotations = [...textAnnotations].sort(
    (a, b) => a.bottom_left.y - b.bottom_left.y,
  );

  // **3:** Group annotations by their line position. We use a small epsilon to handle
  // floating-point differences. Two annotations are considered on the same line if their
  // y-coordinates differ by less than epsilon.
  const epsilon = 0.0001;
  const lineMap: Map<number, TextAnnotation[]> = new Map();

  for (const annotation of sortedAnnotations) {
    let foundLineY: number | undefined;

    // **4:** Check if the annotation belongs to an existing line group.
    // If so, add it to that line. Otherwise, start a new line group.
    for (const key of lineMap.keys()) {
      if (Math.abs(key - annotation.bottom_left.y) < epsilon) {
        foundLineY = key;
        break;
      }
    }

    if (foundLineY !== undefined) {
      lineMap.get(foundLineY)!.push(annotation);
    } else {
      lineMap.set(annotation.bottom_left.y, [annotation]);
    }
  }

  // **5:** Extract all line keys (y-coordinates) and sort them to process lines top-to-bottom.
  const lineYs = Array.from(lineMap.keys()).sort((a, b) => a - b);

  // **6:** For each line, group words together and calculate the maximum normalized end position (maxNormalizedEndX).
  // This will help determine the necessary canvas width to accommodate all text.
  let maxNormalizedEndX = 0;
  const finalLines: TextAnnotation[][] = [];

  for (const lineY of lineYs) {
    const lineAnnotations = lineMap.get(lineY)!;

    // **7:** Sort annotations in the current line by their horizontal position (x-coordinate),
    // ensuring left-to-right ordering.
    lineAnnotations.sort((a, b) => a.bottom_left.x - b.bottom_left.x);

    // **8:** Group nearby annotations into word clusters, forming logical sentences or phrases.
    const groupedLineAnnotations = groupWordsInSentence(lineAnnotations);

    // **9:** Determine how far to the right the text in this line extends, normalized by page width.
    // Update maxNormalizedEndX to track the widest line encountered.
    for (const ann of groupedLineAnnotations) {
      const textLengthInPx = ann.text.length * charWidth;
      const normalizedTextLength = textLengthInPx / pageWidth;
      const endX = ann.bottom_left_normalized.x + normalizedTextLength;
      if (endX > maxNormalizedEndX) {
        maxNormalizedEndX = endX;
      }
    }

    // **10:** Save the processed line to finalLines for later rendering.
    finalLines.push(groupedLineAnnotations);
  }

  // **11:** Determine the canvas width in characters. We scale according to maxNormalizedEndX and page width.
  // Add a small buffer (20 chars) to ensure no text overflows the canvas.
  let canvasWidth = Math.ceil(maxNormalizedEndX * (pageWidth / charWidth)) + 20;
  canvasWidth = Math.max(canvasWidth, 1);

  // **12:** Compute the baseline (lowest point) of each line. This helps us understand vertical spacing.
  const lineBaselines = finalLines.map((line) =>
    Math.min(...line.map((a) => a.bottom_left.y)),
  );

  // **13:** Compute vertical gaps between consecutive lines to determine line spacing.
  const verticalGaps: number[] = [];
  for (let i = 1; i < lineBaselines.length; i++) {
    verticalGaps.push(lineBaselines[i] - lineBaselines[i - 1]);
  }

  // **14:** Estimate what a "normal" line spacing is by taking the median of all vertical gaps.
  const normalLineSpacing = verticalGaps.length > 0 ? median(verticalGaps) : 0;

  // **15:** Create a 2D character canvas initialized with spaces, onto which we'll "print" text lines.
  let canvas: string[][] = [];

  // **16:** lineIndex represents the current line of the canvas. Initialize with -1 so the first line starts at 0.
  let lineIndex = -1;

  // **17:** Iterate over each line of processed text.
  for (let i = 0; i < finalLines.length; i++) {
    if (i === 0) {
      // **18:** For the first line, just increment lineIndex to start at 0 with no extra spacing.
      lineIndex++;
      ensureLineExists(canvas, lineIndex, canvasWidth);
    } else {
      // **19:** For subsequent lines, calculate how many extra blank lines to insert based on spacing.
      const gap = lineBaselines[i] - lineBaselines[i - 1];

      let extraLines = 0;
      // **20:** If we have a known normal line spacing, and the gap is larger than expected,
      // insert extra blank lines proportional to the ratio of gap to normal spacing.
      if (normalLineSpacing > 0) {
        if (gap > 1.2 * normalLineSpacing) {
          extraLines = Math.max(Math.round(gap / normalLineSpacing) - 1, 0);
        }
      }

      // **21:** Insert the calculated extra blank lines to maintain approximate vertical spacing.
      for (let e = 0; e < extraLines; e++) {
        lineIndex++;
        ensureLineExists(canvas, lineIndex, canvasWidth);
      }

      // **22:** After adjusting for spacing, increment lineIndex for the current line of text.
      lineIndex++;
      ensureLineExists(canvas, lineIndex, canvasWidth);
    }

    // **23:** Now place the annotations for the current line onto the canvas at the appropriate horizontal positions.
    const lineAnnotations = finalLines[i];
    for (const annotation of lineAnnotations) {
      const text = annotation.text;
      // **24:** Calculate the starting x-position in the canvas based on normalized coordinates.
      const startXInChars = Math.round(
        annotation.bottom_left_normalized.x * canvasWidth,
      );

      // **25:** Place each character of the annotation text into the canvas.
      for (let j = 0; j < text.length; j++) {
        const xPos = startXInChars + j;
        // **26:** Ensure we don't exceed the canvas width.
        if (xPos < canvasWidth) {
          canvas[lineIndex][xPos] = text[j];
        }
      }
    }
  }

  // **27:** Trim trailing whitespace from each line to create a cleaner output.
  canvas = canvas.map((row) => {
    const lineStr = row.join("");
    return Array.from(lineStr.trimEnd());
  });

  // **29:** Join all lines to form the final page text. Trim any trailing whitespace from the entire text.
  let pageText = canvas.map((line) => line.join("")).join("\n");
  pageText = pageText.trimEnd();

  // **30:** Surround the page text with lines of dashes to clearly delineate the text block.
  pageText =
    "-".repeat(canvasWidth) + "\n" + pageText + "\n" + "-".repeat(canvasWidth);

  // **31:** Return the fully formatted text.
  return pageText;
}

/**
 * `ensureLineExists` ensures that a specified line index exists in the canvas.
 * If the canvas is not long enough, it extends it by adding new empty lines (filled with spaces).
 * This function is used to dynamically grow the canvas as we progress through the lines.
 *
 * @param canvas - The 2D character canvas array.
 * @param lineIndex - The desired line index that must exist.
 * @param width - The width of each line in characters.
 */
function ensureLineExists(
  canvas: string[][],
  lineIndex: number,
  width: number,
) {
  // loop until the canvas has at least lineIndex+1 lines.
  // each new line is filled with spaces to match the required width.
  while (lineIndex >= canvas.length) {
    canvas.push(new Array(width).fill(" "));
  }
}

/**
 * `estimateCharacterWidth` estimates the average character width (in pixels) from a collection of text annotations.
 * It calculates the width per character for each annotation and uses their median as the result.
 * If no annotations are available or they have zero-length text, returns 0.
 *
 * @param textAnnotations - An array of text annotations with text and width fields.
 * @returns The median character width in pixels, or 0 if none can be calculated.
 */
function estimateCharacterWidth(textAnnotations: TextAnnotation[]): number {
  // collect width-per-character measurements from each annotation
  const charWidths: number[] = [];
  for (const annotation of textAnnotations) {
    const length = annotation.text.length;
    if (length > 0) {
      charWidths.push(annotation.width / length);
    }
  }

  // return the median of all collected measurements
  return median(charWidths);
}

/**
 * `groupWordsInSentence` groups annotations within a single line into logical "words" or "sentences".
 * It uses a set of heuristics involving horizontal proximity and similar height
 * to decide when to join multiple annotations into a single grouped annotation.
 *
 * @param lineAnnotations - An array of annotations from a single line of text.
 * @returns An array of grouped annotations, where each represents one concatenated piece of text.
 */
function groupWordsInSentence(
  lineAnnotations: TextAnnotation[],
): TextAnnotation[] {
  const groupedAnnotations: TextAnnotation[] = [];
  let currentGroup: TextAnnotation[] = [];

  for (const annotation of lineAnnotations) {
    // if the current group is empty, start a new group with this annotation
    if (currentGroup.length === 0) {
      currentGroup.push(annotation);
      continue;
    }

    // determine horizontal grouping criteria
    // use a padding factor to allow slight spaces between words
    const padding = 2;
    const lastAnn = currentGroup[currentGroup.length - 1];
    const characterWidth = (lastAnn.width / lastAnn.text.length) * padding;
    const isWithinHorizontalRange =
      annotation.bottom_left.x <=
      lastAnn.bottom_left.x + lastAnn.width + characterWidth;

    // check if the annotation can be grouped with the current group.
    // conditions:
    // 1. the height difference from the group's first annotation is ≤ 4 units
    // 2. the annotation is horizontally close to the last annotation in the group
    if (
      Math.abs(annotation.height - currentGroup[0].height) <= 4 &&
      isWithinHorizontalRange
    ) {
      // if it meets the criteria, add to the current group
      currentGroup.push(annotation);
    } else {
      // if it doesn't meet criteria:
      // 1. finalize the current group into a single grouped annotation,
      // 2. add it to groupedAnnotations,
      // 3. start a new group with the current annotation
      if (currentGroup.length > 0) {
        const groupedAnnotation = createGroupedAnnotation(currentGroup);
        groupedAnnotations.push(groupedAnnotation);
        currentGroup = [annotation];
      }
    }
  }

  // after processing all annotations, if there's a remaining group, finalize it too
  if (currentGroup.length > 0) {
    const groupedAnnotation = createGroupedAnnotation(currentGroup);
    groupedAnnotations.push(groupedAnnotation);
  }

  // return the final array of grouped annotations representing words or phrases
  return groupedAnnotations;
}

/**
 * `createGroupedAnnotation` combines a group of annotations into a single annotation by concatenating their text.
 * It also attempts to preserve formatting, such as marking bold text if the median height suggests emphasis.
 *
 * @param group - An array of annotations that should be merged into a single text element.
 * @returns A new TextAnnotation representing the combined text and averaged metrics from the group.
 */
function createGroupedAnnotation(group: TextAnnotation[]): TextAnnotation {
  // initialize an empty string to build the combined text.
  let text = "";

  // concatenate the text from each annotation in the group.
  // insert a space between words, except when punctuation directly follows a word
  for (const word of group) {
    if (
      [".", ",", '"', "'", ":", ";", "!", "?", "{", "}", "’", "”"].includes(
        word.text,
      )
    ) {
      text += word.text;
    } else {
      text += text !== "" ? " " + word.text : word.text;
    }
  }

  // determine if the combined text qualifies as a "word" (contains alphanumeric chars)
  // and whether its median height suggests emphasizing it (e.g., bold text).
  const isWord = /[a-zA-Z0-9]/.test(text);
  const medianHeight = median(group.map((word) => word.height));

  // if it's considered a word and tall enough, surround it with `**` for bold formatting.
  if (isWord && medianHeight > 25) {
    text = "**" + text + "**";
  }

  // return a new annotation that represents the merged group.
  // use the first annotation's coordinates and normalized positions as references,
  // and sum the widths of all annotations to get the total width.
  return {
    text: text,
    bottom_left: {
      x: group[0].bottom_left.x,
      y: group[0].bottom_left.y,
    },
    bottom_left_normalized: {
      x: group[0].bottom_left_normalized.x,
      y: group[0].bottom_left_normalized.y,
    },
    width: group.reduce((sum, a) => sum + a.width, 0),
    height: group[0].height,
  };
}

function median(values: number[]): number {
  if (values.length === 0) return 0;
  const sorted = [...values].sort((a, b) => a - b);
  const middle = Math.floor(sorted.length / 2);

  if (sorted.length % 2 === 0) {
    return (sorted[middle - 1] + sorted[middle]) / 2;
  } else {
    return sorted[middle];
  }
}

export function logLineToString(logLine: LogLine): string {
  try {
    const timestamp = logLine.timestamp || new Date().toISOString();
    if (logLine.auxiliary?.error) {
      return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message}\n ${logLine.auxiliary.error.value}\n ${logLine.auxiliary.trace.value}`;
    }
    return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message} ${
      logLine.auxiliary ? JSON.stringify(logLine.auxiliary) : ""
    }`;
  } catch (error) {
    console.error(`Error logging line:`, error);
    return "error logging line";
  }
}

export function validateZodSchema(schema: z.ZodTypeAny, data: unknown) {
  try {
    schema.parse(data);
    return true;
  } catch {
    return false;
  }
}

================
File: lib/vision.ts
================
import { Page } from "@playwright/test";
import { exec } from "child_process";
import fs from "fs";
import path from "path";
import sharp from "sharp";
import { LogLine } from "../types/log";
import { logLineToString } from "./utils";

type AnnotationBox = {
  x: number;
  y: number;
  width: number;
  height: number;
  id: string;
};

type NumberPosition = {
  x: number;
  y: number;
};

export class ScreenshotService {
  private page: Page;
  private selectorMap: Record<number, string[]>;
  private annotationBoxes: AnnotationBox[] = [];
  private numberPositions: NumberPosition[] = [];
  private isDebugEnabled: boolean;
  private verbose: 0 | 1 | 2;
  private externalLogger?: (logLine: LogLine) => void;

  constructor(
    page: Page,
    selectorMap: Record<number, string[]>,
    verbose: 0 | 1 | 2,
    externalLogger?: (logLine: LogLine) => void,
    isDebugEnabled: boolean = false,
  ) {
    this.page = page;
    this.selectorMap = selectorMap;
    this.isDebugEnabled = isDebugEnabled;
    this.verbose = verbose;
    this.externalLogger = externalLogger;
  }

  log(logLine: LogLine) {
    if (this.verbose >= logLine.level) {
      console.log(logLineToString(logLine));
    }
    if (this.externalLogger) {
      this.externalLogger(logLine);
    }
  }

  async getScreenshot(
    fullpage: boolean = true,
    quality?: number,
  ): Promise<Buffer> {
    if (quality && (quality < 0 || quality > 100)) {
      throw new Error("quality must be between 0 and 100");
    }

    return await this.page.screenshot({
      fullPage: fullpage,
      quality,
      type: "jpeg",
    });
  }

  async getScreenshotPixelCount(screenshot: Buffer): Promise<number> {
    const image = sharp(screenshot);
    const metadata = await image.metadata();

    if (!metadata.width || !metadata.height) {
      this.log({
        category: "screenshotService",
        message: "Unable to determine image dimensions.",
        level: 0,
        auxiliary: {
          width: {
            value: metadata.width?.toString() ?? "undefined",
            type: "string", // might be undefined
          },
          height: {
            value: metadata.height?.toString() ?? "undefined",
            type: "string", // might be undefined
          },
        },
      });
      throw new Error("Unable to determine image dimensions.");
    }

    const pixelCount = metadata.width * metadata.height;
    this.log({
      category: "screenshotService",
      message: "got screenshot pixel count",
      level: 1,
      auxiliary: {
        pixelCount: {
          value: pixelCount.toString(),
          type: "integer",
        },
      },
    });
    return pixelCount;
  }

  async getAnnotatedScreenshot(fullpage: boolean): Promise<Buffer> {
    this.annotationBoxes = [];
    this.numberPositions = [];

    const screenshot = await this.getScreenshot(fullpage);
    const image = sharp(screenshot);

    const { width, height } = await image.metadata();
    this.log({
      category: "screenshotService",
      message: "annotating screenshot",
      level: 2,
      auxiliary: {
        selectorMap: {
          value: JSON.stringify(this.selectorMap),
          type: "object",
        },
      },
    });

    const svgAnnotations = (
      await Promise.all(
        Object.entries(this.selectorMap).map(async ([id, selectors]) =>
          this.createElementAnnotation(id, selectors).catch((error: Error) => {
            this.log({
              category: "screenshotService",
              message:
                "warning: failed to create screenshot annotation for element",
              level: 2,
              auxiliary: {
                message: {
                  value: error.message,
                  type: "string",
                },
                trace: {
                  value: error.stack,
                  type: "string",
                },
              },
            });
          }),
        ),
      )
    ).filter((annotation) => annotation !== null);

    const scrollPosition = await this.page.evaluate(() => {
      return {
        scrollX: window.scrollX,
        scrollY: window.scrollY,
      };
    });

    const svg = `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" style="position:absolute;left:${-scrollPosition.scrollX}px;top:${-scrollPosition.scrollY}px;">
        ${svgAnnotations.join("")}
      </svg>
    `;

    const annotatedScreenshot = await image
      .composite([{ input: Buffer.from(svg), top: 0, left: 0 }])
      .toBuffer();

    if (this.isDebugEnabled) {
      await this.saveAndOpenScreenshot(annotatedScreenshot);
    }

    return annotatedScreenshot;
  }

  private async createElementAnnotation(
    id: string,
    selectors: string[],
  ): Promise<string> {
    try {
      let element = null;

      // Try each selector until one works
      const selectorPromises: Promise<Omit<AnnotationBox, "id"> | null>[] =
        selectors.map(async (selector) => {
          try {
            element = await this.page.locator(`xpath=${selector}`).first();
            const box = await element.boundingBox({ timeout: 5_000 });
            return box;
          } catch {
            return null;
          }
        });

      const boxes = await Promise.all(selectorPromises);
      const box = boxes.find((b) => b !== null);

      if (!box) {
        throw new Error(`Unable to create annotation for element ${id}`);
      }

      const scrollPosition = await this.page.evaluate(() => ({
        scrollX: window.scrollX,
        scrollY: window.scrollY,
      }));

      const adjustedBox = {
        x: box.x + scrollPosition.scrollX,
        y: box.y + scrollPosition.scrollY,
        width: box.width,
        height: box.height,
        id: id,
      };

      this.annotationBoxes.push(adjustedBox);

      const numberPosition = this.findNonOverlappingNumberPosition(adjustedBox);

      const circleRadius = 12;

      return `
        <rect x="${adjustedBox.x}" y="${adjustedBox.y}" width="${adjustedBox.width}" height="${adjustedBox.height}" 
              fill="none" stroke="red" stroke-width="2" />
        <circle cx="${numberPosition.x}" cy="${numberPosition.y}" r="${circleRadius}" fill="white" stroke="red" stroke-width="2" />
        <text x="${numberPosition.x}" y="${numberPosition.y}" fill="red" font-size="16" font-weight="bold" 
              text-anchor="middle" dominant-baseline="central">
          ${id}
        </text>
      `;
    } catch (error) {
      this.log({
        category: "screenshotService",
        message: "warning: failed to create annotation for element",
        level: 1,
        auxiliary: {
          element_id: {
            value: id,
            type: "string",
          },
          error: {
            value: error.message,
            type: "string",
          },
          trace: {
            value: error.stack,
            type: "string",
          },
        },
      });
      return "";
    }
  }

  private findNonOverlappingNumberPosition(box: AnnotationBox): NumberPosition {
    const circleRadius = 12;
    const position: NumberPosition = {
      x: box.x - circleRadius,
      y: box.y - circleRadius,
    };

    let attempts = 0;
    const maxAttempts = 10;
    const offset = 5;

    while (this.isNumberOverlapping(position) && attempts < maxAttempts) {
      position.y += offset;
      attempts++;
    }

    this.numberPositions.push(position);
    return position;
  }

  private isNumberOverlapping(position: NumberPosition): boolean {
    const circleRadius = 12;
    return this.numberPositions.some(
      (existingPosition) =>
        Math.sqrt(
          Math.pow(position.x - existingPosition.x, 2) +
            Math.pow(position.y - existingPosition.y, 2),
        ) <
        circleRadius * 2,
    );
  }

  async saveAndOpenScreenshot(screenshot: Buffer): Promise<void> {
    const screenshotDir = path.join(process.cwd(), "screenshots");
    if (!fs.existsSync(screenshotDir)) {
      fs.mkdirSync(screenshotDir);
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filename = path.join(screenshotDir, `screenshot-${timestamp}.png`);

    fs.writeFileSync(filename, screenshot);
    this.log({
      category: "screenshotService",
      message: "screenshot saved",
      level: 1,
      auxiliary: {
        filename: {
          value: filename,
          type: "string",
        },
      },
    });

    // Open the screenshot with the default image viewer
    if (process.platform === "win32") {
      exec(`start ${filename}`);
    } else if (process.platform === "darwin") {
      exec(`open ${filename}`);
    } else {
      exec(`xdg-open ${filename}`);
    }
  }
}

================
File: types/act.ts
================
import { Buffer } from "buffer";
import { LLMClient } from "../lib/llm/LLMClient";

export interface ActParams {
  action: string;
  steps?: string;
  domElements: string;
  llmClient: LLMClient;
  screenshot?: Buffer;
  retries?: number;
  logger: (message: { category?: string; message: string }) => void;
  requestId: string;
  variables?: Record<string, string>;
}

export interface ActResult {
  method: string;
  element: number;
  args: unknown[];
  completed: boolean;
  step: string;
  why?: string;
}

================
File: types/browser.ts
================
import { Browser, BrowserContext } from "@playwright/test";

export interface BrowserResult {
  env: "LOCAL" | "BROWSERBASE";
  browser?: Browser;
  context: BrowserContext;
  debugUrl?: string;
  sessionUrl?: string;
  contextPath?: string;
  sessionId?: string;
}

================
File: types/evals.ts
================
import { EvalLogger } from "../evals/logger";
import { AvailableModel } from "../types/model";
import { LogLine } from "../types/log";
import { z } from "zod";
import { EvalCase } from "braintrust";

export type EvalFunction = (args: {
  modelName: AvailableModel;
  logger: EvalLogger;
  useTextExtract: boolean;
}) => Promise<{
  _success: boolean;
  logs: LogLine[];
  debugUrl: string;
  sessionUrl: string;
  error?: unknown;
}>;

export const EvalCategorySchema = z.enum([
  "observe",
  "act",
  "combination",
  "extract",
  "experimental",
  "text_extract",
]);

export type EvalCategory = z.infer<typeof EvalCategorySchema>;
export interface EvalInput {
  name: string;
  modelName: AvailableModel;
}

export interface Testcase
  extends EvalCase<
    EvalInput,
    unknown,
    { model: AvailableModel; test: string }
  > {
  input: EvalInput;
  name: string;
  tags: string[];
  metadata: { model: AvailableModel; test: string };
  expected: unknown;
}

export interface SummaryResult {
  input: EvalInput;
  output: { _success: boolean };
  name: string;
  score: number;
}

export interface EvalArgs<TInput, TOutput, TExpected> {
  input: TInput;
  output: TOutput;
  expected: TExpected;
  metadata?: { model: AvailableModel; test: string };
}

export interface EvalResult {
  name: string;
  score: number;
}

export type LogLineEval = LogLine & {
  parsedAuxiliary?: string | object;
};

================
File: types/inference.ts
================
import { Buffer } from "buffer";
import { LLMClient } from "../lib/llm/LLMClient";
import { LLMProvider } from "../lib/llm/LLMProvider";

export interface VerifyActCompletionParams {
  goal: string;
  steps: string;
  llmProvider: LLMProvider;
  llmClient: LLMClient;
  screenshot?: Buffer;
  domElements?: string;
  logger: (message: { category?: string; message: string }) => void;
  requestId: string;
}

================
File: types/log.ts
================
export type LogLine = {
  id?: string;
  category?: string;
  message: string;
  level?: 0 | 1 | 2;
  timestamp?: string;
  auxiliary?: {
    [key: string]: {
      value: string;
      type: "object" | "string" | "html" | "integer" | "float" | "boolean";
    };
  };
};

================
File: types/model.ts
================
import type { ClientOptions as AnthropicClientOptions } from "@anthropic-ai/sdk";
import type { ClientOptions as OpenAIClientOptions } from "openai";
import { ChatCompletionTool as OpenAITool } from "openai/resources";
import { z } from "zod";

export const AvailableModelSchema = z.enum([
  "gpt-4o",
  "gpt-4o-mini",
  "gpt-4o-2024-08-06",
  "claude-3-5-sonnet-latest",
  "claude-3-5-sonnet-20241022",
  "claude-3-5-sonnet-20240620",
  "o1-mini",
  "o1-preview",
]);

export type AvailableModel = z.infer<typeof AvailableModelSchema>;

export type ModelProvider = "openai" | "anthropic";

export type ClientOptions = OpenAIClientOptions | AnthropicClientOptions;

export type ToolCall = OpenAITool;

export type AnthropicTransformedResponse = {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: {
    index: number;
    message: {
      role: string;
      content: string | null;
      tool_calls: {
        id: string;
        type: string;
        function: {
          name: string;
          arguments: string;
        };
      }[];
    };
    finish_reason: string;
  }[];
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
};

export interface AnthropicJsonSchemaObject {
  definitions?: {
    MySchema?: { properties?: Record<string, unknown>; required?: string[] };
  };
  properties?: Record<string, unknown>;
  required?: string[];
}

================
File: types/page.ts
================
import type { Page as PlaywrightPage } from "@playwright/test";
import type { BrowserContext as PlaywrightContext } from "@playwright/test";
import type { ActResult } from "./act";
import type {
  ActOptions,
  ExtractOptions,
  ExtractResult,
  ObserveOptions,
  ObserveResult,
} from "./stagehand";
import type { z } from "zod";
export interface Page extends PlaywrightPage {
  act: (options: ActOptions) => Promise<ActResult>;
  extract: <T extends z.AnyZodObject>(
    options: ExtractOptions<T>,
  ) => Promise<ExtractResult<T>>;
  observe: (options?: ObserveOptions) => Promise<ObserveResult[]>;
}

// Empty type for now, but will be used in the future
export type BrowserContext = PlaywrightContext;

================
File: types/playwright.ts
================
export class PlaywrightCommandException extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PlaywrightCommandException";
  }
}

export class PlaywrightCommandMethodNotSupportedException extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PlaywrightCommandMethodNotSupportedException";
  }
}

export interface GotoOptions {
  timeout?: number;
  waitUntil?: "load" | "domcontentloaded" | "networkidle" | "commit";
  referer?: string;
}

================
File: types/stagehand.ts
================
import Browserbase from "@browserbasehq/sdk";
import { BrowserContext, Page } from "@playwright/test";
import { z } from "zod";
import { LLMProvider } from "../lib/llm/LLMProvider";
import { LogLine } from "./log";
import { AvailableModel, ClientOptions } from "./model";

export interface ConstructorParams {
  env: "LOCAL" | "BROWSERBASE";
  apiKey?: string;
  projectId?: string;
  verbose?: 0 | 1 | 2;
  debugDom?: boolean;
  llmProvider?: LLMProvider;
  headless?: boolean;
  logger?: (message: LogLine) => void | Promise<void>;
  domSettleTimeoutMs?: number;
  browserbaseSessionCreateParams?: Browserbase.Sessions.SessionCreateParams;
  enableCaching?: boolean;
  browserbaseSessionID?: string;
  modelName?: AvailableModel;
  modelClientOptions?: ClientOptions;
}

export interface InitOptions {
  /** @deprecated Pass this into the Stagehand constructor instead. This will be removed in the next major version. */
  modelName?: AvailableModel;
  /** @deprecated Pass this into the Stagehand constructor instead. This will be removed in the next major version. */
  modelClientOptions?: ClientOptions;
  /** @deprecated Pass this into the Stagehand constructor instead. This will be removed in the next major version. */
  domSettleTimeoutMs?: number;
}

export interface InitResult {
  debugUrl: string;
  sessionUrl: string;
  sessionId: string;
}

export interface InitFromPageOptions {
  page: Page;
  /** @deprecated Pass this into the Stagehand constructor instead. This will be removed in the next major version. */
  modelName?: AvailableModel;
  /** @deprecated Pass this into the Stagehand constructor instead. This will be removed in the next major version. */
  modelClientOptions?: ClientOptions;
}

export interface InitFromPageResult {
  context: BrowserContext;
}

export interface ActOptions {
  action: string;
  modelName?: AvailableModel;
  modelClientOptions?: ClientOptions;
  useVision?: "fallback" | boolean;
  variables?: Record<string, string>;
  domSettleTimeoutMs?: number;
}

export interface ActResult {
  success: boolean;
  message: string;
  action: string;
}

export interface ExtractOptions<T extends z.AnyZodObject> {
  instruction: string;
  schema: T;
  modelName?: AvailableModel;
  modelClientOptions?: ClientOptions;
  domSettleTimeoutMs?: number;
  useTextExtract?: boolean;
}

export type ExtractResult<T extends z.AnyZodObject> = z.infer<T>;

export interface ObserveOptions {
  instruction?: string;
  modelName?: AvailableModel;
  modelClientOptions?: ClientOptions;
  useVision?: boolean;
  domSettleTimeoutMs?: number;
}

export interface ObserveResult {
  selector: string;
  description: string;
}

================
File: types/textannotation.ts
================
export type TextAnnotation = {
  text: string;
  bottom_left: { x: number; y: number };
  bottom_left_normalized: { x: number; y: number };
  width: number;
  height: number;
};

================
File: .env.example
================
OPENAI_API_KEY=""
BROWSERBASE_API_KEY=""
BRAINTRUST_API_KEY=""
ANTHROPIC_API_KEY=""
HEADLESS=false
ENABLE_CACHING=false
EVAL_MODELS="gpt-4o,claude-3-5-sonnet-latest"
EXPERIMENTAL_EVAL_MODELS="gpt-4o,claude-3-5-sonnet-latest,o1-mini,o1-preview"
EVAL_CATEGORIES="observe,act,combination,extract,experimental"

================
File: .gitignore
================
node_modules/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/
screenshot.png
.DS_STORE
.cache/
.env
downloads/
dist/
evals/**/public
lib/dom/build/
evals/public
*.tgz
evals/playground.ts
tmp/
eval-summary.json
pnpm-lock.yaml

================
File: .prettierignore
================
pnpm-lock.yaml

================
File: .prettierrc
================
{}

================
File: CHANGELOG.md
================
# @browserbasehq/stagehand

## 1.8.0

### Minor Changes

- [#324](https://github.com/browserbase/stagehand/pull/324) [`cd23fa3`](https://github.com/browserbase/stagehand/commit/cd23fa33450107f29cb1ddb6edadfc769d336aa5) Thanks [@kamath](https://github.com/kamath)! - Move stagehand.act() -> stagehand.page.act() and deprecate stagehand.act()

- [#319](https://github.com/browserbase/stagehand/pull/319) [`bacbe60`](https://github.com/browserbase/stagehand/commit/bacbe608058304bfa1f0ab049da4d8aa90e8d6f7) Thanks [@kamath](https://github.com/kamath)! - We now wrap playwright page/context within StagehandPage and StagehandContext objects. This helps us augment the Stagehand experience by being able to augment the underlying Playwright

- [#324](https://github.com/browserbase/stagehand/pull/324) [`cd23fa3`](https://github.com/browserbase/stagehand/commit/cd23fa33450107f29cb1ddb6edadfc769d336aa5) Thanks [@kamath](https://github.com/kamath)! - moves extract and act -> page and deprecates stagehand.extract and stagehand.observe

### Patch Changes

- [#320](https://github.com/browserbase/stagehand/pull/320) [`c0cdd0e`](https://github.com/browserbase/stagehand/commit/c0cdd0e985d66f0464d2e70b7d0cb343b0efbd3f) Thanks [@kamath](https://github.com/kamath)! - bug fix: set this.env to LOCAL if BROWSERBASE_API_KEY is not defined

- [#325](https://github.com/browserbase/stagehand/pull/325) [`cc46f34`](https://github.com/browserbase/stagehand/commit/cc46f345c0a1dc0af4abae7e207833df17da50e7) Thanks [@pkiv](https://github.com/pkiv)! - only start domdebug if enabled

## 1.7.0

### Minor Changes

- [#316](https://github.com/browserbase/stagehand/pull/316) [`902e633`](https://github.com/browserbase/stagehand/commit/902e633e126a58b80b757ea0ecada01a7675a473) Thanks [@kamath](https://github.com/kamath)! - rename browserbaseResumeSessionID -> browserbaseSessionID

- [#296](https://github.com/browserbase/stagehand/pull/296) [`f11da27`](https://github.com/browserbase/stagehand/commit/f11da27a20409c240ceeea2003d520f676def61a) Thanks [@kamath](https://github.com/kamath)! - - Deprecate fields in `init` in favor of constructor options

  - Deprecate `initFromPage` in favor of `browserbaseResumeSessionID` in constructor
  - Rename `browserBaseSessionCreateParams` -> `browserbaseSessionCreateParams`

- [#304](https://github.com/browserbase/stagehand/pull/304) [`0b72f75`](https://github.com/browserbase/stagehand/commit/0b72f75f6a62aaeb28b0c488ae96db098d6a2846) Thanks [@seanmcguire12](https://github.com/seanmcguire12)! - add textExtract: an optional, text based approach to the existing extract method. textExtract often performs better on long form extraction tasks. By default `extract` uses the existing approach `domExtract`.

- [#298](https://github.com/browserbase/stagehand/pull/298) [`55f0cd2`](https://github.com/browserbase/stagehand/commit/55f0cd2fe7976e800833ec6e41e9af62d88d09d5) Thanks [@kamath](https://github.com/kamath)! - Add sessionId to public params

### Patch Changes

- [#283](https://github.com/browserbase/stagehand/pull/283) [`b902192`](https://github.com/browserbase/stagehand/commit/b902192bc7ff8eb02c85150c1fe6f89c2a95b211) Thanks [@sameelarif](https://github.com/sameelarif)! - allowed customization of eval config via .env

- [#299](https://github.com/browserbase/stagehand/pull/299) [`fbe2300`](https://github.com/browserbase/stagehand/commit/fbe23007176488043c2415519f25021612fff989) Thanks [@sameelarif](https://github.com/sameelarif)! - log playwright actions for better debugging

## 1.6.0

### Minor Changes

- [#286](https://github.com/browserbase/stagehand/pull/286) [`9605836`](https://github.com/browserbase/stagehand/commit/9605836ee6b8207ed7dc9146e12ced1c78630d59) Thanks [@kamath](https://github.com/kamath)! - minor improvement in action + new eval case

- [#279](https://github.com/browserbase/stagehand/pull/279) [`d6d7057`](https://github.com/browserbase/stagehand/commit/d6d70570623a718354797ef83aa8489eacc085d1) Thanks [@kamath](https://github.com/kamath)! - Add support for o1-mini and o1-preview in OpenAIClient

- [#282](https://github.com/browserbase/stagehand/pull/282) [`5291797`](https://github.com/browserbase/stagehand/commit/529179724a53bf2fd578a4012fd6bc6b7348d1ae) Thanks [@kamath](https://github.com/kamath)! - Added eslint for stricter type checking. Streamlined most of the internal types throughout the cache, llm, and handlers. This should make it easier to add new LLMs down the line, maintain and update the existing code, and make it easier to add new features in the future. Types can be checked by running `npx eslint .` from the project directory.

### Patch Changes

- [#270](https://github.com/browserbase/stagehand/pull/270) [`6b10b3b`](https://github.com/browserbase/stagehand/commit/6b10b3b1160649b19f50d66588395ceb679b3d68) Thanks [@sameelarif](https://github.com/sameelarif)! - add close link to readme

- [#288](https://github.com/browserbase/stagehand/pull/288) [`5afa0b9`](https://github.com/browserbase/stagehand/commit/5afa0b940a9f379a3719a5bbae249dd2a9ef8380) Thanks [@kamath](https://github.com/kamath)! - add multi-region support for browserbase

- [#284](https://github.com/browserbase/stagehand/pull/284) [`474217c`](https://github.com/browserbase/stagehand/commit/474217cfaff8e68614212b66baa62d35493fd2ce) Thanks [@kamath](https://github.com/kamath)! - Build wasn't working, this addresses tsc failure.

- [#236](https://github.com/browserbase/stagehand/pull/236) [`85483fe`](https://github.com/browserbase/stagehand/commit/85483fe091544fc079015c62b6923b03f8b9caa7) Thanks [@seanmcguire12](https://github.com/seanmcguire12)! - reduce chunk size

## 1.5.0

### Minor Changes

- [#266](https://github.com/browserbase/stagehand/pull/266) [`0e8f34f`](https://github.com/browserbase/stagehand/commit/0e8f34fc15aee91c548d09534deaccc8adca7c4d) Thanks [@kamath](https://github.com/kamath)! - Install wasn't working from NPM due to misconfigured build step. This attempts to fix that.

## 1.4.0

### Minor Changes

- [#253](https://github.com/browserbase/stagehand/pull/253) [`598cae2`](https://github.com/browserbase/stagehand/commit/598cae230c7b8d4e31ae22fd63047a91b63e51b8) Thanks [@sameelarif](https://github.com/sameelarif)! - clean up contexts after use

### Patch Changes

- [#225](https://github.com/browserbase/stagehand/pull/225) [`a2366fe`](https://github.com/browserbase/stagehand/commit/a2366feb023180fbb2ccc7a8379692f9f8347fe5) Thanks [@sameelarif](https://github.com/sameelarif)! - Ensuring cross-platform compatibility with tmp directories

- [#249](https://github.com/browserbase/stagehand/pull/249) [`7d06d43`](https://github.com/browserbase/stagehand/commit/7d06d43f2b9a477fed35793d7479de9b183e8d53) Thanks [@seanmcguire12](https://github.com/seanmcguire12)! - fix broken evals

- [#227](https://github.com/browserbase/stagehand/pull/227) [`647eefd`](https://github.com/browserbase/stagehand/commit/647eefd651852eec495faa1b8f4dbe6b1da17999) Thanks [@kamath](https://github.com/kamath)! - Fix debugDom still showing chunks when set to false

- [#250](https://github.com/browserbase/stagehand/pull/250) [`5886620`](https://github.com/browserbase/stagehand/commit/5886620dd1b0a57c68bf810cf130df2ca0a50a69) Thanks [@seanmcguire12](https://github.com/seanmcguire12)! - add ci specific evals

- [#222](https://github.com/browserbase/stagehand/pull/222) [`8dff026`](https://github.com/browserbase/stagehand/commit/8dff02674df7a6448f2262c7e212b58c03be57bc) Thanks [@sameelarif](https://github.com/sameelarif)! - Streamline type definitions and fix existing typescript errors

- [#232](https://github.com/browserbase/stagehand/pull/232) [`b9f9949`](https://github.com/browserbase/stagehand/commit/b9f99494021e6a9e2487b77bb64ed0a491751400) Thanks [@kamath](https://github.com/kamath)! - Minor changes to package.json and tsconfig, mainly around the build process. Also add more type defs and remove unused dependencies.

## 1.3.0

### Minor Changes

- [#195](https://github.com/browserbase/stagehand/pull/195) [`87a6305`](https://github.com/browserbase/stagehand/commit/87a6305d9a2faf1ab5915965913bc14d5cc15772) Thanks [@kamath](https://github.com/kamath)! - - Adds structured and more standardized JSON logging
  - Doesn't init cache if `enableCaching` is false, preventing `tmp/.cache` from being created
  - Updates bundling for browser-side code to support NextJS and serverless

## 1.2.0

### Minor Changes

- [#179](https://github.com/browserbase/stagehand/pull/179) [`0031871`](https://github.com/browserbase/stagehand/commit/0031871d5a6d6180f272a68b88a8634e5a991785) Thanks [@navidkpr](https://github.com/navidkpr)! - Fixes:

  The last big change we pushed out, introduced a small regression. As a result, the gray outline showing the elements Stagehand is looking out is missing. This commit fixes that. We now process selectorMap properly now (using the updated type Record<number, string[]

  Improved the action prompt:

  Improved the structure
  Made it more straightforward
  Improved working for completed arg and prioritized precision over recall

## 1.1.0

### Minor Changes

- [`9206ec6`](https://github.com/browserbase/stagehand/commit/9206ec640b2d0af9170f0a31788ab1eac448357b) Thanks [@kamath](https://github.com/kamath)! - Connect to a minor session

================
File: eslint.config.mjs
================
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";

/** @type {import('eslint').Linter.Config[]} */
export default [
  { files: ["**/*.{js,mjs,cjs,ts}"] },
  { languageOptions: { globals: globals.browser } },
  { ignores: ["dist/**", "lib/dom/build/**"] },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
];

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Browserbase Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "@browserbasehq/stagehand",
  "version": "1.8.0",
  "description": "An AI web browsing framework focused on simplicity and extensibility.",
  "main": "./dist/index.js",
  "module": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "2048": "npm run build-dom-scripts && tsx examples/2048.ts",
    "example": "npm run build-dom-scripts && tsx examples/example.ts",
    "debug-url": "npm run build-dom-scripts && tsx examples/debugUrl.ts",
    "format": "prettier --write .",
    "prettier": "prettier --check .",
    "prettier:fix": "prettier --write .",
    "eslint": "eslint .",
    "cache:clear": "rm -rf .cache",
    "evals": "npm run build-dom-scripts && tsx evals/index.eval.ts",
    "e2e": "npm run build-dom-scripts && cd evals/deterministic && npx playwright test",
    "build-dom-scripts": "tsx lib/dom/genDomScripts.ts",
    "build-types": "tsc --emitDeclarationOnly --outDir dist",
    "build-js": "tsup lib/index.ts --dts",
    "build": "npm run lint && npm run build-dom-scripts && npm run build-js && npm run build-types",
    "lint": "npm run prettier && npm run eslint",
    "release": "npm run build && changeset publish",
    "release-canary": "npm run build && changeset version --snapshot && changeset publish --tag alpha"
  },
  "files": [
    "dist/**",
    "lib/**"
  ],
  "keywords": [],
  "author": "Browserbase",
  "license": "MIT",
  "devDependencies": {
    "@changesets/changelog-github": "^0.5.0",
    "@changesets/cli": "^2.27.9",
    "@eslint/js": "^9.16.0",
    "@types/adm-zip": "^0.5.7",
    "@types/cheerio": "^0.22.35",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.30",
    "@types/ws": "^8.5.13",
    "adm-zip": "^0.5.16",
    "autoevals": "^0.0.64",
    "braintrust": "^0.0.171",
    "cheerio": "^1.0.0",
    "chromium-bidi": "^0.10.0",
    "esbuild": "^0.21.4",
    "eslint": "^9.16.0",
    "express": "^4.21.0",
    "globals": "^15.13.0",
    "multer": "^1.4.5-lts.1",
    "prettier": "^3.2.5",
    "string-comparison": "^1.3.0",
    "tsup": "^8.2.1",
    "tsx": "^4.10.5",
    "typescript": "^5.2.2",
    "typescript-eslint": "^8.17.0"
  },
  "peerDependencies": {
    "@playwright/test": "^1.42.1",
    "deepmerge": "^4.3.1",
    "dotenv": "^16.4.5",
    "openai": "^4.62.1",
    "zod": "^3.23.8"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.27.3",
    "@browserbasehq/sdk": "^2.0.0",
    "sharp": "^0.33.5",
    "ws": "^8.18.0",
    "zod-to-json-schema": "^3.23.5"
  },
  "directories": {
    "doc": "docs",
    "example": "examples",
    "lib": "lib"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/browserbase/stagehand.git"
  },
  "bugs": {
    "url": "https://github.com/browserbase/stagehand/issues"
  },
  "homepage": "https://github.com/browserbase/stagehand#readme"
}

================
File: README.md
================
<div id="toc" align="center">
  <ul style="list-style: none">
    <summary>
      <h1> 🤘 Stagehand </h1>
    </summary>
  </ul>
</div>

<p align="center">
  An AI web browsing framework focused on simplicity and extensibility.</em>
</p>

<p align="center">
  <a href="https://www.npmjs.com/package/@browserbasehq/stagehand"><img alt="NPM" src="https://img.shields.io/npm/v/@browserbasehq/stagehand.svg" /></a>
  <a href="https://github.com/browserbase/stagehand/blob/main/license"><img alt="MIT License" src="https://img.shields.io/badge/license-MIT-blue" /></a>
  <a href="https://join.slack.com/t/stagehand-dev/shared_invite/zt-2tdncfgkk-fF8y5U0uJzR2y2_M9c9OJA"><img alt="Slack Community" src="https://img.shields.io/badge/slack-Join%20our%20community-FEC89A.svg?logo=slack" /></a>
</p>

---

- [Intro](#intro)
- [Getting Started](#getting-started)
- [API Reference](#api-reference)
  - [act()](#act)
  - [extract()](#extract)
  - [observe()](#observe)
  - [close()](#close)
- [Model Support](#model-support)
- [How It Works](#how-it-works)
- [Stagehand vs Playwright](#stagehand-vs-playwright)
- [Prompting Tips](#prompting-tips)
- [Roadmap](#roadmap)
- [Contributing](#contributing)
- [Acknowledgements](#acknowledgements)
- [License](#license)

> [!NOTE]  
> `Stagehand` is currently available as an early release, and we're actively seeking feedback from the community. Please join our [Slack community](https://join.slack.com/t/stagehand-dev/shared_invite/zt-2tdncfgkk-fF8y5U0uJzR2y2_M9c9OJA) to stay updated on the latest developments and provide feedback.

## Intro

Stagehand is the AI-powered successor to [Playwright](https://github.com/microsoft/playwright), offering three simple APIs (`act`, `extract`, and `observe`) that provide the building blocks for natural language driven web automation.

The goal of Stagehand is to provide a lightweight, configurable framework, without overly complex abstractions, as well as modular support for different models and model providers. It's not going to order you a pizza, but it will help you reliably automate the web.

Each Stagehand function takes in an atomic instruction, such as `act("click the login button")` or `extract("find the red shoes")`, generates the appropriate Playwright code to accomplish that instruction, and executes it.

Instructions should be atomic to increase reliability, and step planning should be handled by the higher level agent. You can use `observe()` to get a suggested list of actions that can be taken on the current page, and then use those to ground your step planning prompts.

Stagehand is [open source](#license) and maintained by the [Browserbase](https://browserbase.com) team. We believe that by enabling more developers to build reliable web automations, we'll expand the market of developers who benefit from our headless browser infrastructure. This is the framework that we wished we had while tinkering on our own applications, and we're excited to share it with you.

## Getting Started

### 1. Install the Stagehand package

We also install zod to power typed extraction

```bash
npm install @browserbasehq/stagehand zod
```

### 2. Configure your model provider

You'll need to provide your API Key for the model provider you'd like to use. The default model provider is OpenAI, but you can also use Anthropic or others. More information on supported models can be found in the [API Reference](#api-reference).

Ensure that an OpenAI API Key or Anthropic API key is accessible in your local environment.

```
export OPENAI_API_KEY=sk-...
export ANTHROPIC_API_KEY=sk-...
```

### 3. Create a Stagehand Instance

If you plan to run the browser locally, you'll also need to install Playwright's browser dependencies.

```bash
npm exec playwright install
```

Then you can create a Stagehand instance like so:

```javascript
import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";

const stagehand = new Stagehand({
  env: "LOCAL",
});
```

If you plan to run the browser remotely, you'll need to set a Browserbase API Key and Project ID.

```bash
export BROWSERBASE_API_KEY=...
export BROWSERBASE_PROJECT_ID=...
```

```javascript
import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  enableCaching: true,
});
```

### 4. Run your first automation

```javascript
await stagehand.init();
const page = stagehand.page;
await page.goto("https://github.com/browserbase/stagehand");
await page.act({ action: "click on the contributors" });
const contributor = await page.extract({
  instruction: "extract the top contributor",
  schema: z.object({
    username: z.string(),
    url: z.string(),
  }),
});
await stagehand.close();
console.log(`Our favorite contributor is ${contributor.username}`);
```

This simple snippet will open a browser, navigate to the Stagehand repo, and log the top contributor.

## API Reference

### `Stagehand()`

This constructor is used to create an instance of Stagehand.

- **Arguments:**

  - `env`: `'LOCAL'` or `'BROWSERBASE'`. Defaults to `'BROWSERBASE'`.
  - `modelName`: (optional) an `AvailableModel` string to specify the default model to use.
  - `modelClientOptions`: (optional) configuration options for the model client.
  - `enableCaching`: a `boolean` that enables caching of LLM responses. When set to `true`, the LLM requests will be cached on disk and reused for identical requests. Defaults to `false`.
  - `headless`: a `boolean` that determines if the browser runs in headless mode. Defaults to `false`. When the env is set to `BROWSERBASE`, this will be ignored.
  - `domSettleTimeoutMs`: an `integer` that specifies the timeout in milliseconds for waiting for the DOM to settle. Defaults to 30000 (30 seconds).
  - `apiKey`: (optional) your Browserbase API key. Defaults to `BROWSERBASE_API_KEY` environment variable.
  - `projectId`: (optional) your Browserbase project ID. Defaults to `BROWSERBASE_PROJECT_ID` environment variable.
  - `browserbaseSessionCreateParams`: configuration options for creating new Browserbase sessions.
  - `browserbaseSessionID`: ID of an existing live Browserbase session. Overrides `browserbaseSessionCreateParams`.
  - `logger`: a function that handles log messages. Useful for custom logging implementations.
  - `verbose`: an `integer` that enables several levels of logging during automation:
    - `0`: limited to no logging
    - `1`: SDK-level logging
    - `2`: LLM-client level logging (most granular)
  - `debugDom`: a `boolean` that draws bounding boxes around elements presented to the LLM during automation.

- **Returns:**

  - An instance of the `Stagehand` class configured with the specified options.

- **Example:**

  ```javascript
  // Basic usage
  const stagehand = new Stagehand();

  // Custom configuration
  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1,
    headless: true,
    enableCaching: true,
    logger: (logLine) => {
      console.log(`[${logLine.category}] ${logLine.message}`);
    },
  });

  // Resume existing Browserbase session
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    browserbaseSessionID: "existing-session-id",
  });
  ```

### Methods

#### `init()`

`init()` asynchronously initializes the Stagehand instance. It should be called before any other methods.

> [!WARNING]  
> Passing parameters to `init()` is deprecated and will be removed in the next major version. Use the constructor options instead.

- **Arguments:**

  - `modelName`: (**deprecated**, optional) an `AvailableModel` string to specify the model to use. This will be used for all other methods unless overridden.
  - `modelClientOptions`: (**deprecated**, optional) configuration options for the model client
  - `domSettleTimeoutMs`: (**deprecated**, optional) timeout in milliseconds for waiting for the DOM to settle

- **Returns:**

  - A `Promise` that resolves to an object containing:
    - `debugUrl`: a `string` representing the URL for live debugging. This is only available when using a Browserbase browser.
    - `sessionUrl`: a `string` representing the session URL. This is only available when using a Browserbase browser.
    - `sessionId`: a `string` representing the session ID. This is only available when using a Browserbase browser.

- **Example:**
  ```javascript
  await stagehand.init();
  ```

#### `act()`

`act()` allows Stagehand to interact with a web page. Provide an `action` like `"search for 'x'"`, or `"select the cheapest flight presented"` (small atomic goals perform the best).

> [!WARNING]  
> `act()` on the Stagehand instance is deprecated and will be removed in the next major version. Use `stagehand.page.act()` instead.

- **Arguments:**

  - `action`: a `string` describing the action to perform
  - `modelName`: (optional) an `AvailableModel` string to specify the model to use
  - `modelClientOptions`: (optional) configuration options for the model client
  - `useVision`: (optional) a `boolean` or `"fallback"` to determine if vision-based processing should be used. Defaults to `"fallback"`
  - `variables`: (optional) a `Record<string, string>` of variables to use in the action. Variables in the action string are referenced using `%variable_name%`
  - `domSettleTimeoutMs`: (optional) timeout in milliseconds for waiting for the DOM to settle

- **Returns:**

  - A `Promise` that resolves to an object containing:
    - `success`: a `boolean` indicating if the action was completed successfully.
    - `message`: a `string` providing details about the action's execution.
    - `action`: a `string` describing the action performed.

- **Example:**

  ```javascript
  // Basic usage
  await stagehand.page.act({ action: "click on add to cart" });

  // Using variables
  await stagehand.page.act({
    action: "enter %username% into the username field",
    variables: {
      username: "john.doe@example.com",
    },
  });

  // Multiple variables
  await stagehand.page.act({
    action: "fill in the form with %username% and %password%",
    variables: {
      username: "john.doe",
      password: "secretpass123",
    },
  });
  ```

#### `extract()`

`extract()` grabs structured text from the current page using [zod](https://github.com/colinhacks/zod). Given instructions and `schema`, you will receive structured data. Unlike some extraction libraries, stagehand can extract any information on a page, not just the main article contents.

> [!WARNING]  
> `extract()` on the Stagehand instance is deprecated and will be removed in the next major version. Use `stagehand.page.extract()` instead.

- **Arguments:**

  - `instruction`: a `string` providing instructions for extraction
  - `schema`: a `z.AnyZodObject` defining the structure of the data to extract
  - `modelName`: (optional) an `AvailableModel` string to specify the model to use
  - `modelClientOptions`: (optional) configuration options for the model client
  - `domSettleTimeoutMs`: (optional) timeout in milliseconds for waiting for the DOM to settle
  - `useTextExtract`: (optional) a `boolean` to determine if text-based extraction should be used. Defaults to `false`

- **Returns:**

  - A `Promise` that resolves to the structured data as defined by the provided `schema`.

- **Example:**
  ```javascript
  const price = await stagehand.page.extract({
    instruction: "extract the price of the item",
    schema: z.object({
      price: z.number(),
    }),
  });
  ```

#### `observe()`

> [!WARNING]  
> `observe()` on the Stagehand instance is deprecated and will be removed in the next major version. Use `stagehand.page.observe()` instead.

> [!NOTE]  
> `observe()` currently only evaluates the first chunk in the page.

`observe()` is used to get a list of actions that can be taken on the current page. It's useful for adding context to your planning step, or if you unsure of what page you're on.

If you are looking for a specific element, you can also pass in an instruction to observe via: `observe({ instruction: "{your instruction}"})`.

- **Arguments:**

  - `instruction`: (optional) a `string` providing instructions for the observation. Defaults to "Find actions that can be performed on this page."
  - `modelName`: (optional) an `AvailableModel` string to specify the model to use
  - `modelClientOptions`: (optional) configuration options for the model client
  - `useVision`: (optional) a `boolean` to determine if vision-based processing should be used. Defaults to `false`
  - `domSettleTimeoutMs`: (optional) timeout in milliseconds for waiting for the DOM to settle

- **Returns:**

  - A `Promise` that resolves to an array of objects containing:
    - `selector`: a `string` representing the element selector
    - `description`: a `string` describing the possible action

- **Example:**
  ```javascript
  const actions = await stagehand.page.observe();
  ```

#### `close()`

`close()` is a cleanup method to remove the temporary files created by Stagehand. It's highly recommended that you call this when you're done with your automation.

- **Example:**
  ```javascript
  await stagehand.close();
  ```

#### `page` and `context`

`page` and `context` are instances of Playwright's `Page` and `BrowserContext` respectively. Use these methods to interact with the Playwright instance that Stagehand is using. Most commonly, you'll use `page.goto()` to navigate to a URL.

- **Example:**
  ```javascript
  await stagehand.page.goto("https://github.com/browserbase/stagehand");
  ```

### `log()`

`log()` is used to print a message to the browser console. These messages will be persisted in the Browserbase session logs, and can be used to debug sessions after they've completed.

Make sure the log level is above the verbose level you set when initializing the Stagehand instance.

- **Example:**
  ```javascript
  stagehand.log("Hello, world!");
  ```

## Model Support

Stagehand leverages a generic LLM client architecture to support various language models from different providers. This design allows for flexibility, enabling the integration of new models with minimal changes to the core system. Different models work better for different tasks, so you can choose the model that best suits your needs.

#### Currently Supported Models

Stagehand currently supports the following models from OpenAI and Anthropic:

- **OpenAI Models:**

  - `gpt-4o`
  - `gpt-4o-mini`
  - `gpt-4o-2024-08-06`

- **Anthropic Models:**
  - `claude-3-5-sonnet-latest`
  - `claude-3-5-sonnet-20240620`
  - `claude-3-5-sonnet-20241022`

These models can be specified when initializing the `Stagehand` instance or when calling methods like `act()` and `extract()`.

## How It Works

The SDK has two major phases:

1. Processing the DOM (including chunking - _see below_).
2. Taking LLM powered actions based on the current state of the DOM.

### DOM processing

Stagehand uses a combination of techniques to prepare the DOM.

The DOM Processing steps look as follows:

1. Via Playwright, inject a script into the DOM accessible by the SDK that can run processing.
2. Crawl the DOM and create a list of candidate elements.
   - Candidate elements are either leaf elements (DOM elements that contain actual user facing substance), or are interactive elements.
   - Interactive elements are determined by a combination of roles and HTML tags.
3. Candidate elements that are not active, visible, or at the top of the DOM are discarded.
   - The LLM should only receive elements it can faithfully act on on behalf of the agent/user.
4. For each candidate element, an xPath is generated. this guarantees that if this element is picked by the LLM, we'll be able to reliably target it.
5. Return both the list of candidate elements, as well as the map of elements to xPath selectors across the browser back to the SDK, to be analyzed by the LLM.

#### Chunking

While LLMs will continue to increase context window length and reduce latency, giving any reasoning system less stuff to think about should make it more reliable. As a result, DOM processing is done in chunks in order to keep the context small per inference call. In order to chunk, the SDK considers a candidate element that starts in a section of the viewport to be a part of that chunk. In the future, padding will be added to ensure that an individual chunk does not lack relevant context. See this diagram for how it looks:

![](./docs/media/chunks.png)

### Vision

The `act()` and `observe()` methods can take a `useVision` flag. If this is set to `true`, the LLM will be provided with a annotated screenshot of the current page to identify which elements to act on. This is useful for complex DOMs that the LLM has a hard time reasoning about, even after processing and chunking. By default, this flag is set to `"fallback"`, which means that if the LLM fails to successfully identify a single element, Stagehand will retry the attempt using vision.

### LLM analysis

Now we have a list of candidate elements and a way to select them. We can present those elements with additional context to the LLM for extraction or action. While untested on a large scale, presenting a "numbered list of elements" guides the model to not treat the context as a full DOM, but as a list of related but independent elements to operate on.

In the case of action, we ask the LLM to write a playwright method in order to do the correct thing. In our limited testing, playwright syntax is much more effective than relying on built in javascript APIs, possibly due to tokenization.

Lastly, we use the LLM to write future instructions to itself to help manage it's progress and goals when operating across chunks.

### Stagehand vs Playwright

Below is an example of how to extract a list of companies from the AI Grant website using both Stagehand and Playwright.

![](./docs/media/stagehand-playwright.png)

## Prompting Tips

Prompting Stagehand is more literal and atomic than other higher level frameworks, including agentic frameworks. Here are some guidelines to help you craft effective prompts:

### Do:

- **Use specific and concise actions**

```javascript
await stagehand.page.act({ action: "click the login button" });

const productInfo = await stagehand.page.extract({
  instruction: "find the red shoes",
  schema: z.object({
    productName: z.string(),
    price: z.number(),
  }),
});
```

- **Break down complex tasks into smaller, atomic steps**

Instead of combining actions:

```javascript
// Avoid this
await stagehand.page.act({ action: "log in and purchase the first item" });
```

Split them into individual steps:

```javascript
await stagehand.page.act({ action: "click the login button" });
// ...additional steps to log in...
await stagehand.page.act({ action: "click on the first item" });
await stagehand.page.act({ action: "click the purchase button" });
```

- **Use `observe()` to get actionable suggestions from the current page**

```javascript
const actions = await stagehand.page.observe();
console.log("Possible actions:", actions);
```

### Don't:

- **Use broad or ambiguous instructions**

```javascript
// Too vague
await stagehand.page.act({ action: "find something interesting on the page" });
```

- **Combine multiple actions into one instruction**

```javascript
// Avoid combining actions
await stagehand.page.act({ action: "fill out the form and submit it" });
```

- **Expect Stagehand to perform high-level planning or reasoning**

```javascript
// Outside Stagehand's scope
await stagehand.page.act({ action: "book the cheapest flight available" });
```

By following these guidelines, you'll increase the reliability and effectiveness of your web automations with Stagehand. Remember, Stagehand excels at executing precise, well-defined actions so keeping your instructions atomic will lead to the best outcomes.

We leave the agentic behaviour to higher-level agentic systems which can use Stagehand as a tool.

## Roadmap

At a high level, we're focused on improving reliability, speed, and cost in that order of priority.

You can see the roadmap [here](./ROADMAP.md). Looking to contribute? Read on!

## Contributing

> [!NOTE]  
> We highly value contributions to Stagehand! For support or code review, please join our [Slack community](https://join.slack.com/t/stagehand-dev/shared_invite/zt-2tdncfgkk-fF8y5U0uJzR2y2_M9c9OJA).

First, clone the repo

```bash
git clone git@github.com:browserbase/stagehand.git
```

Then install dependencies

```bash
npm install
```

Ensure you have the `.env` file as documented above in the Getting Started section.

Then, run the example script `npm run example`.

### Development tips

A good development loop is:

1. Try things in the example file
2. Use that to make changes to the SDK
3. Write evals that help validate your changes
4. Make sure you don't break existing evals!
5. Open a PR and get it reviewed by the team.

### Running evals

You'll need a Braintrust API key to run evals

```.env
BRAINTRUST_API_KEY=""
```

After that, you can run all evals at once using `npm run evals`

You can also run individual evals using `npm run evals -- your_eval_name`.

### Adding new evals

Running all evals can take some time. We have a convenience script `example.ts` where you can develop your new single eval before adding it to the set of all evals.

You can run `npm run example` to execute and iterate on the eval you are currently developing.

#### Adding a New Model

To add a new model to Stagehand, follow these steps:

1. **Define the Model**: Add the new model name to the `AvailableModel` type in the `LLMProvider.ts` file. This ensures that the model is recognized by the system.

2. **Map the Model to a Provider**: Update the `modelToProviderMap` in the `LLMProvider` class to associate the new model with its corresponding provider. This mapping is crucial for determining which client to use.

3. **Implement the Client**: If the new model requires a new client, implement a class that adheres to the `LLMClient` interface. This class should define all necessary methods, such as `createChatCompletion`.

4. **Update the `getClient` Method**: Modify the `getClient` method in the `LLMProvider` class to return an instance of the new client when the new model is requested.

### Building the SDK

Stagehand uses [tsup](https://github.com/egoist/tsup) to build the SDK and vanilla [esbuild](https://esbuild.github.io/d) to build the scripts that run in the DOM.

1. run `npm run build`
2. run `npm pack` to get a tarball for distribution

## Acknowledgements

This project heavily relies on [Playwright](https://playwright.dev/) as a resilient backbone to automate the web. It also would not be possible without the awesome techniques and discoveries made by [tarsier](https://github.com/reworkd/tarsier), and [fuji-web](https://github.com/normal-computing/fuji-web).

[Jeremy Press](https://x.com/jeremypress) wrote the original MVP of Stagehand and continues to be a major ally to the project.

## License

Licensed under the MIT License.

Copyright 2024 Browserbase, Inc.

================
File: ROADMAP.md
================
The purpose of this doc is to discuss future directions and plans for stagehand. To see actionable improvements, refer to the repo's issues.

## Improvements to Vision

~~The main thing people ask about with regards to stagehand is the lack of vision. Vision would unlock 2 major wins~~~

1. ~~the LLM will use the visual layout to improve context~~
2. ~~instructions can reference visual positioning in instructions~~

~~The challenge is to create an effective map between elements, and the screenshots. Fuji-web does this by supplying a regular screenshot and an annotated one in order to access the element map correctly.~~

We have a baseline implementation of the vision mechanism done.

Improvement suggestions:

- Reduce the size of the vision model for optimized and fast performance. <br> Example to incorporate: https://github.com/merveenoyan/smol-vision

Ultimately the question is by how much will this improve accuracy, and is it worth the cost latency trade off.

## Playwright

Stagehand currently depends on playwright. Is that a good thing? There are a couple of major benefits

1. LLMs can already write atomic playwright instructions really well
2. Using playwright de-risks a lot of flakiness around interacting with the web

[Garret](https://github.com/GRVYDEV) brought up an interesting point, that if instead stagehand could work with sort of a "browser automation assembly" we might be able to do more interesting things when it comes to a interactive workflow. It would also give stagehand a lot more flexibility in interacting with other projets like Langchain. However, I think an advantage of stagehand is that it will focus on the reliability of these atomic actions and will allow higher level code to avoid thinking about these things.

## Caching

LLMs are still expensive, and for automations that run many times on pages that rarely change, it is extremely wasteful to talk to an LLM every time. V0 of stagehand implemented caching that would rollback and retry if instructions failed. This is currently disabled until we learn more about how people want to use the library, and what kind of instructions are cachable in reality.

Reducing LLM calls where possible by hashing previous element maps on websites which have been visited can greatly increase speed and reduce cost of the library. There needs to be a mechanism to check for page updates, though (maybe some fuzzy DOM hash similarity metric)

A good middle ground might be to make instructions cachability opt in.

Also, the initial implementation of caching was pretty lax. if the instruction didn't error things would proceed. However, that doesn't mean everything worked as expected. Instead, we could use the list of candidate elements as a sort of key for the cache. Even if the overall structure changed, if the same candidate elements are there required to do the thing, we can do the thing without talking to an LLM.

## Latency & Performance & Cost

The current library is not optimized for performance, latency and cost yet.
`stagehand` should be very cheap to run and ideally very fast so that it can be a highly scalable AI agent web automation framework.

Here is a non-exhaustive list of thoughts / missing pieces to improve on this:

- DOM parsing is cheaper than vision. The library should be optimized to leverage DOM parsing as much as possible before falling back on vision for cost optimization.
- When using vision, can we optimize by reducing the size of the image so that it's barely visible to a human eye, but large enough for an llm to create a cheap element map? See [Improvements to vision](#improvements-to-vision)
- See [Caching](#caching) section above for details on reducing LLM calls through element map hashing and cache invalidation strategies.
- Recursion / Tree traversal improvements: many ideas here, we sometimes go really deep in the recursion stack unneccesarily, maybe some "look ahead" mechanism when drilling deeper in the DOM could be explored.
- Node pruning: prune more nodes based on the user query vs text or other representation of the node in the DOM tree
- Combining i-frames with clickable elements. Right now, if the element we seek is in i-frame which is not the main frame, we try to traverse all chunks in the mainframe first. It would be therefore way more efficient to have a mechanism to feed all possible elements into one LLM call from all i-frames (of course, we will have to handle infinite scrolling edge cases etc.)
- Chunking improvements - can we use a fast algorithm to get text from all top-level nodes and then based on the user query jump directly to the chunk desired? This could greatly increase the processing speed.
- Parallel processing of chunks: this one is obvious, but when searching for info in different chunk in parallel, we need to deal with locks when merging the information found in separate processes.

## Open Source Models

It would be great if `stagehand` could support open-source models as well as local or "in-browser" LLMs which could run server-side when running massive parallel jobs. (Is it possible to inject pure C/java LLM code implementation into a browser and use client side compute when running headless (client from the purview of owner of the stagehand job and that being the server)? Like a small 1-2B param quantized model which could run DOM segmentation tasks quite efficiently)

## Levels of abstraction

One thing we still haven't nailed is what the right level of abstraction is for this library. The opportunity is we get to define it! By talking to devs who are relying on automation for their product to truly work, we can uncover what is valuable to them in terms of effort saved while still being reliable. TLDR, talk to customers and make the product better.

## Environments

Python is clearly the next best place to support stagehand. Is there any value to making this runnable in the browser?

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "target": "es6",
    "noImplicitAny": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "*": ["node_modules/*", "lib/types/*"]
    },
    "skipLibCheck": true,
    "declaration": true
  },
  "exclude": ["node_modules", "dist", ".eslintrc.cjs"]
}
